// tslint:disable:no-namespace

import { Glue42Core } from "@glue42/core";
import { UnsubscribeFunction } from "callback-registry";
import { Glue42Workspaces } from "@glue42/workspaces-api";

/**
 * Factory function that creates a new Glue42 instance.
 */
export default function Glue(config?: Glue42.Config): Promise<Glue42.Glue>;

/**
 * @docmenuorder 1
 * @docname Glue
 * @intro
 * **Glue42 Enterprise** is a real-time user interface (UI) integration platform. Applications are combined at the user interface level to provide a better user experience (UX).
 * UI integration makes it easier for users to access the right data and functionality at the right time and also reduce the number of times they need to copy/paste their way between one application and another.
 * **Glue42 Enterprise** provides intuitive paths from one function to the next, in order to deliver business outcomes quickly and reliably. It allows developers to connect to any (legacy, 3rd party or modern)
 * web or desktop application and have multiple apps interact with each other in real time.
 *
 * The Glue42 JavaScript library enables JavaScript applications to participate in **Glue42 Enterprise** and use Glue42 functionalities via a set of APIs.
 *
 * ## Referencing the Library
 *
 * ### From a JavaScript File
 *
 * Glue42 JavaScript is a library available as a single JavaScript file, which you can include in your web applications using a `<script>` tag.
 * If you are using a Glue42 installer, you can find the JavaScript files in `%LOCALAPPDATA%\Tick42\GlueSDK\GlueJS\js\web`.
 *
 * ```html
 * <script type="text/javascript" src="desktop.umd.js"></script>
 * ```
 *
 * When deploying your application in production, it is recommended to always reference a specific minified version:
 *
 * ```html
 * <script type="text/javascript" src="desktop.umd.min.js"></script>
 * ```
 *
 * **Using the Glue42 CDN**
 *
 * You can alternatively point to Glue42 JavaScript `npm` packages and files via the [Glue42 CDN](https://cdn.glue42.com/) by using URLs in the format:
 *
 * ```html
 * https://cdn.glue42.com/:package&commat;:version/:file
 * ```
 *
 * - Using the latest version: `https://cdn.glue42.com/desktop&commat;latest`;
 * - Using a fixed version: `https://cdn.glue42.com/desktop&commat;5.6.1`
 * - Using a specific file different from the one defined in the `package.json`: `https://cdn.glue42.com/browse/desktop&commat;5.6.1/dist/web/&commat;glue42/desktop.min.js`
 * - To see all available versions and files, append `/` to the URL: `https://cdn.glue42.com/desktop/`
 *
 * ### From an NPM Module
 *
 * The Glue42 JavaScript library is also available as an `npm` package, which you can include as a dependency in your project and import in your code.
 * The currently available packages are [`&commat;glue42/core`](https://www.npmjs.com/package/&commat;glue42/core) and [`&commat;glue42/desktop`](https://www.npmjs.com/package/&commat;glue42/desktop).
 * The Core package is a subset of the Desktop package and offers basic functionalities for sharing data between applications (Interop, Shared Contexts, Pub/Sub, Metrics),
 * while the Desktop package offers additional options for sharing data between apps (Channels), as well as advanced window management functionalities (App Management, Layouts, Window Management).
 *
 * To include any of the packages as a dependency in your project, navigate to the root directory of your project and run:
 *
 * ```cmd
 * npm install &commat;glue42/desktop
 * ```
 *
 * Your `package.json` file now should have an entry similar to this:
 *
 * ```json
 * {
 *     "dependencies": {
 *         "&commat;glue42/desktop": "^5.6.1"
 *     }
 * }
 * ```
 *
 * ## Initializing the Library
 *
 * When included, the JavaScript library will register a global factory function called `Glue()`.
 * It should be invoked with an *optional* configuration object to initialize the library. The factory function will resolve with the initialized `glue` API object.
 *
 * Initialization in a Glue42 window:
 *
 * ```javascript
 * import Glue from "&commat;glue42/desktop"
 *
 * // You don't need to specify any configuration.
 * const initializeGlue42 = async () => {
 *     window.glue = await Glue();
 * };
 *
 * initializeGlue42().catch(console.error);
 * ```
 * See also the [**Glue42 Enterprise** documentation](../../../../getting-started/how-to/glue42-enable-your-app/javascript/index.html) for more details.
 */
export declare namespace Glue42 {
    export import AGM = Glue42Core.AGM;
    export import Contexts = Glue42Core.Contexts;
    export import Connection = Glue42Core.Connection;
    export import Logger = Glue42Core.Logger;
    export import Metrics = Glue42Core.Metrics;
    export import Auth = Glue42Core.Auth;
    export import Channels = Glue42.Channels.API;
    export import ChannelContext = Glue42.Channels.ChannelContext;
    export import Interop = Glue42Core.Interop;
    export import GDObject = Glue42Core.GDObject;
    export import GlueDesktopObject = Glue42Core.GlueDesktopObject;
    export import GatewayConfig = Glue42Core.GatewayConfig;
    export import MetricsConfig = Glue42Core.MetricsConfig;
    export import InprocGWSettings = Glue42Core.InprocGWSettings;
    export import GwTokenProvider = Glue42Core.GwTokenProvider;
    export import LoggerConfig = Glue42Core.LoggerConfig;

    /**
     * Optional configuration object when initializing the Glue42 library.
     * @docmenuorder 2
     */
    export interface Config extends Glue42Core.Config {
        /**
         * Whether to initialize the Application Manager or not.
         * @default false
         */
        appManager?: boolean | Glue42.AppManager.Mode;

        /**
         * Whether to initialize the Layouts API or not.
         * @default "slim"
         */
        layouts?: boolean | Glue42.Layouts.Mode;

        /**
         * Whether to initialize the Activities API or not.
         * @default "trackMyTypeAndInitiatedFromMe"
         */
        activities?: boolean | Glue42.Activities.ActivitiesModes;

        /**
         * Whether to initialize the Window Management API or not.
         * @default true
         */
        windows?: boolean;

        /**
         * Whether to initialize the Channels API or not.
         * @default false
         */
        channels?: boolean;

        /**
         * Whether to initialize the Displays library or not.
         */
        displays?: boolean;

        /**
         * A list of glue libraries which will be initiated internally and provide access to specific functionalities
         */
        libraries?: Array<(glue: Glue42.Glue, config?: Glue42.Config) => Promise<void>>;
    }

    /**
     * Instance of the initialized Glue42 library.
     */
    export interface Glue extends Glue42Core.GlueCore {
        /** Window Management library. */
        windows: Glue42.Windows.API;
        /** Activities library. */
        activities: Glue42.Activities.API;
        /** Application Management library. */
        appManager: Glue42.AppManager.API;
        /** Layouts library. */
        layouts: Glue42.Layouts.API;
        /** Channels library. */
        channels: Glue42.Channels.API;
        /** Hotkeys library. */
        hotkeys: Glue42.Hotkeys.API;
        /**
         * Displays library.
         * @since Glue42 3.9
         */
        displays: Glue42.Displays.API;
        /**
         * Intents API
         * @since Glue42 3.9
         */
        intents: Glue42.Intents.API;
        /**
         * Notifications API (alpha version)
         * @since Glue42 3.9
         */
        notifications: Glue42.Notifications.API;
        /**
         * Workspaces library
         * @since Glue42 3.10
         */
        workspaces?: Glue42Workspaces.API;

        /**
         * Themes API
         * @since Glue42 3.10
         */
        themes?: Glue42.Themes.API;

        /**
         * Preferences API
         * @since Glue42 3.12
         */
        prefs: Glue42.Preferences.API;
    }

    /**
     * @docmenuorder 3
     * @intro
     * An Activity is a collection of windows organized in a layout and sharing a private context. Here is an example of an Activity consisting of four windows:
     *
     * ![Example Activity](../../../../images/activities/activity.gif)
     *
     * Activities are usually registered as components in the application configuration and can be instantiated either as applications from the toolbar or programmatically - on demand.
     *
     * An *Activity type* is a definition template for an Activity, consisting of a collection of *window types*, their layout and an initial *Activity context*.
     *
     * A *window type* is a definition of a window, typically configured in the application configuration settings. However, the Activities API allows for an application to dynamically define both (window types and Activity types) at runtime.
     *
     * An *Activity context* is an object containing a set of key/value pairs which hold the current state of an Activity - e.g., the currently selected `party`, `instrument`, `order`, etc.
     *
     * An *Activity instance* is an instance of an *Activity type*, just like an object is an instance of a class in class-based languages. "Activity" is often used as a synonym for Activity instance.
     *
     * The Activities API enables:
     *
     * - the definition of window types and Activity types (collection of window types, layout and an initial context);
     * - starting an Activity instance of a specific Activity type;
     * - reacting to Activity events from an Activity-aware window, such as joining and leaving an Activity;
     * - application state synchronization via Activity context management functions;
     * - intra-Activity application collaboration via Activity Interop extension functions;
     *
     * The Activities API is accessible through the `glue.activities` object.
     */
    namespace Activities {

        /** @ignore */
        export interface LoggerConfig {
            publish: string;
            console: string;
            metrics: string;
        }

        /** Activities configuration object. */
        export interface Config {
            /**
             * @ignore
             * Activities mode.
             */
            mode?: boolean | ActivitiesModes;
            /** Types of activities to track. */
            typesToTrack: string[];
            /** @ignore */
            logger?: LoggerConfig;
        }

        /**
         * Activities API mode.
         */
        export type ActivitiesModes = "trackMyOnly" | "trackMyTypeAndInitiatedFromMe" | "trackAll" | "trackTypes";

        /**
         * Activities API
         *
         * @docmenuorder 1
         */
        export interface API {
            /** API version string. */
            version: string;

            /**
             * Returns `true` if the current window is activity aware, meaning that the window was created as
             * an activity participant - either a helper or an owner window.
             */
            aware: boolean;

            /** Returns `true` if the current window is activity aware and is currently participating in an activity. */
            inActivity: boolean;

            /** A lightweight, single activity oriented subset of the API which should be used by most activity applications. */
            my: My;

            /** Extended API that provides access to all running activities and windows and the available activity and window types. */
            all: ActivitiesManagement;

            /**
             * This method notifies applications when the API is ready to be used.
             * Note: If you are using the Glue42 library, you don't need to use this
             * as the Glue42 library is initialized when all included libraries are initialized.
             * @param callback Optional callback function to notify the application when the API is initialized.
             */
            ready(callback?: (api: API) => void): Promise<API>;

            /** Returns a list of frame colors that can be used for the activity frame. */
            getAvailableFrameColors(): string[];
        }

        /**
         * A lightweight, single activity oriented subset of the API which should be used
         * by most activity applications.
         *
         * @docmenuorder 2
         */
        export interface My {

            /** The current activity of the application. Can be `undefined` if currently not part of any activity. */
            activity: Activity;

            /** The current activity window. Can be `undefined` if the window is not part of any activity. */
            window: ActivityWindow;

            /** The context of the activity the application is part of. */
            context: any;

            /**
             * Updates the activity context using the properties of the `context` argument.
             * If the old context values are `{ a: 1, b: 2, c: 3 }`, invoking `updateContext({ b: 3, c: null, d: 4 })` will result in
             * the following context state: `{ a: 1, b: 3, d: 4 }`.
             * @param context Context object with which to update the current activity context.
             * @param callback Optional callback function that will be executed when the context has been updated.
             */
            updateContext(context: any, callback?: any): Promise<object>;

            /**
             * Replaces the specified activity context.
             * @param context Context object with which to replace the existing activity context.
             * @param callback Optional callback function that will be executed when the context has been replaced.
             */
            setContext(context: any, callback?: any): Promise<object>;

            /**
             * Creates a new window and joins it to the activity.
             * @param windowType The name or the window definition of the window you want to create and add to the activity.
             */
            createWindow(windowType: string | WindowDefinition): Promise<ActivityWindow>;

            /**
             * Creates a stacked set of windows and joins them to the activity.
             * @param windowTypes An array of window names or definitions you want to create and add to the activity.
             * @param timeout Optional timeout for the operation.
             */
            // tslint:disable-next-line:array-type
            createStackedWindows(windowTypes: (string | WindowDefinition)[], timeout?: number): Promise<ActivityWindow[]>;

            /**
             * Subscribes for the event which fires when the current window joins an activity.
             * @param callback Handler function for the event.
             */
            onActivityJoined(callback: (activity: Activity) => void): void;

            /**
             * Subscribes for the event which fires when the current window leaves an activity.
             * @param callback Handler function for the event.
             */
            onActivityLeft(callback: (activity: Activity) => void): void;

            /**
             * Subscribes for context updates.
             * @param callback Handler function that receives the updated context object, a delta object,
             * an array of removed context properties and the activity instance as arguments.
             */
            onContextChanged(callback: (context: object, delta: object, removed: string[], activity: Activity) => void): void;

            /**
             * @ignore
             * Creates a new activity by cloning the current one.
             * @param options Options for cloning an activity.
             * @param callback Handler function for the cloned activity.
             */
            clone(options: CloneOptions, callback: (activity: Activity) => void): Promise<Activity>;

            /**
             * @ignore
             * Attaches the current activity to another activity.
             * This stops the current activity. It can be restored by using the returned `AttachedActivityDescriptor` object.
             * @param activity Activity to which to attach the current activity.
             * @param tag
             */
            attach(activity: Activity | string, tag?: object): Promise<AttachedActivityDescriptor>;

            /** Sets the frame color of the current activity.
             * @param color The color you want to set for activity frame color.
             * @param callback Callback function invoked when the activity frame color has been changed.
             */
            setFrameColor(color: string, callback: () => void): Promise<Activity>;

            /** Returns the frame color of the current activity. */
            getFrameColor(): string;

            /** Subscribes for the event which fires when the activity frame color is changed. */
            onFrameColorChanged(callback: () => void): void;
        }

        /**
         * Extended API that provides access to all running activities and windows and all
         * available activity and window types.
         *
         * @docmenuorder 3
         */
        export interface ActivitiesManagement {
            /** Access point to the activity types. */
            activityTypes: ActivityTypesAPI;

            /** Access point to the window types. */
            windowTypes: WindowTypesAPI;

            /** Access point to the running activity windows. */
            windows: WindowingAPI;

            /** Access point to the running activity instances. */
            instances: InstancesAPI;

            /**
             * @ignore
             * Subscribes for the event which fires when an activity is attached to another activity.
             * @param callback
             */
            onAttached(callback: (activity: Activity, descriptor: AttachedActivityDescriptor) => void): void;

            /**
             * @ignore
             * Subscribes for the event which fires when two activities are detached.
             * @param callback
             */
            onDetached(callback: (newActivity: Activity, oldActivity: Activity, descriptor: AttachedActivityDescriptor) => void): void;

            /** Subscribes for the event which fires when the color of the activity frame is changed.
             * @param callback Handler function for the event. Receives the activity and the new activity frame color as arguments.
             */
            onActivityFrameColorChanged(callback: (activity: Activity, frameColor: string) => void): void;
        }

        /**
         * The Activity Types API enables you to define templates for activities. You can specify the window types the activity should contain,
         * the layout of the activity windows and the initial context they should share.
         *
         * @docmenuorder 4
         */
        export interface ActivityTypesAPI {

            /** Returns all known activity types or a specific activity type by name. */
            get(name?: string): ActivityType[] | ActivityType;

            /**
             * Registers a new activity type.
             * @param activityTypeName The name of the activity type to be created.
             * @param ownerWindowType The type of the owner window or a `WindowDefinition` of the owner window.
             * @param helperWindowTypes Types of helper windows (or `WindowDefinitions` of helper windows).
             * @param layoutConfig Layout configuration.
             * @param description Description of the new activity type.
             * @param callback Callback function to handle the result. If not specified, the method will return a `Promise` that resolves with the created activity type.
             */
            register(activityTypeName: string, ownerWindowType: string | WindowDefinition, helperWindowTypes?: string[] | WindowDefinition[], layoutConfig?: any, description?: string, callback?: (at: ActivityType) => void): Promise<ActivityType>;

            /**
             * Unregisters an existing activity type.
             * @param type The name of the activity type to be removed.
             */
            unregister(type: string): void;

            /**
             * Initiates a new activity of the specified type.
             * @param activityType The activity type to initiate.
             * @param context The initial context of the activity.
             * @param configuration Configuration with which you can override the predefined activity type configuration.
             * @param callback Callback function to handle the result.
             */
            initiate(activityType: string, context?: object, configuration?: OverrideTypeDefinition | WindowDefinition[], callback?: (act: Activity) => void): Promise<Activity>;

            /** Subscribes for `ActivityType` events.
             * @param handler Handler function for the event. Receives the activity type and the event name as arguments.
             */
            subscribe(handler: (act: ActivityType, event: string) => void): void;

            /** Unsubscribes from `ActivityType` events.
             * @param handler Handler function for the event. Receives the activity type and the event name as arguments.
             */
            unsubscribe(handler: (act: ActivityType, event: string) => void): void;
        }

        /**
         * The Window Types API enables you to create and handle windows by type.
         * @docmenuorder 5
         */
        export interface WindowTypesAPI {

            /** Get all available window types or a specific type by name. */
            get(name?: string): WindowType[] | WindowType;

            /**
             * Allows you to subscribe for window events - e.g., registering a window type.
             * @param handler Handler function for the event. Receives the window type and the event name as arguments.
             */
            subscribe(handler: (act: WindowType, event: string) => void): void;

            /** Unsubscribes from window events.
             * @param handler Handler function for the event. Receives the window type and the event name as arguments.
             */
            unsubscribe(handler: (act: WindowType, action: string) => void): void;

            /**
             * Registers a factory function for a given `WindowType`. It will be called once a window of that type is requested.
             * @param windowType Window type that will be constructed by the factory function. Can be a string (name of the window type)
             * or an object with `name` and `description` properties.
             * @param factoryMethod The factory function that will construct windows of the specified type.
             */
            registerFactory(windowType: string | { name: string, description: string }, factoryMethod: (activityInfo: ActivityWindowCreateRequest) => Promise<void>): Promise<any>;

            /**
             * Unregisters all factory methods for a given `WindowType`.
             * @param windowType Window type that is constructed by the factory function.
             */
            unregisterFactory(windowType: string): Promise<any>;
        }

        /** Request object for creating an activity window. Passed to the factory function for creating activity windows. */
        export interface ActivityWindowCreateRequest {

            /** ID of the activity for which the window will be created. */
            activityId?: string;

            /** Type of the activity for which the window will be created. */
            activityType?: string;

            /** Type of the window that will be created as an activity window. */
            type: string;

            /** Gateway token for the window that will be created as an activity window. */
            gwToken?: string;

            /** Configuration for the window that will be created as an activity window. */
            configuration?: any;
        }

        /**
         * The Windowing API enables you to handle activity windows.
         *
         * @docmenuorder 6
         */
        export interface WindowingAPI {
            /**
             * Returns activity windows based on a filter. If no filter is supplied, all activity windows are returned.
             * @param filter  Filter object describing which activity windows to return.
             */
            get(filter: { id?: string, type?: string, name?: string, activityId?: string }): ActivityWindow[];

            /**
             * Initializes an activity for the current window. By doing this, the window is announced as activity aware to the other activity participants.
             * @param activityWindowId The ID of the window that was created.
             * @param windowType Type of the window.
             */
            announce(activityWindowId?: string, windowType?: string): Promise<ActivityWindow>;

            /**
             * Creates a new window of a given type and joins it to an activity.
             *
             * @param activity Activity to which to join the window.
             * @param windowType The type of the window to be created and joined to the activity.
             * @param callback Optional callback to handle the result.
             */
            create(activity: Activity, windowType: string | WindowDefinition, callback?: (aw: ActivityWindow) => void): Promise<ActivityWindow>;

            /**
             * Allows you to subscribe for activity window events (e.g., window joining or leaving an activity).
             * @param handler Handler function which receives the activity, the activity window and the event as parameters.
             */
            subscribe(handler: (activity: Activity, window: ActivityWindow, event: any) => void): void;

            /** Unsubscribes from an activity window event. */
            unsubscribe(handler: (activity: Activity, window: ActivityWindow, event: any) => void): void;
        }

        /**
         * API for managing activity instances.
         * @docmenuorder 7
         */
        export interface InstancesAPI {
            /**
             * Returns all started activities.
             * @param activityType Can be a string or an `ActivityType`.
             */
            get(activityType?: string | ActivityType | string[] | ActivityType[]): Activity[];

            /**
             * Subscribes for activity status events.
             * @param handler Handler function that receives the activity, the new and the old activity statuses as parameters.
             */
            subscribe(handler: (activity: Activity, newStatus: ActivityStatus, oldStatus: ActivityStatus) => void): void;

            /** Unsubscribes from receiving activity status events.
             * @param handler Handler function that receives the activity, the new and the old activity statuses as parameters.
             */
            unsubscribe(handler: (activity: Activity, newStatus: ActivityStatus, oldStatus: ActivityStatus) => void): void;
        }

        /**
         * Object describing an activity.
         * @docmenuorder 8
         */
        export interface Activity {
            /** ID of the activity. */
            id: string;

            /** Type of the activity. */
            type: ActivityType;

            /** Context of the activity. */
            context: any;

            /** Status of the activity. */
            status: ActivityStatus;

            /** Owner window. */
            owner: ActivityWindow;

            /** List of all windows participating in the activity (including the owner window). */
            windows: ActivityWindow[];

            /**
             * Creates a new window and joins it to the activity.
             * @param windowType Type of the window to be created and joined to the activity.
             * @param callback Optional callback function to handle the result. Receives the created activity window as a parameter.
             */
            createWindow(windowType: string | WindowDefinition, callback?: (aw: ActivityWindow) => void): Promise<ActivityWindow>;

            /**
             * Creates a stacked set of windows and joins them to the activity.
             * @param windowTypes Types of windows to create and join to the activity.
             * @param timeout Optional timeout.
             * @param callback Optional callback to handle the result. Receives an array of the created activity windows as a parameter.
             */
            createStackedWindows(windowTypes: Array<(string | WindowDefinition)>, timeout?: number, callback?: (aw: ActivityWindow[]) => void): Promise<ActivityWindow[]>;

            /**
             * Returns all windows of a given type participating in the activity.
             * @param windowType Type of activity windows to return.
             */
            getWindowsByType(windowType: string): ActivityWindow[];

            /**
             * Replaces the activity context with a new one.
             * @param context Context object with which to replace the current activity context.
             * @param callback Optional callback function to handle the result. Receives the activity as a parameter.
             */
            setContext(context: any, callback?: (activity: Activity) => void): Promise<object>;

            /**
             * Updates the activity context with the properties from the provided context object.
             * If the old context values are `{ a: 1, b: 2, c: 3 }`, invoking `updateContext({ b: 3, c: null, d: 4 })` will result in
             * the following context state: `{ a: 1, b: 3, d: 4 }`.
             * @param context Context object with which to update the existing activity context.
             * @param callback Optional callback function to handle the result. Receives the activity as a parameter.
             */
            updateContext(context: any, callback?: (activity: Activity) => void): Promise<object>;

            /**
             * Subscribes for activity status change events.
             * @param handler Handler function for the event. Receives the activity, the new and the old activity statuses as parameters.
             */
            onStatusChange(handler: (activity: Activity, newStatus: ActivityStatus, oldStatus: ActivityStatus) => void): () => void;

            /**
             * Subscribes for window related events, like joining or removing a window from the activity.
             * @param handler Handler function for the event. Receives the activity, the window and the event as parameters.
             */
            onWindowEvent(handler: (activity: Activity, window: ActivityWindow, event: ActivityWindowEvent) => void): () => void;

            /**
             * Subscribes for activity context updates.
             * @param handler Handler function for the event.
             */
            onContextChanged(handler: ContextUpdateHandler): void;

            /** Stops the activity and closes all windows. */
            stop(): void;

            /**
             * @ignore
             * Creates a new activity with the same set of windows.
             * @param options Cloning options.
             */
            clone(options: CloneOptions): Promise<Activity>;

            /**
             * @ignore
             * Attaches the current activity to another activity. This stops the current activity. It can be restored by using the returned `AttachedActivityDescriptor`.
             * @param activity Activity to which to attach the current activity.
             * @param tag
             */
            attach(activity: Activity | string, tag?: object): Promise<AttachedActivityDescriptor>;

            /**
             * @ignore
             * Subscribes for the event which fires when another activity is attached the current one.
             * @param callback Callback function to handle the event. Receives the `AttachedActivityDescriptor` object of the attached activity as an argument.
             */
            onActivityAttached(callback: (descriptor: AttachedActivityDescriptor) => void): void;

            /**
             * @ignore
             * Subscribes for the event which fires when another activity is detached from this one.
             * @param callback Callback function to handle the event. Receives the restored activity and its `AttachedActivityDescriptor` object as arguments.
             */
            onDetached(callback: (newActivity: Activity, descriptor: AttachedActivityDescriptor) => void): void;
        }

        /**
         * Object for overriding the activity type definition when initiating a new activity of a specified type.
         */
        export interface OverrideTypeDefinition {
            /** Owner window. */
            owner: WindowDefinition;
            /** Helper windows. */
            helpers: WindowDefinition[];
        }

        /**
         * Activity context update handler.
         *
         * @docmenuorder 10
         *
         * @param context The full context object after the update.
         * @param delta Object that contains only the changed context properties.
         * @param removed Array of strings with the names of the removed properties.
         * @param activity The activity that was updated.
         */
        type ContextUpdateHandler = (context: object, delta: object, removed: string[], activity: Activity) => void;

        /** The status of the activity instance. */
        interface ActivityStatus {
            /** Returns the activity instance state. */
            getState(): string;

            /** Returns the message for the activity status. */
            getMessage(): string;

            /** Returns the time of the activity status. */
            getTime(): Date;
        }

        /** Activity window events for joining and leaving an activity. */
        enum ActivityWindowEvent {
            Joined,
            Removed
        }

        /** Defines an activity window. */
        interface WindowDefinition {
            /** Window type. */
            type: string;
            /** Window name. */
            name: string;
            /** Whether the window is independent or not. */
            isIndependent: boolean;
            /** Distance of the top left window corner from the left edge of the screen. */
            left?: number;
            /** Distance of the top left window corner from the top edge of the screen. */
            top?: number;
            /** Width of the window. */
            width?: number;
            /** Height of the window. */
            height?: number;
            /** Positions the new window relatively to an existing window. */
            relativeTo?: string | RelativeWindow;
            /** Relative direction of positioning the new window. Considered only if `relativeTo` is supplied. Can be "bottom", "top", "left", "right". */
            relativeDirection?: string;
            /** Whether to use an existing window when creating a new window. */
            useExisting?: boolean;
            /** The context of the new window. */
            context?: object;
            /** Deprecated. Do not use, to be removed. */
            arguments?: object;
            /** Deprecated. */
            windowStyleAttributes?: object;
        }

        /** Existing window used to relatively position another window. */
        export type RelativeWindow = {
            /** Type of the window that will be used to relatively position the new window. */
            type?: string;
            /** ID of the window that will be used to relatively position the new window. */
            windowId?: string;
        }

        /**
         * An activity type is a definition template for an activity consisting of a collection of window types,
         * their layout and an initial activity context.
         */
        interface ActivityType {
            /** Name of the activity type. */
            name: string;

            /** Description of the activity type. */
            description: string;

            /** A list of window types that will be created when initiating a new instance of that activity type. */
            helperWindows: WindowDefinition[];

            /** Returns the definition of the owner window of that activity type. */
            ownerWindow: WindowDefinition;

            /**
             * Initiates a new activity of this type.
             * @param context The initial context to be used for the new activity.
             * @param callback Optional callback to handle the result. Receives the created activity and a configuration object
             * with which you can override the default activity definition.
             */
            initiate(context: object, callback?: (activity: Activity) => void, configuration?: OverrideTypeDefinition | WindowDefinition[]): Promise<Activity>;
        }

        /**  A window type is a definition of a window, typically configured in Glue42 Desktop. */
        interface WindowType {

            /** Name of the window type. */
            name: string;

            /** Returns the Glue42 Desktop configuration related to this window type (as an application object from the AppManager API) */
            config: object;

            /**  All windows from that type. */
            windows: ActivityWindow[];
        }

        /** Object defining the window bounds. */
        interface WindowBounds {
            /** Distance of the top left window corner from the top edge of the screen. */
            top?: number;
            /** Distance of the top left window corner from the left edge of the screen. */
            left?: number;
            /** Width of the window. */
            width?: number;
            /** Height of the window. */
            height?: number;
        }

        /**
         * A window participating in an activity.
         * @docmenuorder 9
         */
        interface ActivityWindow {

            /** ID of the window. */
            id: string;

            /** Name of the window. */
            name: string;

            /** Type of the window. */
            type: WindowType;

            /**  The activity that the window is a part of. */
            activity: Activity;

            /** If `true`, the window is the owner of the activity. */
            isOwner: boolean;

            /** The Interop instance of that window. You can use it to invoke Interop methods for that window. */
            instance: Glue42Core.AGM.Instance;

            /** Returns the window as an object from the Window Management API (`glue.windows`). */
            underlyingWindow: Windows.GDWindow;

            /** If `true`, this is an independent window. */
            isIndependent(): boolean;

            /**
             * Sets window visibility.
             * @param isVisible If `true`, the window will be visible.
             * @param callback Optional callback to handle the result. Receives the activity window as an argument.
             */
            setVisible(isVisible: boolean, callback?: (aw: ActivityWindow) => void): Promise<ActivityWindow>;

            /**
             * Activates the window.
             * @param focus If `true`, the window will be on focus.
             */
            activate(focus: boolean): Promise<ActivityWindow>;

            /** Returns the window bounds. */
            getBounds(): Promise<WindowBounds>;

            /**
             * Sets the window bounds.
             * @param bounds Window bounds object.
             * @param callback Optional callback to handle the result. Receives the activity window as an argument.
             */
            setBounds(bounds: WindowBounds, callback?: (aw: ActivityWindow) => void): Promise<ActivityWindow>;

            /** Closes the window. */
            close(): Promise<any>;

            /**
             * Subscribes for the event which fires when the window joins an activity.
             * @param callback Callback to handle the event. Receives as an argument the activity which the window has joined.
             */
            onActivityJoined(callback: (activity: Activity) => void): void;

            /**
             * Subscribes for the event which fires when the window leaves an activity.
             * @param callback Callback to handle the event. Receives as an argument the activity which the window has left.
             */
            onActivityRemoved(callback: (activity: Activity) => void): void;
        }

        /**
         * @ignore
         * Object describing an activity that has been attached to another activity.
         * Can be used to restore the attached activity.
         */
        interface AttachedActivityDescriptor {
            /** ID of the owner window of the attached activity. */
            ownerId: string;
            /** Helper windows IDs. */
            windowIds: string[];
            /** The frame color of the attached activity. */
            frameColor: string;
            /** Context object of the attached activity. */
            context: object;
            /** */
            tag: object;

            /**
             * Restores the activity by detaching it from the activity it was previously attached to.
             * @param descriptor Object describing the attached activity.
             */
            detach(descriptor?: AttachedActivityDescriptor): Promise<Activity>;
        }

        /**
         * @ignore
         * Options for cloning an activity.
         */
        interface CloneOptions {
            /** Context for the new activity. */
            context: object;
            /** Offset from the top left corner of the original activity. */
            offset: { left: number, top: number };
        }
    }

    /**
     * @docmenuorder 2
     * @intro
     * The Application Management API provides a way to manage **Glue42 Enterprise** applications. It offers abstractions for:
     *
     * - *Application* - a program as a logical entity, registered in **Glue42 Enterprise** with some metadata (name, description, icon, etc.) and with all the configuration needed to spawn one or more instances of it.
     * The Application Management API provides facilities for retrieving application metadata and for detecting when an application is started.
     *
     * - *Instance* - a running copy of an application. The Application Management API provides facilities for starting/stopping application instances and tracking application related events.
     *
     * ![App Management](../../../../images/app-management/app-management.gif)
     *
     * The Application Management API is accessible through the `glue.appManager` object.
     */
    namespace AppManager {

        /**
         * Application Management API
         */
        export interface API extends AppManager, Entitlements {
            /** Returns the current application instance. */
            myInstance: Instance;

            /**
             * In memory store for applications - allows you to import application definitions at runtime
             * @since Glue42 3.12
             */
            inMemory: InMemoryStore;

            /** Notifies when the Application Management API is ready to be used. */
            ready(): Promise<{} | void>;

            /** Exits Glue42 */
            exit(options?: ExitOpts): Promise<any>;

            /**
             * Restarts Glue42
             * @since 4.7.0
             */
            restart(options?: ExitOpts): Promise<any>;

            /**
             * Notifies when Glue42 GD will shut down or restart. If you return a promise from the callback it will be waited (up until 60 sec) before shutdown continues
             * @param callback Callback to handle the event. Receives as an argument object with the property restarting.
             * @since 5.4.0
             */
            onShuttingDown(callback: (arg: { restarting: boolean }) => Promise<void>): void;
        }

        export interface InMemoryStore {
            /**
             * Imports the provided collection of application definitions.
             * @param definitions A collection of application definition objects to be imported.
             * @param mode Import mode, by default it is "replace". "replace" mode replaces all existing definitions with the provided collection, "merge" mode adds (if new) or updates (if already existing) the provided definitions.
             * @returns ImportResult
             */
            import(definitions: Definition[], mode?: "replace" | "merge"): Promise<ImportResult>;

            /**
             * Exports all known application definitions from the in memory store
             */
            export(): Promise<Definition[]>;

            /**
             * Removed an application definition. This method will fire onAppRemoved if a definition was removed and it will do nothing if an app with this was was not found.
             * @param name The name of the application to be removed.
             */
            remove(name: string): Promise<void>;

            /** Removes all applications from the store */
            clear(): Promise<void>;
        }

        export interface ImportResult {
            imported: string[];
            errors: Array<{ app: string; error: string }>;
        }

        /** Application Management API that allows you to handle your Glue42 enabled applications. */
        export interface AppManager {

            /**
             * Returns an application by name.
             * @param name Name of the desired application.
             */
            application(name: string): Application;

            /** Returns an array with all registered applications for the current branch. */
            applications(): Application[];

            /** Returns an array with all running application instances. */
            instances(): Instance[];

            /**
             * Notifies when a new application instance has been started.
             * @param callback Callback function to handle the event. Receives the started application instance as a parameter.
             */
            onInstanceStarted(callback: (instance: Instance) => any): UnsubscribeFunction;

            /**
             * Notifies when starting a new application instance has failed.
             * @param callback Callback function to handle the event. Receives the started application instance as a parameter.
             */
            onInstanceStartFailed(callback: (instance: Instance) => any): UnsubscribeFunction;

            /**
             * Notifies when an application instance has been stopped.
             * @param callback Callback function to handle the event. Receives the stopped application instance as a parameter.
             */
            onInstanceStopped(callback: (instance: Instance) => any): UnsubscribeFunction;

            /**
             * Notifies when an application instance is updated.
             * @param callback Callback function to handle the event. Receives the updated application instance as a parameter.
             */
            onInstanceUpdated(callback: (instance: Instance) => any): UnsubscribeFunction;

            /**
             * Notifies when an application is registered in the environment.
             * @param callback Callback function to handle the event. Receives the added application as a parameter.
             */
            onAppAdded(callback: (app: Application) => any): UnsubscribeFunction;

            /**
             * Notifies when the application is removed from the environment.
             * @param callback Callback function to handle the event. Receives the removed application as a parameter.
             */
            onAppRemoved(callback: (app: Application) => any): UnsubscribeFunction;

            /**
             * Notifies when an application is available and can be started.
             * @param callback Callback function to handle the event. Receives the available application as a parameter.
             */
            onAppAvailable(callback: (app: Application) => any): UnsubscribeFunction;

            /**
             * Notifies when an application is no longer available and cannot be started.
             * @param callback Callback function to handle the event. Receives the unavailable application as a parameter.
             */
            onAppUnavailable(callback: (app: Application) => any): UnsubscribeFunction;

            /**
             * Notifies when the configuration for an application has changed.
             * @param callback Callback function to handle the event. Receives the changed application as a parameter.
             */
            onAppChanged(callback: (app: Application) => any): UnsubscribeFunction;
        }

        /** @ignore */
        interface Entitlements {

            /** Returns the region under which the API operates. */
            getRegion(success?: (region: string) => any, error?: (err: any) => any): void | Promise<string>;

            /**
             * Returns the list of branches for which the user has coverage.
             * Returns an error if your application does not have access to App Management admin functionality.
             */
            getBranches(success?: (branches: Branch[]) => any, error?: (err: any) => any): void | Promise<Branch[]>;

            /**
             * Retrieves the user branch that the API operates under.
             * Returns an error if your application does not have access to App Management admin functionality.
             */
            getCurrentBranch(success?: (branch: Branch) => any, error?: (err: any) => any): void | Promise<Branch>;

            /**
             * Returns the effective entitlement value for a specific function.
             * Returns null if there's no such functional entitlement.
             * The entitlements depend on the branch that is selected.
             * Most applications will typically only care about the function name.
             * However, the API allows a functional entitlement to be associated with a scalar value.
             */
            getFunctionalEntitlement(funct: string, success?: (entitlement: string) => any, error?: (err: any) => any): void | Promise<string>;

            /** Same as getFunctionalEntitlement but you can specify a branch */
            getFunctionalEntitlementBranch(funct: string, branch: string, success?: (entitlement: string) => any, error?: (err: any) => any): void | Promise<string>;

            /**
             * Changes the current branch under which the API operates.
             * Functional entitlements and the list of applications
             * a user is entitled to run depend on the selected branch.
             */
            setCurrentBranch(branch: string, success?: (resMsg: string) => any, error?: (err: any) => any): void | Promise<string>;

            /** Changes the region under which the API operates. */
            setRegion(region: string, success?: (resMsg: string) => any, error?: (err: any) => any): void | Promise<string>;

            /** Returns  info about the currently logged on user. */
            currentUser(success?: (user: UserInfo) => any, error?: (err: any) => any): void | Promise<UserInfo>;

            /** Checks whether the currently logged on user is entitled to perform a certain function. */
            canI(functionName: string, success?: (allowed: boolean) => any, error?: (err: any) => any): void | Promise<boolean>;

            /** Checks whether the currently logged on user is entitled to perform a certain function on a given branch. */
            canIBranch(functionName: string, branch: string, success?: (allowed: boolean) => any, error?: (err: any) => any): void | Promise<boolean>;

            /** Allows you to track when branches collection has been modified */
            onBranchesChanged(callback: (branches: Branch[]) => any): void;

            /** Allows you to track when the current branch has changed */
            onBranchChanged?(callback: (branch: Branch) => any): void;
        }

        /** @ignore */
        type Mode = "startOnly" | "skipIcons" | "full";

        /** @ignore */
        interface Config {
            activities: Glue42.Activities.API;
            agm: Glue42Core.AGM.API;
            logger: Glue42Core.Logger.API;
            mode: Mode;
            windows: Glue42.Windows.API;
            gdMajorVersion: number;
        }

        /** Object describing an application. */
        interface Application {
            /** Application name. */
            name: string;

            /** Application title. */
            title: string;

            /** Application version. */
            version: string;

            /**
             * If `true`, the application is auto started with the framework.
             * @since 3.1.0
             */
            autoStart: boolean;

            /**
             * Whether the application is a shell application.
             * @default false
             */
            isShell: boolean;

            /**
             * The caption of the application.
             * @since 3.1.0
             */
            caption: string;

            /**
             * Whether the application is present in the Application Manager or not.
             * @since 3.1.0
             * @default false
             */
            hidden: boolean;

            /** The container identifier. */
            container: string;

            /**
             * The activity type associated with this application (populated only if this is an activity application).
             * @since 3.1.0
             */
            activityType: string;

            /**
             * The activity window type associated with this application (populated only if this is an activity application).
             * @since 3.1.0
             */
            activityWindowType: string;

            /**
             * The window settings object passed to Glue42 Desktop.
             * @since 3.1.0
             */
            windowSettings: Glue42.Windows.WindowSettings;

            /**
             * If `true`, the application can have multiple instances.
             * @since 3.1.0
             * @default true
             */
            allowMultiple: boolean;

            /** If `true`, the application is available and can be started. */
            available: boolean;

            /** `Base64` string of the app icon. */
            icon: string;

            /** The URL of the app icon. */
            iconURL: string;

            /** Sort indicator used when ordering apps in a list. */
            sortOrder: number;

            /** Custom configuration object attached to the application. */
            userProperties: PropertiesObject;

            /**
             * If `true`, the application is an activity.
             * @since 3.0.8
             */
            isActivity: boolean;

            /**
             * Glue42 Desktop legacy configuration object for the application.
             * This is kept for legacy applications, all properties are available in the application object now.
             */
            configuration: LegacyAppConfigProperties;

            /** Instances of that app. */
            instances: Instance[];

            /** Type of the application. */
            type: string;

            /**
             * Mode of the application window.
             * If the application is running in a Glue42 window, the possible modes are "flat", "html" or "tab".
             * If the mode cannot be determined (e.g., external apps, activity definitions), the value is "unknown".
             */
            mode: Glue42.Windows.WindowMode | "unknown";

            /**
             * Start an instance of the application.
             * @param context Context to be passed to the started application.
             * @param options Options object in which you can specify window setting (that will override the default configuration settings), as well as other additional options.
             * @since 3.0.5
             */
            start(context?: object, options?: ApplicationStartOptions): Promise<Instance>;

            /**
             * Notifies you when instances of this application are started.
             * @param callback Callback to handle the event. Receives the instance object as an argument.
             */
            onInstanceStarted(callback: (instance: Instance) => any): void;

            /**
             * Notifies you when instances of this application are stopped.
             * @param callback Callback to handle the event. Receives the instance object as an argument.
             */
            onInstanceStopped(callback: (instance: Instance) => any): void;

            /**
             * Notifies you when the application becomes available.
             * @param callback Callback to handle the event. Receives the application object as an argument.
             */
            onAvailable(callback: (app: Application) => any): void;

            /**
             * Notifies you when the application becomes unavailable.
             * @param callback Callback to handle the event. Receives the application object as an argument.
             */
            onUnavailable(callback: (app: Application) => any): void;

            /**
             * Notifies you when the application configuration is changed.
             * @param callback Callback to handle the event. Receives the application object as an argument.
             */
            onChanged(callback: (app: Application) => any): void;

            /**
             * Notifies you when the application is removed.
             * @param callback Callback to handle the event. Receives the application object as an argument.
             */
            onRemoved(callback: (app: Application) => any): void;
        }

        /** Generic object for passing properties, settings, etc., in the for of key/value pairs. */
        export interface PropertiesObject {
            [key: string]: any
        }

        /**
         * Object describing an application instance
         */
        export interface Instance {
            /** Instance ID. */
            id: string;

            /** The application object of that instance. */
            application: Application;

            /** Returns the activity object if the instance is part of an activity. */
            activity: Activities.Activity;

            /**
             * Returns the instances of the other windows in the activity if this instance is part of an activity.
             * @since 3.0.8
             */
            activityInstances: Instance[];

            /**
             * Returns the instance of the owner window of the activity if this instance is part of an activity.
             * @since 3.0.8
             */
            activityOwnerInstance: Instance;

            /**
             * The window associated with the instance (as an object from the Window Management API).
             * If the application instance is an activity instance, this is `undefined`.
             * @since 3.0.8
             * @deprecated Use getWindow instead
             */
            window: Windows.GDWindow;



            /**
             * The starting context of the instance.
             * @deprecated Use `getContext()` instead.
             */
            context: object;

            /** Title of the instance. */
            title: string;

            /**
             * Whether the application instance is an activity instance.
             * @since 3.0.8
             */
            isActivityInstance: boolean;

            /**
             * The activity ID (only if the apps is part of an activity).
             * @since 3.0.8
             */
            activityId: string;

            /**
             * If `true`, the instance is running as part of an activity.
             * @since 3.0.8
             */
            inActivity: boolean;

            /**
             * If `true`, the instance is running as a single window application (not part of an activity).
             * @since 3.0.8
             */
            isSingleWindowApp: boolean;

            /** Interop instance. Use this to invoke Interop methods for that instance. */
            agm: Partial<Glue42Core.AGM.Instance>;

            /** Stops the instance. */
            stop(): Promise<void>;

            /** Activates the instance. */
            activate(): Promise<Glue42Core.AGM.InvocationResult<any>>;

            /**
             * Notifies when the Interop library is ready to be used.
             * @param callback Callback function to handle the event. Receives the instance as an argument.
             */
            onAgmReady(callback: (instance: Instance) => any): void;

            /**
             * Notifies when the instance is stopped.
             * @param callback Callback function to handle the event. Receives the instance as an argument.
             */
            onStopped(callback: (instance: Instance) => any): void;

            /* The starting context of the instance. */
            getContext(): Promise<object>;

            /**
             * Retrieves the window object corresponding to that instance
             * @since 3.6.7
             */
            getWindow(): Promise<Windows.GDWindow>;
        }

        /**
         * @ignore
         */
        export interface Branch {
            Name: string;
            Roles: Roles[];
        }

        /**
         * @ignore
         */
        export interface UserInfo {
            FirstName: string;
            LastName: string;
            LoginName: string;
        }

        /**
         * @ignore
         */
        export interface ExitOpts {
            autoSave: boolean;
        }

        /**
         * Object with options for starting an application.
         */
        export interface ApplicationStartOptions extends Glue42.Windows.WindowSettings {
            /**
             * Whether to wait for the Interop library to be initialized.
             * @default true
             */
            waitForAGMReady?: boolean;
            /**
             * If `true`, the application layout will not be saved on close and if a saved layout exists, it will be ignored.
             * @default false
             */
            ignoreSavedLayout?: boolean;
        }

        /** Legacy application configuration options. */
        export interface LegacyAppConfigProperties {
            /** Whether to auto start the application. */
            autoStart?: boolean;
            /** Caption for the application. */
            caption?: string;
            /**  */
            hidden?: boolean;
            /** Container identifier. */
            container?: string;
            /** Activity type (if the application is in an activity). */
            activityType?: string;
            /** If `true`, multiple instances of the app can be started. */
            allowMultiple?: boolean;
        }

        /** @ignore */
        export type Roles = "Full" | "ReadWrite" | "ReadOnly";

        export interface Definition {
            /**
             * Application name. Should be unique.
             */
            name: string;

            /** Type of the application - "window" for web apps hosted in Glue42 */
            type: string;

            /**
             * The title of the application. Sets the window's title.
             */
            title?: string;

            /**
             * Application version.
             */
            version?: string;

            /**
             * Detailed configuration.
             */
            details: any;

            /**
             * Generic object for passing properties, settings, etc., in the for of key/value pairs. Accessed using the app.userProperties property.
             */
            customProperties?: PropertiesObject;

            /**
             * Application icon.
             */
            icon?: string;

            /**
             * Application caption.
             */
            caption?: string;

            /**
             * The list of intents implemented by the Application
             */
            intents?: Intent[];
        }

        /**
         * An intent definition.
         */
        export interface Intent {
            /**
             * The name of the intent to 'launch'. In this case the name of an Intent supported by an Application.
             */
            name: string;

            /**
             * An optional display name for the intent that may be used in UI instead of the name.
             */
            displayName?: string;

            /**
             * A comma separated list of the types of contexts the intent offered by the application can process, here the first part of the context type is the namespace e.g."fdc3.contact, org.symphony.contact".
             */
            contexts?: string[];

            /**
             * Custom configuration for the intent that may be required for a particular desktop agent.
             */
            customConfig?: object;
        }
    }

    /**
     * @intro
     * **Glue42 Enterprise** provides a way for applications to programmatically capture screenshots of the available monitors, of windows and window groups.
     * Based on custom logic you can capture one or all monitors in order to save a snapshot of the visual state at a given moment.
     *
     * The Displays API is accessible through the `glue.displays` object.
     */
    namespace Displays {

        /**
         * Displays API
         * @since Glue42 Enteprise 3.9
         */
        export interface API {
            /** Returns all `Display` objects. */
            all(): Promise<Display[]>;

            /** Returns a single display by ID.
             * @param id ID of the desired display.
             */
            get(id: number): Promise<Display>;

            /** Returns a single display by window ID.
             * @param id Window ID of the desired display.
             */
            getByWindowId(id: string): Promise<Display>;

            /**
             * Returns the primary display.
             */
            getPrimary(): Promise<Display>;

            /** Returns a `base64` string of the screenshots of all displays. The returned value depends on the `combined` property specified in the options object.
             * @param options Options object specifying the way the captured screenshots should be returned.
             */
            captureAll(options: CaptureAllOptions): Promise<string | string[]>;

            /** Returns a `base64` string of the screenshot of a single display.
             * @param options Options object specifying the ID of the display to capture and the size of the returned image.
             */
            capture(options: CaptureOptions): Promise<string>;

            /** Returns the X and Y coordinates of the mouse cursor. */
            getMousePosition(): Promise<Point>;
        }

        /**
         * Object describing a display.
         */
        interface Display {
            /** Unique identifier associated with the display. */
            id: number;

            /** Bounds of the display (width, height, left and top coordinates) */
            bounds: Bounds;

            /** The working area of the display. */
            workingArea: Bounds;

            /** Display resolution. */
            dpi: number;

            /** Whether this is the primary display. */
            isPrimary: boolean;

            /** Index assigned to the display by the operating system. */
            index: number;

            /** Name assigned to the display by the operating system. */
            name: string;

            /** Aspect ratio of the display (e.g., 16:9). */
            aspectRatio: string;

            /** The scale factor of the returned display. */
            scaleFactor: number;

            /**
             * Captures a screenshot of the current display.
             * @param size Size options for the returned image. Can be absolute or relative size.
             */
            capture: (size: ScaleOptions | AbsoluteSizeOptions) => Promise<string>;
        }

        /**
         * Object describing the bounds of the display.
         */
        interface Bounds {
            /** The height of the display (integer). */
            height: number;

            /** The width of the display (integer). */
            width: number;

            /** The horizontal coordinate of the top left corner of the display (integer). */
            left: number;

            /** The vertical coordinate of the top left corner of the display (integer). */
            top: number;
        }

        /** Coordinates of a point on the screen. */
        export interface Point {
            /** The X coordinate of the point. */
            x: number;
            /** The Y coordinate of the point. */
            y: number;
        }

        /**
         * Options for capturing a single display.
         */
        interface CaptureOptions {
            /** A `number` specifying the ID of the targeted display. */
            id: number;
            /** Accepts either a `ScaleOptions` or an `AbsoluteSizeOptions` object, specifying the size of the output image. */
            size?: ScaleOptions | AbsoluteSizeOptions;
        }

        /**
         * Options for capturing all displays.
         */
        interface CaptureAllOptions {
            /** Specifies whether to return a single image (if `true`) of all captured displays or a separate image (if `false`) for each captured display. */
            combined: boolean;
            /** Accepts either a `ScaleOptions` or an `AbsoluteSizeOptions` object, specifying the size of the output image. */
            size?: ScaleOptions | AbsoluteSizeOptions;
        }

        /**
         * Absolute size of the returned image.
         */
        interface AbsoluteSizeOptions {
            /** Width of the returned image. */
            width?: number;
            /** Height of the returned image. */
            height?: number;
            /**
             * Specifies whether to keep the aspect ratio of the output image when you specify `width` and/or `height` of the output image.
             * If `true` and both `width` and `height` are set, then the specified `width` will be used as a basis for the output image aspect ratio.
             */
            keepAspectRatio?: boolean;
        }

        /**
         * Relative size of the returned image.
         */
        interface ScaleOptions {
            /** Specifies the size of the output image relative to the actual screen size. */
            scale: number;
        }
    }
    /**
     * @docmenuorder 6
     * @intro
     * The Layouts API allows you to save the arrangement and context of any set of applications running in **Glue42 Enterprise** as a named Layout and later restore it.
     * You can also choose a default Global Layout which **Glue42 Enterprise** will load upon startup.
     *
     * The Layouts library supports different types of Layouts - e.g., Global, Application Default, Workspace.
     *
     * The Layouts API is accessible through the `glue.layouts` object.
     */
    namespace Layouts {

        /**
         * Supported layout types are Global and Activity.
         * Global Layout saves all running applications and their state. By default, ignores hidden windows.
         * Activity Layout saves applications running in an activity, the activity state and the individual windows states.
         * By default, saves the activity of the current application but can be configured to save any activity.
         * Activity layouts can be restored as new activity instances or joined to any running activity.
         *
         * @docmenuorder 11
         *
         */
        export type LayoutType = "Global" | "Activity" | "ApplicationDefault" | "Swimlane" | "Workspace";

        /**
         * Library initialization mode:
         * - `slim` - in this mode the application will be able to store custom data when a layout is saved and will not track layout events.
         * It will not be able to manage layouts - create, delete, rename.
         * - `full` - in this mode the application will be able to store custom data when a layout is saved and will track layout events.
         * It will be able to manage layouts - create, delete, rename.
         * - `fullWaitSnapshot` - same as `full`, only the library will notify that it is ready when it receives the snapshot of the layouts.
         * In `full` mode, `ready()` is called when the library has successfully subscribed to a stream (a little earlier).
         *
         * @docmenuorder 10
         */
        export type Mode = "slim" | "full" | "fullWaitSnapshot";

        /**
         * Controls the import behavior. If `replace` (default), all existing layouts will be removed.
         * If `merge`, the layouts will be added to the existing ones.
         *
         * @docmenuorder 12
         *
         */
        export type ImportMode = "replace" | "merge";

        /** Layouts library configuration object. */
        export interface Configuration {
            /** Layouts mode. */
            mode: Mode;
            /**
             * If `true`, the context of the current window will be saved when the window is closed.
             * @since 3.10
             * @default false
             */
            autoSaveWindowContext: boolean;
            /** @ignore */
            agm: Glue42Core.AGM.API;
            /** @ignore */
            logger: Glue42Core.Logger.API;
            /** @ignore */
            appManager: Glue42.AppManager.API;
            /** @ignore */
            activityGetter: () => Glue42.Activities.API;
            /** @ignore */
            gdMajorVersion: number;
        }

        /**
         * Layouts API.
         *
         * @docmenuorder 1
         *
         */
        export interface API {
            /**
             * Fetches a saved layout or returns undefined if a layout with the provided name and type does not exist.
             * @param type Type of the layout to fetch.
             * @param name Name of the layout to fetch.
             */
            get(name: string, type: LayoutType): Promise<Layout | undefined>;

            /**
             * Returns a lightweight, summarized version of all layouts of the provided type.
             * @param type Type of the layouts to fetch.
             */
            getAll(type: LayoutType): Promise<LayoutSummary[]>;

            /**
             * Notifies when the library is ready to be used.
             * @ignore
             */
            ready(): Promise<void>;

            /** Lists all layouts. */
            list(): Layout[];

            /**
             * Saves a new layout.
             * @param layout Options for saving a layout.
             */
            save(layout: NewLayoutOptions): Promise<Layout>;

            /**
             * Imports one or more layouts.
             * @param layouts Layouts to import.
             * @param mode Mode for importing the layouts - `replace` or `merge`.
             */
            import(layouts: Layout[], mode?: ImportMode): Promise<void>;

            /**
             * Returns all layouts in the system.
             */
            export(layoutType?: LayoutType): Promise<Layout[]>;

            /**
             * Restores a layout.
             * @param options Options for restoring a layout.
             */
            restore(options: RestoreOptions): Promise<void>;

            /**
             * Removes a layout
             * @param type Type of the layout to remove.
             * @param name Name of the layout to remove.
             */
            remove(type: string, name: string): Promise<void>;

            /**
             * Renames a layout.
             * @param layout Existing layout to rename.
             * @param newName The new name of the layout.
             */
            rename(layout: Layout, newName: string): Promise<void>;

            /**
             * Updates the metadata of a layout.
             * @param layout Existing layout to update.
             */
            updateMetadata(layout: Layout): Promise<void>;

            /**
             * Returns the last restored global layout
             *
             */
            getCurrentLayout(): Promise<Layout | undefined>;

            /**
             * Hibernates a layout.
             * @param name The name of the layout
             * @param options Options for hibernating a layout.
             * @since 4.8 and Glue42 3.9
             */
            hibernate(name: string, options?: Glue42.Layouts.HibernationOptions): Promise<void>;

            /**
             * Resumes a layout.
             * @param name The name of the layout.
             * @param context The context of the layout
             * @since 4.8 and Glue42 3.9
             */
            resume(name: string, context?: any, options?: Glue42.Layouts.ResumeOptions): Promise<void>;

            /**
             * Updates the context saved for your application in the currently loaded layout
             * @param context the new context
             */
            updateAppContextInCurrent(context: object): Promise<void>;

            /**
             * Updates the context that will be saved as a default context for the current window.
             * @param context New context that will be saved as a default window context.
             * @since Glue42 3.10
             */
            updateDefaultContext(context: object): Promise<void>

            /**
             * Notifies when a new layout is added.
             * @param callback Callback function to handle the event. Receives the layout as a parameter and returns an unsubscribe function.
             */
            onAdded(callback: (layout: Layout) => void): () => void;

            /**
             * Notifies when a layout is removed.
             * @param callback Callback function to handle the event. Receives the layout as a parameter and returns an unsubscribe function.
             */
            onRemoved(callback: (layout: Layout) => void): () => void;

            /**
             * Notifies when a layout is changed.
             * @param callback Callback function to handle the event. Receives the layout as a parameter and returns an unsubscribe function.
             */
            onChanged(callback: (layout: Layout) => void): () => void;

            /**
             * Notifies when a layout is renamed.
             * @param callback Callback function to handle the event. Receives the layout as a parameter and returns an unsubscribe function.
             */
            onRenamed(callback: (layout: Layout) => void): () => void;

            /**
             * @ignore
             * Subscribes for raw stream events. For debugging purposes only.
             * @param callback Callback function to handle the event. Receives the event as a parameter and returns an unsubscribe function.
             */
            onEvent(callback: (event: any) => void): () => void;

            /**
             * Subscribes for layout save requests.
             * @param callback The callback passed as an argument will be invoked when a layout save is requested.
             * You have the option to save data (context) which will be restored when the layout is restored.
             * Returns an unsubscribe function.
             */
            onSaveRequested(callback: (info?: SaveRequestContext) => SaveRequestResponse): () => void;

            /**
             * Notifies when a global layout is restored
             * @param callback
             */
            onRestored(callback: (Layout: Layout) => void): UnsubscribeFunction;

            /**
             * Sets a new default global layout
             * @param name
             */
            setDefaultGlobal(name: string): Promise<void>;

            /**
             * Clears the default global layout
             */
            clearDefaultGlobal(): Promise<void>;

            /**
             * Returns the default global layout (might be undefined)
             */
            getDefaultGlobal(): Promise<Layout | undefined>;
        }

        /**
         * Describes a layout and its state.
         *
         * @docmenuorder 2
         *
         */
        export interface Layout extends LayoutSummary {
            /** Array of component objects describing the applications that are saved in the layout. */
            components: LayoutComponent[];

            /** Version of the layout */
            version?: string;
        }

        export interface LayoutSummary {
            /** Name of the layout. The name is unique per layout type. */
            name: string;

            /** Type of the layout. */
            type: LayoutType;

            /** Context object passed when the layout was saved. */
            context?: any;

            /** Metadata passed when the layout was saved. */
            metadata?: any;
        }

        /** Type of the layout component - activity or application. */
        export type ComponentType = "activity" | "application";

        /**
         * Saved component (single window application or activity) with its state (bounds, context).
         */
        export interface LayoutComponent {
            type: string;

            /** Type of the component - can be application or activity. */
            componentType?: ComponentType;

            /** Object describing the application bounds, name, context, etc. */
            state: any;
        }

        /**
         * Object describing the layout that you want to save.
         */
        export interface NewLayoutOptions {
            /** Name of the layout. */
            name: string;

            /**
             * Type of the layout.
             * @default "Global"
             */
            type?: LayoutType;

            /**
             * Context (application specific data) to be saved with the layout.
             * Used to transfer data to the applications when restoring a layout.
             */
            context?: any;

            /**
             * Metadata to be saved with the layout.
             */
            metadata?: any;

            /** Only if the layout type is `Global`. If `true` (default), the layout will not include hidden apps. */
            ignoreHidden?: boolean;

            /** Only if the layout type is `Global`. Ignores the current instance when saving a layout. `False` by default. */
            ignoreMyInstance?: boolean;

            /**
             * Only if the layout type is `Activity`. Will save the layout of the activity with the provided ID.
             * If not passed, will use the activity that the calling application participates in. If the current
             * application is not in an activity, an error will be thrown.
             */
            activityId?: string;
        }

        /**
         * Options object for restoring layouts.
         */
        export interface RestoreOptions {

            /**
             * Name of the layout to restore.
             */
            name: string;

            /**
             * Type of the layout to restore.
             * @default "Global"
             */
            type?: string;

            /**
             * If `true`, will close all visible running instances before restoring the layout.
             * Exceptions are the current application and the Application Manager application.
             * The default is `true` for `Global` layouts and `false` for `Activity` layouts.
             */
            closeRunningInstance?: boolean;

            /**
             * Context object that will be passed to the restored apps. It will be merged with the saved context object.
             */
            context?: object;

            /**
             * Only if the type is `Activity`. If `true` (default), will try to reuse existing windows when restoring the layout.
             */
            reuseWindows?: boolean;

            /**
             * Only if the type is `Activity`. If set, the activity will be restored and joined to the specified activity.
             * If not set, a new activity instance will be created from the saved layout.
             */
            activityIdToJoin?: string;

            /**
             * Only if the type is `Activity`. If `true` (default), will set the activity context upon restore.
             */
            setActivityContext?: boolean;

            /**
             * Only if the type is `Activity` and `activityId` is set. If `true`, will restore the activity owner window.
             */
            restoreActivityOwner?: boolean;

            /**
             * Only if the type is `Activity` and `activityId` is set.
             * With this you can specify that certain window types should not be restored.
             */
            ignoreActivityWindowTypes?: string[];

            /**
             * Restore options for the splash screen.
             */
            splash?: RestoreSplashOptions;

            /**
             * Restore timeout option.
             */
            timeout?: number;
        }

        /**
         * Options object for hibernating layouts.
         */
        export interface HibernationOptions {
            /**
             * Context object that will be passed to the restored apps. It will be merged with the saved context object.
             */
            context?: object;

            /**
             * Metadata to be saved with the layout.
             */
            metadata?: any;
        }

        export interface ResumeOptions {
            /**
             * Whether to stop any already running apps before resuming the layout.
             */
            cleanUp?: boolean;
        }

        /**
         * Options for the restore splash screen.
         */
        export interface RestoreSplashOptions {
            /** Text for the splash screen. */
            text: string;
            /** Text color. */
            textColor: string;
            /** Background color. */
            backgroundColor: string;
            /** Animation color. */
            animationColor: string;
        }

        /**
         * Object returned as a result to a save layout request.
         */
        export interface SaveRequestResponse {

            /** Context object specific to the application. */
            windowContext: object;

            /**
             * The window can return activity context if it is an owner window of the activity.
             * On restore, this context will be merged with the activity context passed when restoring the layout.
             */
            activityContext: object;
        }

        export interface SaveRequestContext {
            context?: unknown;
            layoutName: string;
            layoutType: LayoutType;
        }
    }

    /**
     * @docmenuorder 3
     * @intro
     * The Window Management API lets you create and manipulate windows and is the basis of the Application Management API.
     * It allows users to group a set of desktop windows so that they move, maximize and minimize together.
     * The Window Management API provides the following features, not found in any normal browser:
     *
     * - 3 types of window modes: flat, tab or HTML
     * - Complete control and customization of the windows:
     *     - visibility - create hidden windows, show them later;
     *     - bounds - set window location and/or size;
     *     - user interaction - allow a window to be sticky, enable/disable minimize/maximize/close buttons;
     *     - add custom buttons to the windows and respond accordingly to user interaction with them;
     *     - organize windows into tabs that the user can also tear off;
     *
     * Native applications, as opposed to web applications, can have more than one window. This means that after you make your native application Glue42 enabled,
     * your application windows do not automatically become Glue42 enabled. You can choose which windows to register (or not register) as Glue42 windows
     * so that they can use **Glue42 Enterprise** functionalities.
     *
     * Web and native windows are handled by **Glue42 Enterprise** as window abstractions. This means that:
     *
     * - You can use any technology adapter we offer (JavaScript, .NET, Java, etc.) to control any window (web or native).
     * - From an end-user perspective, there is no difference between web or native windows.
     * - Feature parity is provided by the different technology adapters.
     *
     * The Window Management API is accessible through the `glue.windows` object.
     */
    namespace Windows {
        export import Screen = Glue42.Screen;

        /**
         * Settings for Glue42 Windows.
         */
        export interface WindowSettings {
            /**
             * Distance of the top left window corner from the top edge of the screen.
             * @default 0
             */
            top?: number;

            /**
             * Distance of the top left window corner from the left edge of the screen.
             * @default 0
             */
            left?: number;

            /**
             * Window width.
             * @default 400
             */
            width?: number;

            /**
             * Window height.
             * @default 400
             */
            height?: number;

            /**
             * If `false`, the window will not contain a close button.
             * @default true
             */
            allowClose?: boolean;

            /**
             * If `false`, the tab header will not contain a close button.
             * @default true
             */
            allowTabClose?: boolean;

            /**
             * If `false`, the window will not contain a collapse button.
             * @default true
             */
            allowCollapse?: boolean;

            /**
             * If `false`, the window will not contain an activity related forward button.
             * @default true
             */
            allowForward?: boolean;

            /**
             * If `false`, the window will not contain a maximize button.
             * @default true
             */
            allowMaximize?: boolean;

            /**
             * If `false`, the window will not contain a minimize button.
             * @default true
             */
            allowMinimize?: boolean;

            /**
             * If `false`, the window will not unstick from other windows.
             * @default true
             */
            allowUnstick?: boolean;

            /**
             * If `false`, the window will not contain a lock/unlock button.
             * @default false
             */
            allowLockUnlock?: boolean;

            /**
             * If `true`, when moving the window operation ends, the window will snap to one of the approaching edges of another window
             * (if any of the approaching edges are marked with red).
             * @default true
             */
            autoSnap?: boolean;

            /**
             * If `true`, a snapped window will adjust its bounds to the same width/height of the window it has stuck to,
             * and/or will occupy the space between other windows (if any).
             * @default true
             */
            autoAlign?: boolean;

            /** Image as `base64` encoded string that will be used as a taskbar icon for the window. The supported formats are `png`, `ico`, `jpg`, `apng`. */
            base64ImageSource?: string;

            /** Can be a color name such as "red", or a hex-encoded RGB or ARGB value. */
            borderColor?: string;

            /**
             * Defines the height of the window when collapsed.
             * @default -1
             */
            collapseHeight?: number;

            /**
             * If `true`, allows opening a developer console (using F12) for the new window.
             * @default true
             */
            devToolsEnable?: boolean;

            /** Object that defines file download behavior in the window. */
            downloadSettings?: DownloadSettings;

            /**
             * If `true`, the window will start collapsed.
             * @default false
             */
            isCollapsed?: boolean;

            /**
             * If `true`, the window will open as a child window, sharing the lifetime and the environment of the opener.
             * @default false
             * @deprecated Use isChild
             */
            isPopup?: boolean;

            /**
             * If `true`, the window will ope  n as a child window, sharing the lifetime and the environment of the opener.
             * @default false
             */
            isChild?: boolean;

            /**
             * If `true`, the window will stick to other Glue42 Windows forming groups.
             * @default true
             */
            isSticky?: boolean;

            /**
             * If `false`, the window will not be on focus when created.
             * @default true
             */
            focus?: boolean;

            /**
             * If `false`, the window cannot be moved.
             * @default true
             */
            hasMoveAreas?: boolean;

            /**
             * If `false`, the window cannot be resized by dragging its borders, maximizing, etc.
             * @default true
             */
            hasSizeAreas?: boolean;

            /**
             * If `true`, the window will be started as a hidden window.
             * @default false
             */
            hidden?: boolean;

            /**
             * If `true`, this will allow the users to navigate back (CTRL+Left) and forward (CTRL+Right) through the web page history.
             * @default true
             */
            historyNavigationEnabled?: boolean;

            /** Specifies the maximum window height. */
            maxHeight?: number;

            /** Specifies the maximum window width. */
            maxWidth?: number;

            /**
             * Specifies the minimum window height.
             * @default 30
             */
            minHeight?: number;

            /**
             * Specifies the minimum window width.
             * @default 50
             */
            minWidth?: number;

            /**
             * Glue42 Window type. Possible values are `flat`, `tab` and `html`.
             * @default "flat"
             */
            mode?: WindowMode;

            /**
             * How much of the window area is to be considered as a moving area (meaning you can move the window using it).
             * The string value corresponds to the left, top, right and bottom borders of the window.
             * Setting `moveAreaThickness` to "0, 20, 0, 0" will set a 20 pixel thick move area at the top of the window.
             * @default "0, 12, 0, 0"
             */
            moveAreaThickness?: string;

            /**
             * Margin for the top window move area. The string value corresponds to the left, top, right and bottom borders of the move area.
             * Setting `moveAreaTopMargin` to "10, 0, 0, 10" will take away 10 pixels from the left and the right side of the move area.
             * @default "0, 0, 0, 0"
             */
            moveAreaTopMargin?: string;

            /**
             * If `true`, the window will appear on top of the z-order.
             * @default false
             */
            onTop?: boolean;

            /** The ID of the window that will be used to relatively position the new window. Can be combined with `relativeDirection`. */
            relativeTo?: string;

            /**
             * Direction (`"bottom"`, `"top"`, `"left"`, `"right"`) of positioning the window relatively to the `relativeTo` window. Considered only if `relativeTo` is supplied.
             * @default "right"
             */
            relativeDirection?: RelativeDirection;

            /**
             * If `false`, the window will not appear on the Windows taskbar.
             * @default true
             */
            showInTaskbar?: boolean;

            /**
             * Determines whether the window will have a title bar.
             * @default true
             */
            showTitleBar?: boolean;

            /**
             * How much of the window area is to be considered as a sizing area (meaning you can resize the window using that area).
             * The string value corresponds to the left, top, right and bottom borders.
             * @default "5, 5, 5, 5"
             */
            sizeAreaThickness?: string;

            /**
             * Specifies the active Glue42 Window snapping edges.
             * Possible values are: `top`, `left`, `right`, `bottom`, `all` or any combination of them (e.g., `left, right`).
             * @default "all"
             */
            snappingEdges?: string;

            /**
             * Specifies the start window location.
             * Possible options are `Automatic` (The Glue42 Window decides where the window will be positioned) and `CenterScreen`.
             */
            startLocation?: string;

            /**
             * Specifies the Glue42 window frame color. Accepts hex color as string (e.g. `"#666666"`) or named HTML colors (e.g. `"red"`).
             * @default "#5b8dc9"
             */
            stickyFrameColor?: string;

            /**
             * If set, the Glue42 Window can only stick to windows that have the same group.
             * @default "Any"
             */
            stickyGroup?: string;

            /** Specifies the tab group ID. If two or more tab windows are defined with the same ID, they will be hosted in the same tab window. */
            tabGroupId?: string;

            /** The tab index of the current window. All tabs in a common tab container have different indices. */
            tabIndex?: number;

            /**
             * Tab is selected.
             * @default true
             */
            tabSelected?: boolean;

            /**
             * The tab title.
             * @default ""
             */
            tabTitle?: string;

            /**
             * The tab tooltip.
             * @default ""
             */
            tabTooltip?: string;

            /** Sets the window title. To work properly, there should be a title HTML tag in the page. */
            title?: string;

            /** Object that defines loader behavior. */
            loader?: Loader;

            /**
             * If `true`, this will set a random (from a predefined list of colors) frame color to the new window.
             * @default false
             */
            useRandomFrameColor?: boolean;

            /**
             * If set, the window will start in the specified state (maximized, minimized, normal).
             * @default "normal"
             */
            windowState?: WindowState;
        }

        export interface WindowCreateOptions extends WindowSettings {
            /** The name of the window */
            windowName?: string;

            /** The URL of the app to be loaded in the new window */
            url?: string;
        }

        export interface WindowButtons {
            allowClose?: boolean;
            allowCollapse?: boolean;
            allowLockUnlock?: boolean;
            allowMaximize?: boolean;
            allowMinimize?: boolean;
        }

        export interface SizeConstraints {
            maxWidth?: number;
            maxHeight?: number;
            minWidth?: number;
            minHeight?: number;
        }

        export interface WindowStyle extends WindowButtons, SizeConstraints {
            hidden?: boolean;
            focus?: boolean;
        }

        /**
         * Settings that define the window download behavior.
         */
        export interface DownloadSettings {
            /**
             * If `true`, will autosave the file (without asking the user where to save it). If `false`, a system save dialog will appear.
             * @default true
             */
            autoSave?: boolean;

            /**
             * If `true`, will open the folder that contains the downloaded file after the download is completed.
             * @default false
             */
            autoOpenPath?: boolean;

            /**
             * If `true`, will open the download file after the download is completed.
             * @default false
             */
            autoOpenDownload?: boolean;

            /**
             * If `true`, enables the window to download files.
             * @default true
             */
            enable?: boolean;

            /**
             * If `true`, a download bar tracking the progress will appear at the bottom of the window when downloading. If `false`, the download process will be invisible.
             * @default true
             */
            enableDownloadBar?: boolean;
        }

        /**
         * Window buttons settings.
         */
        export interface ButtonInfo {
            /** Unique ID for the button. */
            buttonId: string;

            /** Button position. */
            order?: number;

            /** Button tooltip. */
            tooltip?: string;

            /** Button image in `base64` format. */
            imageBase64: string;

        }

        /** Object describing the window bounds. */
        export interface Bounds {
            /** Vertical coordinate of the top left window corner. */
            top: number;
            /** Horizontal coordinate of the top left window corner. */
            left: number;
            /** Window width. */
            width: number;
            /** Window height. */
            height: number;

            [key: string]: number | undefined;
        }

        /** Object describing the size of the window. */
        export interface Size {
            /** Window width. */
            width?: number;
            /** Window height. */
            height?: number;
        }

        /**
         * Options for creating flydown windows.
         */
        export interface FlydownOptions {
            /** An array of defined zones which when triggered will show a flydown window. */
            zones: FlydownZone[];
            /** Range where the flydown will remain active.  */
            activeArea?: Bounds;
            /** Default horizontal offset for all flydown zones. */
            horizontalOffset?: number;
            /** Default vertical offset for all flydown zones. */
            verticalOffset?: number;
            /** The location (`"bottom"`, `"top"`, `"left"`, `"right"` or `"none"`) where the flydown will appear, relative to the defined flydown zone.
             * If `"none"` is passed, the flydown will appear at `{ left: 0, top: 0 }` of the flydown trigger zone.
             */
            targetLocation?: PopupTargetLocation;
            /** The ID of the window which will be used as a flydown window. */
            windowId?: string;
            /** The size of the rendered flydown window (`width` and `height`).
             * Can be an object with a specific size, or a callback that calculates the size.
             * The callback receives the flydown data and a function to cancel the flydown.
             */
            size?: ((data: ShowFlydownData, cancel: () => void) => Promise<Size>) | Size;
        }

        /**
         * Object describing a flydown window.
         */
        export interface ShowFlydownData {
            /** The ID of the zone which triggered the flydown. */
            zoneId: string;
            /** The initial bounds of the flydown, if set before the callback is invoked. If not set, this defaults to `{ left: 0, top: 0, height: 200, width: 200}`. */
            flydownWindowBounds: Bounds;
            /** The ID of the window used as a flydown. */
            flydownWindowId: string;
        }

        /**
         * Object describing a flydown trigger zone.
         */
        export interface FlydownZone {
            /** Unique ID of the flydown trigger zone. */
            id: string;
            /** The size of the rendered flydown window (`width` and `height`).
             * Can be an object with a specific size, or a callback that calculates the size.
             * The callback receives the flydown data and a function to cancel the flydown.
             */
            flydownSize?: ((data: ShowFlydownData, cancel: () => void) => Promise<Size>) | Size;
            /** Bounds of the zone which can trigger a flydown window.
             * These bounds are relative to the target window, so the coordinates `{ left: 0, top: 0 }`
             * correspond to the top left corner of the target window, rather than the top left corner of the monitor. */
            bounds: Bounds;
            /** The location (`"bottom"`, `"top"`, `"left"`, `"right"` or `"none"`) where the flydown will appear, relative to the defined flydown zone.
             * If `"none"` is passed, the flydown will appear at `{ left: 0, top: 0 }` of the flydown trigger zone.
             */
            targetLocation?: PopupTargetLocation;
            /** The ID of the window which will be used as a flydown window. */
            windowId?: string;
        }

        /** Flydown instance returned when creating flydown windows. */
        export interface Flydown {
            /** Function that clears all flydown trigger zones from the window when invoked. */
            destroy: () => Promise<void>;
            /** The options object used when the flydown was created. */
            options: FlydownOptions;
        }

        /**
         * Options for creating popup windows.
         */
        export interface PopupOptions {
            /** The ID of the window which will be used as a popup window. */
            windowId: string;
            /** The bounds of the area around which the popup will appear. */
            targetBounds: Bounds;
            /** The size of the rendered popup window (`width` and `height`). */
            size: Size;
            /** The location (`"bottom"`, `"top"`, `"left"`, `"right"` or `"none"`) where the popup will appear, relative to the defined popup area.
             * If `"none"` is passed, the popup will appear at `{ left: 0, top: 0 }` of the popup area.
             */
            targetLocation: PopupTargetLocation;
            /** The horizontal offset from the target bounds (applied only to `left` and `right` target locations). */
            horizontalOffset?: number;
            /** The vertical offset from the target bounds (applied only to `top` and `bottom` target locations). */
            verticalOffset?: number;
        }

        /**
         * Location of the window (flydown or popup) relative to the defined trigger zone (flydown trigger zone or popup trigger area).
         */
        export enum PopupTargetLocation {
            None = "none",
            Left = "left",
            Right = "right",
            Top = "top",
            Bottom = "bottom"
        }

        /**
         * Window loader settings.
         */
        export interface Loader {

            /**
             * Enable or disable the loader.
             * @default true
             */
            enabled?: boolean;

            /**
             * Hide the loader once the page is loaded.
             * @default true
             */
            loaderHideOnLoad?: boolean;

            /**
             * Changes the loader animation speed.
             * @default 1
             */
            loaderSpeed?: number;

            /**
             * Changes the background of the loader page.
             * @default "#1C2D3B"
             */
            loaderBackground?: string;

            /**
             * Type of the loading animation.
             * @default "DoubleBounce"
             */
            loaderType?: string;

            /** Sets a specific size (in pixels) for the loader animation. */
            loaderSize?: number;

            /**
             * Sets a size factor for the loader animation relative to the window size.
             * @default 0.3
             */
            loaderSizeFactor?: number;

            /**
             * Text that will show below the loader animation.
             * @default "Loading"
             */
            loaderText?: string;

            /** Size of the loader text.
             * @default 12
             */
            loaderTextSize?: number;

            /**
             * Color for the loader text.
             * @default "#F1F1F1"
             */
            loaderTextColor?: string;

            /** If set, will auto hide the loader after the specified period of time (in ms). */
            timeout?: number;
        }

        /**
         * Window settings for a window detached from a window group.
         */
        export interface DetachOptions {
            /** Position the new window relatively to an existing window. */
            relativeTo?: GDWindow;
            /** Relative direction of positioning the new window. Considered only if `relativeTo` is supplied. Can be "bottom", "top", "left", "right". */
            relativeDirection?: RelativeDirection;
            /** Window width. */
            width?: number;
            /** Window height. */
            height?: number;
            /** Window bounds. */
            bounds?: Partial<Bounds>;
            /** Whether to hide or show to window header. */
            hideTabHeader?: boolean;
        }

        /**
         * Window settings for a window being attached to a tab group.
         */
        export interface AttachOptions {
            /* Determines the position of the tab in the tab group. */
            index?: number;
            /** Whether the tab window is selected. */
            selected?: boolean;
        }

        /**
        * Window settings for a window extracted from a window group.
        */
        export interface UngroupOptions {
            /** Bounds for the extracted window. */
            bounds?: Partial<Bounds>;
            /** If `true`, the extracted window will be on focus. **/
            focus?: boolean;
        }

        /**
         * Relative direction of positioning the window.
         * @default "right"
         */
        export type RelativeDirection = "top" | "left" | "right" | "bottom";

        /**
         * Glue42 Window mode.
         * @default "flat"
         */
        export type WindowMode = "html" | "flat" | "tab";

        /**
         * Window state.
         * @default "normal"
         */
        export type WindowState = "normal" | "maximized" | "minimized";

        /** Options for capturing a display. */
        export interface CaptureOptions {
            /** Size of the output image. Can be relative or absolute. */
            size?: ScaleOptions | AbsoluteSizeOptions;
        }

        /** Absolute size for the output image when capturing a display. */
        export interface AbsoluteSizeOptions {
            /** Image width. */
            width?: number;
            /** Image height. */
            height?: number;
            /** Specifies whether to keep the aspect ratio of the output image when you specify `width` and/or `height` of the output image.
             * If `true` and both `width` and `height` are set, then the specified `width` will be used as a basis for the output image aspect ratio.
             * @default true
             */
            keepAspectRatio?: boolean;
        }

        export interface ScaleOptions {
            /** Specifies the size of the output image relative to the actual screen size. */
            scale: number;
        }

        /* Configuration settings for overriding the default global Glue42 Windows settings.*/
        export interface WindowsConfiguration {
            /* If `true`, the caption of window groups will not be visible.*/
            hideGroupCaption?: boolean;
            /* If `true`, the Sticky Button will be visible.*/
            showStickyButton?: boolean;
            /* If `true`, the Extract Button will be visible.*/
            showExtractButton?: boolean;
            /* If `true`, the Glue42 Windows will be able to stick to each other and form groups.*/
            sticky?: boolean;
        }

        export interface WindowConfiguration {
            /**
             * If `false`, a window in HTML mode can not be moved.
             */
            hasMoveAreas?: boolean;
            /**
             * If `false`, a window cannot be resized by dragging its borders, maximizing, etc.
             */
            hasSizeAreas?: boolean;
            /**
             * How much of the outer window area is to be considered as a moving area (meaning you can move the window using it). The string value corresponds to the left, top, right and bottom borders.
             */
            moveAreaThickness?: string;
            /**
             * The Glue42 window can contain a move area thickness left margin. The margin is related to the left border of `moveAreaThickness` only. The string value corresponds to the left, top, right and bottom.
             */
            moveAreaLeftMargin?: string;
            /**
             * The Glue42 window can contain a move area thickness top margin. The margin is related to the top border of `moveAreaThickness` only. The string value corresponds to the left, top, right and bottom.
             */
            moveAreaTopMargin?: string;
            /**
             * The Glue42 window can contain a move area thickness right margin. The margin is related to the right border of `moveAreaThickness` only. The string value corresponds to the left, top, right and bottom.
             */
            moveAreaRightMargin?: string;
            /**
             * The Glue42 window can contain a move area thickness bottom margin. The margin is related to the bottom border of `moveAreaThickness` only. The string value corresponds to the left, top, right and bottom.
             */
            moveAreaBottomMargin?: string;
            /**
             * How much of the outer window area is to be considered as a sizing area (meaning you can resize the window using it). The string value corresponds to the left, top, right and bottom borders.
             */
            sizeAreaThickness?: string;
            /**
             * Determines the conditions under which the window buttons will be visible. Valid only for Glue42 Windows in `html` mode.
             */
            buttonsVisibility?: "off" | "onDemand" | "always" | "onFocus";
        }
        export interface PrintToPDFOptions {
            /**
             * If `true`, will autosave the file (without asking the user where to save it). If `false`, a system save dialog will appear.
             * @default false
             */
            autoSave?: boolean;
            /**
             * If `true`, will open the folder that contains the PDF file.
             * @default false
             */
            autoOpenPath?: boolean;
            /**
             * If `true`, will open the PDF file.
             * @default false
             */
            autoOpen?: boolean;
            /**
             * Header and footer for the PDF.
             */
            headerFooter?: {
                /* The title for the PDF header. */
                title?: string;
                /* The URL for the PDF footer. */
                url?: string;
            };
            /**
             * Set to `true` for landscape layout, `false` for portrait layout.
             */
            landscape?: boolean;
            /**
             * Specifies the type of margins to use. Uses 0 for default margin, 1 for no
             * margin, and 2 for minimum margin.
             */
            marginsType?: number;
            /**
             * The scale factor of the web page. Can range from 0 to 100.
             */
            scaleFactor?: number;
            /**
             * The page range to print.
             */
            pageRanges?: PageRange[];
            /**
             * Specify page size of the generated PDF file. Can be `A3`, `A4`, `A5`, `Legal`, `Letter`, `Tabloid` or an `Object` with `height` and `width` in microns.
             */
            pageSize?: ('A3' | 'A4' | 'A5' | 'Legal' | 'Letter' | 'Tabloid') | Size;
            /**
             * Whether to print CSS backgrounds.
             */
            printBackground?: boolean;
            /**
             * Whether to print selection only.
             */
            printSelectionOnly?: boolean;
        }

        export interface PrintOptions {
            /**
             * Whether to ask the user for print settings. Default is `false`.
             */
            silent?: boolean;
            /**
             * Prints the background color and image of the web page. Default is `false`.
             */
            printBackground?: boolean;
            /**
             * Set the printer device name to use. Must be the system-defined name and not the
             * user-friendly-name, e.g 'Brother_QL_820NWB' and not 'Brother QL-820NWB'.
             */
            deviceName?: string;
            /**
             * Whether the printed web page will be in color or grayscale. Default is `true`.
             */
            color?: boolean;
            margins?: Margins;
            /**
             * Whether the web page should be printed in landscape mode. Default is `false`.
             */
            landscape?: boolean;
            /**
             * The scale factor of the web page.
             */
            scaleFactor?: number;
            /**
             * The number of pages to print per sheet.
             */
            pagesPerSheet?: number;
            /**
             * Whether the web page should be collated.
             */
            collate?: boolean;
            /**
             * The number of copies of the web page to print.
             */
            copies?: number;
            /**
             * The page range to print.
             */
            pageRanges?: PageRange[];
            /**
             * Set the duplex mode of the printed web page. Can be `simplex`, `shortEdge`, or
             * `longEdge`.
             */
            duplexMode?: 'simplex' | 'shortEdge' | 'longEdge';
            dpi?: {
                horizontal?: number;
                vertical?: number;
            };
            /**
             * String to be printed as page header.
             */
            header?: string;
            /**
             * String to be printed as page footer.
             */
            footer?: string;
            /**
             * Specify page size of the generated PDF file. Can be `A3`, `A4`, `A5`, `Legal`, `Letter`, `Tabloid` or an `Object` with `height` and `width` in microns.
             */
            pageSize?: ('A3' | 'A4' | 'A5' | 'Legal' | 'Letter' | 'Tabloid') | Size;
        }

        /* The page range to print */
        export interface PageRange {
            /*  Index of the first page to print (0-based). */
            from: number;
            /*  Index of the last page to print (inclusive, 0-based). */
            to: number;
        }

        export interface Margins {
            /**
             * Can be `default`, `none`, `printableArea`, or `custom`. If `custom` is chosen,
             * you will also need to specify `top`, `bottom`, `left`, and `right`.
             */
            marginType?: 'default' | 'none' | 'printableArea' | 'custom';
            /**
             * The top margin of the printed web page, in pixels.
             */
            top?: number;
            /**
             * The bottom margin of the printed web page, in pixels.
             */
            bottom?: number;
            /**
             * The left margin of the printed web page, in pixels.
             */
            left?: number;
            /**
             * The right margin of the printed web page, in pixels.
             */
            right?: number;
        }

        /* Specifies the window position relative to the screen. */
        export interface PlacementSettings {
            /**
             * If `true`, the Glue42 Window will remain snapped to the specified screen position even in cases of resolution changes, window visibility changes or when the application virtualization window hosting the Glue42 Window has been resized.
             * However, this doesn't include any API calls or manual user interaction which affect the window placement or bounds. If `false`, the window will be positioned at the specified screen location only once when created.
             */
            snapped: boolean;
            /**
             * Defines a vertical alignment configuration. If `horizontalAlignment` is set, then `verticalAlignment` will default to "stretch".
             */
            verticalAlignment?: "top" | "bottom" | "center" | "stretch";
            /**
             * Defines a horizontal alignment configuration. If `verticalAlignment` is set, then `horizontalAlignment` will default to "stretch".
             */
            horizontalAlignment?: "left" | "right" | "center" | "stretch";
            /**
             * Sets the margin for all four sides of the window.
             */
            margin?: string;
            /**
             * Defines the window width.
             * Use a `number` to define the width in pixels. Use a `string` to define the width in pixels or percentage of the screen width - e.g., "10px" or "10%".
             */
            width?: number | string;
            /**
             * Defines the window height.
             * Use a `number` to define the height in pixels. Use a `string` to define the height in pixels or percentage of the screen height - e.g., "10px" or "10%".".
             */
            height?: number | string;
            /**
             * Defines the current display.
             */
            display?: Glue42.Displays.Display | "current";
        }

        /** Modes for flashing window
         *  @default "auto"
         *  auto - the window starts to flash only if it is not active. The flashing stops when the window is reactivated
         *  force - the window starts to flash even if is active but still turns off when the window is activated
         *  forceAndKeep" - the window start to flash until the method "flash" is called with parameter "false"
         */
        export type FlashMode = "auto" | "force" | "forceAndKeep"

        export interface Neighbours {
            leftNeighbours: GDWindow[],
            topNeighbours: GDWindow[],
            rightNeighbours: GDWindow[],
            bottomNeighbours: GDWindow[]
        }

        /**
         * Provides access to window groups.
         * @docmenuorder 3
         */
        export interface GroupsAPI {

            /** Returns the current group of the window. */
            my: Group;

            /** Lists all window groups.
             * @param success Optional callback to handle the returned window groups. Receives an array of the returned window groups as a parameter.
             */
            list(success?: (groups: Group[]) => void): Group[];

            /** Finds a group by a provided window object or window ID.
             * @param winId A Glue42 Window object or a window ID by which to find a window group.
             * @param success Optional callback to handle the returned window group. Receives the returned window group as a parameter.
             * @param error Optional callback
             */
            findGroupByWindow(winId: string | GDWindow, success?: (group: Group) => void, error?: (error: string) => void): Group;
        }

        /**
         * Glue42 Windows can be grouped together via the Window Management API.
         * The `Group` object describes a window group.
         *
         * @docmenuorder 4
         */
        export interface Group {

            /** The ID of the current group. */
            id: string;

            /** Lists all windows in the group. */
            windows: GDWindow[];

            /** Whether the header of the group is visible or not. */
            isHeaderVisible: boolean;

            /**
             * Finds a window by ID or by a window object.
             * @param window Window ID or a window object by which to find a window in the group.
             * @param success Optional callback to handle the returned window.
             */
            find(window: string | GDWindow, success?: (window: GDWindow) => void): GDWindow;

            /**
             * Restores the window group.
             * @param success Optional success callback to handle the returned window group.
             * @param error Optional error callback to handle errors.
             */
            restore(success?: (group: Group) => void, error?: (error: string) => void): void;

            /**
             * Maximizes the window group.
             * @param success Optional success callback to handle the maximized window group.
             * @param error Optional error callback to handle errors.
             */
            maximize(success?: (group: Group) => void, error?: (error: string) => void): void;

            /**
             * Shows the window group header.
             * @param success Optional success callback that receives the window group as a parameter.
             * @param error Optional error callback to handle errors.
             */
            showHeader(success?: (group: Group) => void, error?: (error: string) => void): Promise<Group>;

            /**
             * Hides the window group header.
             * @param success Optional success callback that receives the window group as a parameter.
             * @param error Optional error callback to handle errors.
             */
            hideHeader(success?: (group: Group) => void, error?: (error: string) => void): Promise<Group>;

            /**
             * Returns the current group title
             */
            getTitle(): Promise<string>;

            /**
             * Changes the group title
             * @param title the new group title
             */
            setTitle(title: string): Promise<Group>;

            /**
             * Returns an image of the entire window group as a `base64` encoded string.
             * @param options Options for capturing the window group.
             */
            capture(options?: CaptureOptions): Promise<string>;

            /**
             * Notifies when the visibility of the window group header is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onHeaderVisibilityChanged(callback: (group: Group) => void): UnsubscribeFunction;

            /**
             * Notifies when a new window is added to the group.
             * @param callback Callback function to handle the event. Receives the window group and the added window as parameters. Returns an unsubscribe function.
             */
            onWindowAdded(callback: (group: Group, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a window is removed from the group.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onWindowRemoved(callback: (group: Group) => void): UnsubscribeFunction;
        }

        /**
         * Window Management API
         *
         * @docmenuorder 1
         */
        export interface API {

            /** Returns the API for managing group windows. */
            groups: GroupsAPI;

            /** Returns the current window. */
            my(): GDWindow;

            /**
             * Opens a new Glue42 Window.
             * @param name A unique window name.
             * @param url The window URL.
             * @param options Options for creating a window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional error callback to handle errors.
             */
            open(name: string, url: string, options?: WindowCreateOptions, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Finds a window by name.
             * @param name A unique window name.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional error callback to handle errors.
             */
            find(name: string, success?: (window: GDWindow) => void, error?: (error: string) => void): GDWindow;

            /**
             * Finds a window by ID.
             * @param id Window ID.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional error callback to handle errors.
             */
            findById(id: string, success?: (window: GDWindow) => void, error?: (error: string) => void): GDWindow;

            /**
             * Lists all windows.
             * @param success Optional success callback to handle the returned windows.
             */
            list(success?: (windows: GDWindow[]) => void): GDWindow[];

            /**
             * Creates a flydown window.
             * @param targetWindowId ID of the window for which to create the flydown.
             * @param config Options for creating a flydown window.
             */
            createFlydown(targetWindowId: string, config: FlydownOptions): Promise<Flydown>;

            /**
             * Creates a popup window.
             * @param targetWindowId ID of the window for which to create the popup.
             * @param config Options for creating a popup window.
             */
            showPopup(targetWindowId: string, config: PopupOptions): Promise<void>;

            /**
             * Notifies when a new window is opened. For backwards compatibility, you can also use `windowAdded`.
             * @param callback Callback function to handle the event. Receives the added window as a parameter. Returns an unsubscribe function.
             */
            onWindowAdded(callback: (window: GDWindow) => void): UnsubscribeFunction;

            windowAdded(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a window is closed. For backwards compatibility, you can also use `windowRemoved`.
             * @param callback Callback function to handle the event. Receives the removed window as a parameter. Returns an unsubscribe function.
             */
            onWindowRemoved(callback: (window: GDWindow) => void): UnsubscribeFunction;

            windowRemoved(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a tab window is attached to another tab group.
             * This is a generic event handler that provides information for both the window being attached
             * and the group of tab windows that the tab is attached to.
             * @param callback Callback function to handle the event. Receives as parameters the attached tab window,
             * the ID of the new tab group and a `boolean` value showing whether the header of the tab is visible or not.
             */
            onTabAttached(callback: (tabWindow: GDWindow, newTabGroupId: string, tabHeaderVisible: boolean) => void): UnsubscribeFunction;

            /**
             * Notifies you when a tab window is detached from another tab group.
             * This is a generic event handler that provides information for both the window being detached
             * and the group of tab windows that the tab is being detached from.
             * @param callback Callback function to handle the event. Receives as parameters the detached tab window,
             * the ID of the new tab group and a the ID of the old tab group.
             */
            onTabDetached(callback: (window: GDWindow, tabGroupId: string, oldTabGroupId: string) => void): UnsubscribeFunction;

            /**
             * Notifies when the window frame color is changed.
             * @param callback Callback function to handle the event. Receives the window instance as a parameter. Returns a `Promise` which resolves with an unsubscribe function.
             */
            onWindowFrameColorChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a window receives focus.
             * @param callback Callback function to handle the event. Receives the window instance as a parameter. Returns an unsubscribe function.
             */
            onWindowGotFocus(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a window loses focus.
             * @param callback Callback function to handle the event. Receives the window instance as a parameter. Returns an unsubscribe function.
             */
            onWindowLostFocus(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /** Returns a `Promise` that resolves when the library is ready. */
            ready(): Promise<any>;

            /**
             * @ignore
             * @param callback Callback function to handle the event. Receives a stream as a parameter. Returns an unsubscribe function.
             */
            onEvent(callback: (stream: any) => void): UnsubscribeFunction;

            /**
             * Configure global Glue42 Windows settings
             * @param options configuration options.
             */
            configure(options: WindowsConfiguration): Promise<void>;
        }

        /**
         * Glue42 Window object.
         * @docmenuorder 2
         */
        export interface GDWindow {

            /** The type of the window. */
            windowType: "electron" | "remote";

            /** The name of the current window. Window names are unique within Glue42. */
            name: string;

            /** The Interop instance that the window runs in. */
            hostInstance: Glue42Core.AGM.Instance | string;

            /** The Interop instance of the window. Used for easier access to the Interop API. */
            agmInstance: Glue42.AGM.Instance | undefined;

            /** The URL of the current window. */
            url: string;

            /** The ID of the current window. */
            id: string;

            /** The application associated with the current window. Can be `undefined` if the window was not started as an application. */
            application: AppManager.Application | undefined;

            /** The title of the current window. */
            title: string;

            /**
             * Deprecated. Use `settings` instead.
             * The window styles of the current window.
             */
            windowStyleAttributes: WindowSettings;

            /** The settings of the current window. */
            settings: WindowSettings;

            /**
             * The tab group ID of the current window. When several windows reside in a common tab container they
             * have the same tab group ID.
             */
            tabGroupId: string;

            /**
             * The tab index of the current window. When several windows reside in a common tab container they
             * have different index in the group ID.
             */
            tabIndex: number;

            /** Returns all frame buttons. */
            frameButtons: ButtonInfo[];

            /** Returns the mode of the window - `html`, `flat`, `tab`. */
            mode: WindowMode;

            /** Returns the state of the window - `normal`, `maximized` or `minimized`. */
            state: WindowState;

            /** Returns `true` if the window is collapsed. */
            isCollapsed: boolean;

            /** Returns `true` if the window is visible. */
            isVisible: boolean;

            /** Returns `true` if the window is locked. */
            isLocked: boolean;

            /** Whether the window is focused or not. */
            isFocused: boolean;

            /** Whether the header of the window group is visible or hidden. */
            isGroupHeaderVisible: boolean;

            /**
             * Returns the context of the window.
             * @deprecated Use `getContext()` instead.
             */
            context: any;

            /** Returns the bounds of the window. */
            bounds: Bounds;

            /** Returns the minimum height of the window. */
            minHeight: number;

            /** Returns the maximum height of the window. */
            maxHeight: number;

            /** Returns the minimum width of the window. */
            minWidth: number;

            /** Returns the maximum width of the window. */
            maxWidth: number;

            /** Returns the color of the window frame. */
            frameColor: string;

            /** Whether the window is open or not. */
            opened: boolean;

            /** Returns the group of the window. */
            group: Group;

            /** Returns the ID of the group of the window. */
            groupId: string;

            /** Whether the window is sticky or not. */
            isSticky: boolean;

            /** Returns the top neighbours of the window. */
            topNeighbours: GDWindow[];

            /** Returns the left neighbours of the window. */
            leftNeighbours: GDWindow[];

            /** Returns right neighbours of the window. */
            rightNeighbours: GDWindow[];

            /** Returns bottom neighbours of the window. */
            bottomNeighbours: GDWindow[];

            /** Returns the ID of the activity the window participates in (`undefined` if it is not part of an activity). */
            activityId: string;

            /** Returns the ID of the window if the window is an activity window (`undefined` if it is not part of an activity). */
            activityWindowId: string;

            /**
             * Available only when the window is in `tab` mode. Returns all tabs that are in the same tab group as the current window.
             */
            tabs: GDWindow[];

            /** Whether the tab header of the window is visible or not. */
            isTabHeaderVisible: boolean;

            /** Whether the tab window is selected. */
            isTabSelected: boolean;

            /** Returns the current zoom factor. */
            zoomFactor: number;

            /** Returns the screen the window is on. Deprecated, use `getDisplay()` instead. */
            screen: Glue42.Screen;

            /** Returns current placement options. */
            placementSettings: PlacementSettings;

            /**
             * Attaches a tab window to the current tab window.
             * @param tab The instance or the name of the tab window to attach.
             * @param options Optional settings for the attached tab.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            attachTab(tab: GDWindow | string, options?: number | AttachOptions, success?: () => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Detaches a tab window from the current tab window.
             * @param opt Settings for the detached window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            detachTab(opt: DetachOptions, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Maximizes a window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            maximize(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Restores a window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            restore(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Minimizes a window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            minimize(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Maximizes or restores the current window based on the current window state.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            maximizeRestore(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Collapses a window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            collapse(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Expands a window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            expand(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Collapses or expands the current window based on the current window state.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            toggleCollapse(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Focuses the current window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            focus(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Activates the current window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            activate(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Extracts the current window from the window group. If the window is part of a tab group, the entire tab group will be extracted.
             * @param options Settings for the extracted window.
             */
            ungroup(options?: UngroupOptions): Promise<GDWindow | undefined>;

            /**
             * Move and/or resize the window.
             * @param dimension Location and size for the window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            moveResize(dimension: Partial<Bounds>, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            resizeTo(width?: number, height?: number): Promise<GDWindow>;

            // resizeBy(width?: number, height?: number): Promise<GDWindow>;

            moveTo(top?: number, left?: number): Promise<GDWindow>;

            // moveBy(top?: number, left?: number): Promise<GDWindow>;

            /**
             * Sets the title of the current window.
             * @param title The title for the window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setTitle(title: string, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Sets the style of the current window.
             * @param styles An object defining the window frame buttons, window size constraints, focus and visibility.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setStyle(styles: WindowStyle, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Resets the visible buttons of the window frame.
             * @param buttons An object defining which buttons to be shown on the window frame.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            resetButtons(buttons: WindowButtons, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /** Z-index setting. If `true`, will make the window appear on top of all other windows. */
            setOnTop(onTop: boolean, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Changes the size constraints of the window.
             * @param constraints Min and max width and height constraints for the window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setSizeConstraints(constraints: SizeConstraints, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Changes the tooltip of a tab window.
             * @param tabTooltip The text to be used as a tooltip.
             */
            setTabTooltip(tabTooltip: string): Promise<GDWindow>;

            /**
             * Navigates the window to a new URL.
             * @param url URL to navigate to.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            navigate(url: string, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Adds a frame button to the window.
             * @param buttonInfo Window button settings.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            addFrameButton(buttonInfo: ButtonInfo, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Removes a frame button from the window.
             * @param buttonId ID of the button to remove.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            removeFrameButton(buttonId: string, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Hides or shows the current window.
             * @param toBeVisible Whether the window is to be visible or not.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setVisible(toBeVisible?: boolean, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Shows the current window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            show(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Hides the current window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            hide(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Closes the window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            close(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Snaps the window to another window.
             * @param target Instance or name of the window to which to snap the current window.
             * @param direction Direction for snapping the window. Relative to the target window.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            snap(target: string | GDWindow, direction?: RelativeDirection, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Shows a loader animation for the window or updates the loader properties (animation type, background or text).
             * @param options Settings for the loader animation.
             */
            showLoader(options?: Loader): Promise<GDWindow>;

            /** Hides the loader animation for the window. */
            hideLoader(): Promise<GDWindow>;

            /**
             * Updates the window context.
             * @param context Context object with which to update the current context (or create a new one if it does not exist).
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            updateContext(context: any, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Locks the window. When in locked state, moving the window will result in moving the entire group (if it is part of any).
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            lock(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Unlocks the window. When in unlocked state, moving the window will result in tearing it out from the window group (if it is part of any).
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            unlock(success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Returns the window icon.
             * @param success Optional success callback to handle the returned icon.
             * @param error Optional callback to handle errors.
             */
            getIcon(success?: (icon: string) => void, error?: (error: string) => void): Promise<string>;

            /**
             * Sets the window icon.
             * @param base64Image Icon as a `base64` encoded string.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setIcon(base64Image: string, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Sets the window frame color.
             * @param frameColor Can be a color name, such as "red", or a hex-encoded RGB or ARGB value.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setFrameColor(frameColor: string, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Hides or shows the tab header of the current window.
             * @param toBeVisible Whether to show or hide the tab header.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             */
            setTabHeaderVisible(toBeVisible?: boolean, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Shows a popup window.
             * @param config Options for the popup window.
             */
            showPopup(config: PopupOptions): Promise<GDWindow>;

            /**
             * Creates a flydown window.
             * @param config Options for the flydown window.
             */
            createFlydown(config: FlydownOptions): Promise<Flydown>;

            /**
             * Makes a window behave like a modal when its used as a flydown
             * @param isModal determines if the modal behaviour is enabled
             */
            setModalState(isModal: boolean): Promise<void>;

            /** Zooms in the window. */
            zoomIn(): Promise<GDWindow>;

            /** Zooms out the window. */
            zoomOut(): Promise<GDWindow>;

            /**
             * Changes the zoom level.
             * @param factor Zoom factor.
             */
            setZoomFactor(factor: number): Promise<GDWindow>;

            /**
             * @ignore
             * Opens the Chrome DevTools.
             */
            showDevTools(): Promise<GDWindow>;

            /**
             * Returns a screenshot of the window.
             * @param options Options for capturing the window.
             */
            capture(options: CaptureOptions): Promise<string>;

            /**
             * Makes the taskbar window icon flash (e.g., to prompt the user to take action).
             * @param options Whether to start or stop flashing the taskbar window icon. Default is true.
             * @param options Whether to start flashing the taskbar window icon even it is activated. Default is true.
             */
            flash(options?: boolean, mode?: FlashMode): Promise<Glue42.Windows.GDWindow>;

            /**
             * Moves the window to the center of the screen.
             * @param screen Optional parameter specifying the screen on which to center the window.
             */
            center(screen?: Glue42.Screen): Promise<GDWindow>;

            getURL(): Promise<string>;

            getTitle(): Promise<string>;

            getBounds(): Promise<Bounds>;

            getContext(): Promise<any>;

            setContext(context: any): Promise<GDWindow>;

            getDisplay(): Promise<Glue42.Displays.Display>;


            /**
             * Enable or disable the stickiness of the current window.
             * @param isSticky Whether to enable or disable the stickiness.
             * @param success Optional success callback to handle the returned window.
             * @param error Optional callback to handle errors.
             * @since Glue42 3.11
             */
            setSticky(isSticky: boolean, success?: (window: GDWindow) => void, error?: (error: string) => void): Promise<GDWindow>;

            /**
             * Refresh the current window.
             * @param ignoreCache Whether to refresh the page with or without cache. Default value: false
             * @since Glue42 3.12
             */
            refresh(ignoreCache: boolean): Promise<GDWindow>;

            /**
             * Configure Glue42 Window settings
             * @param options configuration options.
             * @since Glue42 3.12
             */
            configure(options: WindowConfiguration): Promise<GDWindow>;

            /**
             * Notifies when a window is attached to the current window.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onWindowAttached(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a window is detached from the current window.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onWindowDetached(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the visibility of the window tab header changes.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onTabHeaderVisibilityChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is closed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onClose(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window URL is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onUrlChanged(callback: (url: string, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the title of the window is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onTitleChanged(callback: (title: string, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a frame button is added.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onFrameButtonAdded(callback: (buttonInfo: ButtonInfo, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a frame button is removed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onFrameButtonRemoved(callback: (buttonInfo: ButtonInfo, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when a frame button is clicked.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onFrameButtonClicked(callback: (buttonInfo: ButtonInfo, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is collapsed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onCollapsed(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is expanded.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onExpanded(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is minimized.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onMinimized(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is maximized.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onMaximized(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is restored from minimized/maximized state to normal state.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onNormal(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the current window is attached.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onAttached(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the current window is detached.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onDetached(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window visibility changes.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onVisibilityChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window context is updated.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onContextUpdated(callback: (context: any, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is locked or unlocked.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onLockingChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window location is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onBoundsChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window frame color is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onFrameColorChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window focus is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onFocusChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window stickiness is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onStickyChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window group is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onGroupChanged(callback: (window: GDWindow, newGroup: Group, oldGroup: Group) => void): UnsubscribeFunction;

            /**
             * Notifies when the active tab is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onTabSelectionChanged(callback: (selectedWindow: GDWindow, previousWindow: GDWindow, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the window is about to close.
             * @param callback Callback function to handle the event. Returns a `Promise` that will be awaited
             * before the window is closed. Subject to a timeout configured in Glue42 Desktop.
             */
            onClosing(callback: () => Promise<void>): void;

            /**
             * Notifies when the window is about to refresh.
             * @param callback Callback function to handle the event. Returns a `Promise` that will be awaited
             * before the window is refreshed. Subject to a timeout configured in Glue42 Desktop.
             * A prevent function is passed to the callback as a parameter. It allows the calling code to prevent the refresh.
             */
            onRefreshing(callback: (prevent: () => void) => Promise<void>): void;

            /**
             * Notifies when the zoom factor is changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onZoomFactorChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the placement of the window has changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onPlacementSettingsChanged(callback: (window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Notifies when the neighbours of the window are changed.
             * @param callback Callback function to handle the event. Returns an unsubscribe function.
             */
            onNeighboursChanged(callback: (neighbours: Glue42.Windows.Neighbours, window: GDWindow) => void): UnsubscribeFunction;

            /**
             * Returns all child windows of this window
             */
            getChildWindows(): Promise<GDWindow[]>;

            /**
             * Returns the parent window of this window
             */
            getParentWindow(): Promise<GDWindow | undefined>;

            /**
             * Prints the window web page.
             * @since Glue42 3.11
             */
            print(options?: PrintToPDFOptions): Promise<GDWindow | undefined>;

            /**
             * Prints the window web page as a PDF file with the custom print preview settings of Chromium.
             * @since Glue42 3.11
             */
            printToPDF(option?: PrintOptions): Promise<string | undefined>;

            /* Places the window at the specified position*/
            place(options: PlacementSettings): Promise<void>;
        }
    }

    /**
     * @docmenuorder 3
     * @intro
     * The Glue42 Channels are globally accessed named contexts that allow users to dynamically group applications, instructing them to work over the same shared data object.
     * Assign a Glue42 enabled app to a Channel through the Channel Selector of the Glue42 Window:
     *
     * ![Selected Channel](../../../../images/channels/channel-selector.png)
     *
     * When applications are on the same Channel, they share a context data object which they can monitor and/or update.
     * See below how applications interact with each other using the Glue42 Channels:
     *
     * ![Channel interactions](../../../../images/channels/channels.gif)
     *
     * The Channels API is accessible through the `glue.channels` object.
     */
    namespace Channels {

        /**
         * Channels API
         */
        export interface API {
            /**
             * Tracks the data in the current channel. Persisted after a channel change.
             * The callback isn't called when you publish the data.
             * @param callback Callback function to handle the received data.
             * @returns Unsubscribe function.
             */
            subscribe(callback: (data: any, context: ChannelContext, updaterId: string) => void): () => void;

            /**
             * Tracks the data in a given channel.
             * @param name The channel to track.
             * @param callback Callback function to handle the received data.
             * @returns Promise that resolves with an unsubscribe function.
             */
            subscribeFor(name: string, callback: (data: any, context: ChannelContext, updaterId: string) => void): Promise<() => void>;

            /**
             * Updates the context of the current or a given channel.
             * @param data Data object with which to update the channel context.
             * @param name The name of the channel to be updated. If not provided will update the current channel.
             * @returns Promise that resolves when the data has been published.
             */
            publish(data: any, name?: string): Promise<void>;

            /**
             * Returns a list of all channel names.
             * @returns Promise that resolves with the list of all channel names.
             */
            all(): Promise<string[]>;

            /**
             * Returns a list of all channel contexts.
             * @returns Promise that resolves with the list of all channel contexts.
             */
            list(): Promise<ChannelContext[]>;

            /**
             * Returns the context of a given channel.
             * @param name The name of the channel whose context to return.
             * @returns Promise that resolves with the context of the given channel.
             */
            get(name: string): Promise<ChannelContext>;

            /**
             * Returns the context of the current channel.
             * @returns Promise that resolves with the context of the current channel. Undefined if not on a channel.
             * @since 5.5.9
             */
            getMy(): Promise<ChannelContext>;

            /**
             * Joins a new channel by name. Leaves the current channel.
             * @param name The name of the channel to join.
             * @returns Promise that resolves when the channel has been joined.
             */
            join(name: string): Promise<void>;

            /**
             * Leaves the current channel.
             * @returns Promise that resolves when the channel has been left.
             */
            leave(): Promise<void>;

            /**
             * Returns the name of the current channel.
             * @ignore
             * @returns The name of the current channel.
             */
            current(): string;

            /**
             * Returns the name of the current channel.
             * @returns The name of the current channel.
             */
            my(): string;

            /**
             * Subscribes for the event which fires when a channel is changed.
             * @ignore
             * @param callback Callback function to handle channel changes.
             * @returns Unsubscribe function.
             */
            changed(callback: (channel: string) => void): () => void;

            /**
             * Subscribes for the event which fires when a channel is changed.
             * @param callback Callback function to handle channel changes.
             * @returns Unsubscribe function.
             */
            onChanged(callback: (channel: string) => void): () => void;

            /**
             * Adds a new channel.
             * @ignore
             * @param info The initial channel context.
             * @returns Promise that resolves with the initial channel context.
             */
            add(info: ChannelContext): Promise<ChannelContext>;

            /**
             * Returns all windows on a give channel
             * @since Glue42 3.12
             */
            getWindowsOnChannel(channel: string): Promise<Glue42.Windows.GDWindow[]>;

            /**
             * Returns channel enabled windows together with their current channel.
             * If no filter is set will return all channel enabled windows.
             * @param filter if set will limit the result to windows matching the criteria
             * @since Glue42 3.12
             */
            getWindowsWithChannels(filter?: WindowWithChannelFilter): Promise<WindowOnChannelInfo[]>;

            // remove(name: string): void; // ???
            // onChannelAdded(cb: () => void): void;
            // onChannelRemoved(cb: () => void): void;

            // advanced 1 (list, join, leave) - use-cases:
            // * draw my own selector in my application or join leave channels based on some other condition
            // * participate if not in SW

            // advanced 2 - manage channels at runtime - use-cases:
            // * give the user of the system the ability to define/update channels from some UI
            // meta(name: string, meta: object): Promise<void>; // updates the meta of some context

            // advanced 3 - discover peers that are on the same channel:
            // * some apps might be interested who else is on their channel
            // * there might be some UI logic that for example groups all windows that are on the blue channel
            // apps(name?: string): Promise<any[]>;
        }

        /**
         * Information about a GDWindow that is channel enabled channel
         */
        export interface WindowOnChannelInfo {
            // the actual window
            window: Glue42.Windows.GDWindow;
            // the channel that the window is currently on - might be undefined if the channel selector is in unselected state
            channel: string;
            // the name of the window's application - shortcut for window.application.name
            application: string;
        }

        export interface WindowWithChannelFilter {
            // if set only windows that are instances of the specified application
            application?: string;
            // if set will return only the list of specified window
            windowIds?: string[];
            // if set will return only windows that are on the listed channels
            channels?: string[];
        }

        /**
         * Channel context object.
         */
        export interface ChannelContext {
            /** Unique name of the context. */
            name: string;
            /** Channel meta data (display name, color, image, etc.) */
            meta: any;
            /** Channel data. */
            data: any;
        }
    }

    /**
     * @docmenuorder 7
     * @intro
     * The Hotkeys API allows applications to register key combinations and receive notifications
     * when a key combination is pressed by the user irrespective of whether the application is on focus or not.
     * Hotkeys is useful for web applications that do not have access to system resources and cannot register global shortcuts.
     *
     * The Hotkeys API is accessible through the `glue.hotkeys` object.
     */
    namespace Hotkeys {

        /**
         * Information about the hotkey.
         */
        interface HotkeyInfo {
            /**
             * The key or key combination that will be used as a hotkey.
             */
            hotkey: string;
            /**
             * Description of the hotkey.
             */
            description?: string;
        }

        /**
         * Callback function that is invoked when the hotkey is activated.
         */
        type HotkeyCallback = () => void;

        /**
         * Hotkeys API
         * @since Glue42 JavaScript 4.3.5
         */
        interface API {
            /**
             * Registers a hotkey.
             * Note that the same hotkey can be registered just once.
             * @param hotkey The key or key combination (as a string or as a `HotkeyInfo` object) that will be registered.
             * @param callback Callback function that will be invoked when the hotkey is activated.
             */
            register(hotkey: string | HotkeyInfo, callback: HotkeyCallback): Promise<void>;

            /**
             * Unregisters a hotkey. Notifications will no longer be received about this hotkey.
             * @param hotkey The hotkey to unregister.
             */
            unregister(hotkey: string): Promise<void>;

            /**
             * Unregister all hotkeys registered by the current application.
             */
            unregisterAll(): Promise<void>;

            /**
             * Returns `true` if the current application has registered a hotkey.
             * @param hotkey The hotkey you want to check for.
             */
            isRegistered(hotkey: string): void;
        }
    }

    /**
     * @docmenuorder 8
     * @intro
     * In certain workflow scenarios, your application may need to start (or activate) a specific application.
     * For instance, you may have an application showing client portfolios with financial instruments.
     * When the user clicks on an instrument, you want to start an application which shows a chart for that instrument.
     * In other cases, you may want to present the user with several options for executing an action or handling data from the current application.
     * The Intents API makes all that possible by enabling applications to register, find and raise Intents.
     *
     * The Intents API is accessible through the `glue.intents` object.
     */
    namespace Intents {
        /**
         * Intents API
         * @since Glue42 Enterprise 3.9
         */
        export interface API {
            /**
             * Raises an intent, optionally passing context to the intent handlers, and optionally targeting specific intent handlers.
             * If no handlers are matching the targeting conditions the promise will be rejected.
             * @param request can be the intent's name or an {@link IntentRequest} object carrying the intent, and its optional target, context and start options (see "startNew").
             * @returns Promise that resolves with {@link IntentResult}.
             */
            raise(request: string | IntentRequest): Promise<IntentResult>;

            /**
             * Returns all registered {@link Intent}.
             * @returns Promise that resolves with all registered intents.
             */
            all(): Promise<Intent[]>;

            /**
             * If your application is an intent handler use this method to handle incoming intent requests.
             * Please note that when a new instance of your application is started as a result of a raised intent with e.g. `startNew` your application needs to call `addIntentListener()` on startup so that the intent can be resolved.
             * The handler callback will be invoked whenever an intent is raised and your app was selected as an IntentTarget.
             * You can also use this method to register new dynamic intents, that will have the the same lifespan as your application instance.
             * @param intent The intent to be handled. The intent name of an object containing the intent, contextTypes that the intent can handle and a display name.
             * @param handler The callback that will handle a raised intent. Will be called with an {@link IntentContext} if it is provided by the raising application.
             * @returns An object with an unsubscribe function under the unsubscribe property.
             */
            addIntentListener(intent: string | AddIntentListenerRequest, handler: (context: IntentContext) => any): { unsubscribe: UnsubscribeFunction };

            /**
             * Searches for registered intents.
             * @param intentFilter can be the intent name or a {@link IntentFilter} filtering criteria.
             * @returns Promise that resolves with the found intents that match the provided filtering criteria.
             */
            find(intentFilter?: string | IntentFilter): Promise<Intent[]>;
        }

        /** Use to define dynamic intents, that will have the same lifespan as your application instance */
        export interface AddIntentListenerRequest {
            intent: string;
            contextTypes?: string[];
            displayName?: string;
            icon?: string;
            description?: string;
        }
        /**
         * Specifies the search criteria for the Intent API's `find()` method.
         */
        export interface IntentFilter {
            /**
             * The name of the intent to be used in the lookup.
             */
            name?: string;
            /**
             * The name of the context type to be used in the lookup.
             */
            contextType?: string;
        }

        /**
         * Represents an intent.
         */
        export interface Intent {
            /**
             * The name of the intent, such as `"CreateCall"`.
             */
            name: string;
            /**
             * The set of {@link IntentHandler} that provide an implementation for the intent and can be used to handle an intent request.
             */
            handlers: IntentHandler[];
        }

        /**
         * Represents an implementation of an intent.
         * Each intent handler can offer its own display name - this allows context menus
         * built on the fly to display more user friendly options. For example, if there is
         * an intent with a name "ShowNews", there could be a handler with display name
         * "Show Bloomberg News" and another with display name "Show Reuters News".
         * Handlers can optionally specify the context type they support, where the
         * context type is the name of a typed, documented data structure such as
         * "Person", "Team", "Instrument", "Order", etc. In the example above,
         * both the Bloomberg and Reuters handlers would specify a context type "Instrument" and
         * would expect to be raised with an instrument object conforming to an expected
         * structure from both handlers.
         * An intent handler must not necessarily specify a context type.
         */
        export interface IntentHandler {
            /* The name of the application which registered this intent implementation, as specified in the application configuration. */
            applicationName: string;

            /* The title of the application which registered this intent implementation, as specified in the application configuration. */
            applicationTitle: string;

            /* User friendly (longer) description of the application, as specified in the application configuration. */
            applicationDescription?: string;

            /* Icon URL of the application that has registered the intent handler, as specified in the application configuration */
            applicationIcon?: string;

            /**
             * The type of the handler.
             * "app" - An application that has declared itself as an implementor of the intent inside of its application definition.
             * "instance" - A running instance of an application that can handle the intent. Also includes dynamically added intents using `addIntentListener()`.
             */
            type: "app" | "instance";

            /**
             * The human-readable name of the intent handler, as specified in the intent definition
             */
            displayName?: string;

            /**
             * The context types this handler supports.
             */
            contextTypes?: string[];

            /**
             * The id of the running application instance.
             */
            instanceId?: string;

            /**
             * The window's title of the running application instance.
             */
            instanceTitle?: string;
        }

        /**
         * Represents a request to raise an intent.
         */
        export interface IntentRequest {
            /**
             * The name of the intent to be raised.
             */
            readonly intent: string;
            /**
             * he target of the raised intent. Valid values are:
             * `startNew` - will start a new instance of an application that can handle the intent.
             * `reuse` - a running instance of an application will handle the intent.
             * { app: "AppName" } - will start a new instance of the "AppName" application (iff it can handle it) that will handle the intent.
             * { instance: "i-123-1" } - the running application instance with instanceId "i-123-1" will handle the intent (iff it can handle it).
             */
            readonly target?: "startNew" | "reuse" | { app?: string; instance?: string };
            /**
             * The context type and data that will be provided to the intent implementation's handler.
             */
            readonly context?: IntentContext;
            /**
             * Start up options that will be used when a new instance of an application needs to be started to handle the intent request.
             */
            readonly options?: AppManager.ApplicationStartOptions;
        }

        /**
         * A structure that describes a typed context to be used to raise intents with.
         */
        export interface IntentContext {
            /**
             * The name of a typed, documented data structure such as "Person", "Team", "Instrument", "Order", etc.
             * It is the application developers' job to agree on a protocol to follow.
             */
            readonly type?: string;
            /**
             * The context data used as an argument by the intent implementation.
             */
            readonly data?: { [key: string]: any };
        }

        /**
         * The result of a raised intent.
         */
        export interface IntentResult {
            /**
             * The arguments that were used to raise the intent with.
             */
            request: IntentRequest;
            /**
             * The intent implementation that handled the intent.
             */
            handler: IntentHandler;
            /**
             * The data returned by the intent implementation when handling the intent.
             */
            result?: any;
        }
    }

    /**
     * @docmenuorder 6
     * @intro
     * The Glue42 Notifications API extends the [DOM Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API).
     * It allows notification and action clicks to be handled using Interop methods.
     *
     * The Notifications API is accessible through the `glue.notifications` object.
     */
    export namespace Notifications {
        /**
         * Notifications API
         * @since Glue42 Enterprise 3.9
         */
        export interface API {
            /** The maximum number of actions supported by the UI toast. */
            readonly maxActions: number;

            /**
             * Controls the notification panel UI
             * @since Glue42 3.12.1
             */
            panel: NotificationPanelAPI;

            /**
             * Raises a new notification
             * @param notification notification options
             */
            raise(notification: Glue42NotificationOptions): Promise<Glue42Notification>;

            /** Filters notifications */
            setFilter(filter: NotificationFilter): Promise<NotificationFilter>;

            /** Returns the current filter used to filter notifications */
            getFilter(): Promise<NotificationFilter>;
        }

        export interface NotificationPanelAPI {
            /**
             * Toggles visibility
             * @since Glue42 3.12.1
             */
            toggle(): Promise<void>;

            /**
             * Shows the notification panel
             * @since Glue42 3.12.1
             */
            show(): Promise<void>;

            /**
             * Hides the notification panel
             * @since Glue42 3.12.1
             */
            hide(): Promise<void>;

            /**
             * Checks if the notification panel is visible
             * @since Glue42 3.12.1
             */
            isVisible(): Promise<boolean>;
        }

        export interface NotificationFilter {
            allowed?: string[];
            blocked?: string[];
        }

        export interface ActionEvent extends Event {
            action: string;
        }
        export interface Glue42Notification extends Notification {
            onaction: ((this: Notification, ev: ActionEvent) => any) | null;
        }

        export interface Glue42NotificationOptions extends NotificationOptions {
            /** The title of the notification */
            title: string;

            /**
             * List of action attached to the notification.
             * Those will appear as buttons in the notification UI
             */
            actions?: Glue42NotificationAction[];

            /**
             * Set this to make clicking on the notification invoking an interop method with specific arguments.
             * You can also attach to onclick callback to the Notification object.
             */
            clickInterop?: InteropActionSettings;

            /**
             * Type of the notification -
             * Notification is some information that can be classified as important but not urgent.
             * Alert is usually a special, urgent notification about the occurrence of a specific event.
             */
            type?: "Notification" | "Alert";

            /** Severity of the alert */
            severity?: "Low" | "Medium" | "High" | "Critical" | "None";

            /** A way to override notification source */
            source?: string;
        }

        export interface Glue42NotificationAction extends NotificationAction {
            /** set to make the action invoke an interop method with specific arguments */
            interop?: InteropActionSettings;
        }

        export interface InteropActionSettings {
            method: string;
            arguments?: any;
            target?: "all" | "best";
        }
    }

    /**
     * @docmenuorder 7
     * @intro
     * **Glue42 Enterprise** has two built-in themes - **Day** and **Night**.
     * You can control the themes programmatically by using the Themes API.
     * The themes can also be customized and new themes can be added through the `themes.json` configuration file.
     *
     * The Themes API is accessible through the `glue.themes` object.
     */
    export namespace Themes {
        /**
         * Themes API
         * @since Glue42 3.10
         */
        export interface API {
            /**
             * Returns list of available themes
             */
            list(): Promise<Glue42.Themes.Theme[]>;

            /**
             * Returns the current theme
             */
            getCurrent(): Promise<Glue42.Themes.Theme>;

            /**
             * Selects a new theme
             * @param name The name of the theme
             */
            select(name: string): Promise<void>;

            /**
             * Notifies you when the theme is changed.
             * @param callback Callback to handle the event. Receives the theme object as an argument.
             */
            onChanged(callback: (theme: Glue42.Themes.Theme) => any): void;
        }

        export interface Theme {
            name: string;
            displayName: string;
        }
    }

    /**
     * @docmenuorder 8
     * @docname Application Preferences
     * @intro
     * The Application Preferences API allows applications to store custom data and retrieve it when needed.
     *
     * The Application Preferences API is accessible through the `glue.prefs` object.
     */
    export namespace Preferences {

        /**
         * Application Preferences API
         * @since Glue42 3.12
         */
        export interface API {
            /**
             * Retrieves preferences for the current application
             * @param app Optional - if specified will retrieve preferences for the specified application
             */
            get(app?: string): Promise<AppPreferences | undefined>;

            /**
             * Replaces preferences for the current application. All properties of the data object will be removed and replaced with the ones supplied in the data parameter.
             * @param data New data to replace the existing preferences
             * @param options Optional - if specified can replace preferences of another application
             */
            set(data: any, options?: { app: string }): Promise<void>;

            /**
             * Updates preferences for the current application with the supplied object. This method updates only the specified data properties. Any other existing properties will remain intact.
             * @param data Data to be merged into the existing preferences
             * @param options Optional - if specified can update preferences of another application
             */
            update(data: any, options?: { app: string }): Promise<void>;

            /**
             * Removes preferences for the current application
             * @param app Optional - if specified will clear preferences of another application
             */
            clear(app?: string): Promise<void>;

            /**
             * Retrieves all preferences stored for the current user
             */
            getAll(): Promise<AppPreferences[]>;

            /**
             * Removes all preferences stored for the current user
             */
            clearAll(): Promise<void>;
        }

        export interface AppPreferences {
            app: string;
            data: any;
            lastUpdate: Date;
        }
    }

    /**
     * Object describing a screen.
     */
    export interface Screen {
        /** Screen height. */
        height: number;
        /** Whether this is the primary screen. */
        isPrimary: boolean;
        /** Horizontal coordinate of the top left corner of the screen. */
        left: number;
        /** Name of the screen assigned by the operating system. */
        name: string;
        /** Screen scale factor. */
        scale: number;
        /** Scale factor of the horizontal axis of the screen. */
        scaleX: number;
        /** Scale factor of the vertical axis of the screen. */
        scaleY: number;
        /** Vertical coordinate of the top left corner of the screen. */
        top: number;
        /** Screen width. */
        width: number;
        /** Height of the working area. */
        workingAreaHeight: number;
        /** Horizontal coordinate of the top left corner of the screen working area. */
        workingAreaLeft: number;
        /** Vertical coordinate of the top left corner of the screen working area. */
        workingAreaTop: number;
        /** Width of the working area. */
        workingAreaWidth: number;
    }
}

type NodeRequireFunction = (moduleName: "glue42") => typeof Glue42;
