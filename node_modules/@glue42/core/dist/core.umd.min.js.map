{"version":3,"file":"core.umd.min.js","sources":["../src/metrics/const/metric-types.ts","../src/metrics/protocols/gw3/serializer.ts","../src/metrics/helpers.ts","../src/metrics/metrics/base.ts","../src/metrics/metrics/number.ts","../src/metrics/metrics/object.ts","../src/metrics/metrics/string.ts","../src/metrics/metrics/timestamp.ts","../src/metrics/repository.ts","../src/metrics/system.ts","../src/metrics/protocols/null/null.ts","../src/metrics/pertTracker.ts","../src/metrics/main.ts","../src/metrics/protocols/gw3/gw3.ts","../node_modules/callback-registry/lib/index.js","../src/connection/transports/inProc.ts","../src/connection/transports/worker.ts","../src/utils/utils.ts","../src/utils/pw.ts","../src/utils/timer.ts","../src/connection/transports/ws.ts","../node_modules/shortid/lib/random/random-from-seed.js","../node_modules/shortid/lib/alphabet.js","../node_modules/shortid/lib/random/random-byte-browser.js","../node_modules/shortid/lib/encode.js","../node_modules/shortid/lib/decode.js","../node_modules/shortid/lib/is-valid.js","../node_modules/shortid/lib/index.js","../node_modules/shortid/index.js","../src/connection/protocols/gw3Domain.ts","../src/connection/protocols/gw3.ts","../src/connection/replayer.ts","../src/utils/promise-plus.ts","../src/connection/transports/webPlatform.ts","../src/connection/connection.ts","../src/logger/logger.ts","../src/contexts/bridges/gw3/messages.ts","../src/contexts/contextMessageReplaySpec.ts","../src/contexts/bridges/gw3/contextData.ts","../src/contexts/helpers.ts","../src/contexts/bridges/gw3/bridge.ts","../src/interop/client/client.ts","../src/contexts/contextsModule.ts","../src/interop/helpers/promisify.ts","../src/interop/helpers/promiseHelpers.ts","../src/interop/server/subscription.ts","../src/interop/server/request.ts","../src/interop/server/streaming.ts","../src/interop/server/branch.ts","../src/interop/server/stream.ts","../src/interop/server/server.ts","../src/interop/instance.ts","../src/interop/client/repository.ts","../src/interop/server/repository.ts","../src/interop/protocols/gw3/server-streaming.ts","../src/interop/protocols/gw3/server.ts","../src/interop/protocols/gw3/subscription.ts","../src/interop/protocols/gw3/client-streaming.ts","../src/interop/protocols/gw3/client.ts","../src/interop/protocols/gw3/factory.ts","../src/interop/interop.ts","../src/bus/main.ts","../src/index.ts","../src/config.ts"],"sourcesContent":["export default {\r\n    STRING: 1,\r\n    NUMBER: 2,\r\n    TIMESTAMP: 3,\r\n    OBJECT: 4\r\n};\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport MetricTypes from \"../../const/metric-types\";\r\n\r\nfunction getMetricTypeByValue(metric: Glue42Core.Metrics.Metric): string {\r\n\r\n    if (metric.type === MetricTypes.TIMESTAMP) {\r\n        return \"timestamp\";\r\n    } else if (metric.type === MetricTypes.NUMBER) {\r\n        return \"number\";\r\n    } else if (metric.type === MetricTypes.STRING) {\r\n        return \"string\";\r\n    } else if (metric.type === MetricTypes.OBJECT) {\r\n        return \"object\";\r\n    }\r\n\r\n    return \"unknown\";\r\n}\r\n\r\nfunction getTypeByValue(value: any): string {\r\n\r\n    if (value.constructor === Date) {\r\n        return \"timestamp\";\r\n    } else if (typeof value === \"number\") {\r\n        return \"number\";\r\n    } else if (typeof value === \"string\") {\r\n        return \"string\";\r\n    } else if (typeof value === \"object\") {\r\n        return \"object\";\r\n    } else {\r\n        return \"string\";\r\n    }\r\n}\r\n\r\nfunction serializeMetric(metric: Glue42Core.Metrics.Metric): any {\r\n\r\n    const serializedMetrics: any = {};\r\n    const type = getMetricTypeByValue(metric);\r\n    if (type === \"object\") {\r\n        const values = Object.keys(metric.value).reduce((memo: any, key: any) => {\r\n            const innerType = getTypeByValue(metric.value[key]);\r\n            if (innerType === \"object\") {\r\n                const composite = defineNestedComposite(metric.value[key]);\r\n                memo[key] = {\r\n                    type: \"object\",\r\n                    description: \"\",\r\n                    context: {},\r\n                    composite,\r\n                };\r\n            } else {\r\n                memo[key] = {\r\n                    type: innerType,\r\n                    description: \"\",\r\n                    context: {},\r\n                };\r\n            }\r\n\r\n            return memo;\r\n        }, {});\r\n\r\n        serializedMetrics.composite = values;\r\n    }\r\n\r\n    serializedMetrics.name = normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name);\r\n    serializedMetrics.type = type;\r\n    serializedMetrics.description = metric.description;\r\n    serializedMetrics.context = {};\r\n\r\n    return serializedMetrics;\r\n}\r\n\r\nfunction defineNestedComposite(values: any): any {\r\n    return Object.keys(values).reduce((memo: any, key: any) => {\r\n        const type = getTypeByValue(values[key]);\r\n        if (type === \"object\") {\r\n            memo[key] = {\r\n                type: \"object\",\r\n                description: \"\",\r\n                context: {},\r\n                composite: defineNestedComposite(values[key]),\r\n            };\r\n        } else {\r\n            memo[key] = {\r\n                type,\r\n                description: \"\",\r\n                context: {},\r\n            };\r\n        }\r\n\r\n        return memo;\r\n    }, {});\r\n}\r\n\r\nfunction normalizeMetricName(name: string): string {\r\n    if (typeof name !== \"undefined\" && name.length > 0 && name[0] !== \"/\") {\r\n        return \"/\" + name;\r\n    } else {\r\n        return name;\r\n    }\r\n}\r\n\r\nfunction getMetricValueByType(metric: Glue42Core.Metrics.Metric) {\r\n    const type: string = getMetricTypeByValue(metric);\r\n    if (type === \"timestamp\") {\r\n        return Date.now();\r\n    } else {\r\n        return publishNestedComposite(metric.value);\r\n    }\r\n}\r\n\r\nfunction publishNestedComposite(values: any) {\r\n    if (typeof values !== \"object\") {\r\n        return values;\r\n    }\r\n    return Object.keys(values).reduce((memo: any, key: any) => {\r\n        const value = values[key];\r\n        if (typeof value === \"object\" && value.constructor !== Date) {\r\n            memo[key] = publishNestedComposite(value);\r\n        } else if (value.constructor === Date) {\r\n            memo[key] = new Date(value).getTime();\r\n        } else if (value.constructor === Boolean) {\r\n            memo[key] = value.toString();\r\n        } else {\r\n            memo[key] = value;\r\n        }\r\n\r\n        return memo;\r\n    }, {});\r\n}\r\n\r\nfunction flatten(arr: any[]): Glue42Core.Metrics.SystemStateInfo[] {\r\n    return arr.reduce((flat: Glue42Core.Metrics.SystemStateInfo[], toFlatten: Glue42Core.Metrics.SystemStateInfo | Glue42Core.Metrics.SystemStateInfo[]): Glue42Core.Metrics.SystemStateInfo[] => {\r\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\r\n    }, []);\r\n}\r\n\r\nfunction getHighestState(arr: Glue42Core.Metrics.SystemStateInfo[]): Glue42Core.Metrics.SystemStateInfo {\r\n    return arr.sort((a, b) => {\r\n        if (!a.state) { return 1; }\r\n        if (!b.state) { return -1; }\r\n\r\n        return b.state - a.state;\r\n    })[0];\r\n}\r\n\r\nfunction aggregateDescription(arr: Glue42Core.Metrics.SystemStateInfo[]): string {\r\n    let msg = \"\";\r\n    arr.forEach((m: any, idx: number, a: any[]) => {\r\n        const path = m.path.join(\".\");\r\n        if (idx === a.length - 1) {\r\n            msg += path + \".\" + m.name + \": \" + m.description;\r\n        } else {\r\n            msg += path + \".\" + m.name + \": \" + m.description + \",\";\r\n        }\r\n    });\r\n    if (msg.length > 100) {\r\n        return msg.slice(0, 100) + \"...\";\r\n    } else {\r\n        return msg;\r\n    }\r\n}\r\n\r\nfunction composeMsgForRootStateMetric(system: Glue42Core.Metrics.System): any {\r\n    const aggregatedState: Glue42Core.Metrics.SystemStateInfo[] = system.root.getAggregateState();\r\n    const merged = flatten(aggregatedState);\r\n    const highestState = getHighestState(merged);\r\n    const aggregateDesc = aggregateDescription(merged);\r\n    return {\r\n        description: aggregateDesc,\r\n        value: highestState.state,\r\n    };\r\n}\r\n\r\nexport { normalizeMetricName, serializeMetric, getMetricValueByType, composeMsgForRootStateMetric };\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { Protocol } from \"./types\";\r\n\r\nexport default {\r\n    validate: (definition: Glue42Core.Metrics.MetricDefinition, parent: Glue42Core.Metrics.System, transport: Protocol) => {\r\n        if (definition === null || typeof definition !== \"object\") {\r\n            throw new Error(\"Missing definition\");\r\n        }\r\n        if (parent === null || typeof parent !== \"object\") {\r\n            throw new Error(\"Missing parent\");\r\n        }\r\n        if (transport === null || typeof transport !== \"object\") {\r\n            throw new Error(\"Missing transport\");\r\n        }\r\n    },\r\n};\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport Helpers from \"../helpers\";\r\nimport { Protocol } from \"../types\";\r\n\r\nexport class BaseMetric<T> implements Glue42Core.Metrics.Metric {\r\n    public readonly path: string[] = [];\r\n    public readonly name: string;\r\n    public readonly description: string | undefined;\r\n\r\n    public get repo() {\r\n        return this.system?.repo;\r\n    }\r\n\r\n    public get id() { return `${this.system.path}/${name}`; }\r\n\r\n    constructor(public definition: Glue42Core.Metrics.MetricDefinition, public system: Glue42Core.Metrics.System, protected transport: Protocol, public value: T, public type: number) {\r\n        Helpers.validate(definition, system, transport);\r\n\r\n        this.path = system.path.slice(0);\r\n        this.path.push(system.name);\r\n\r\n        this.name = definition.name;\r\n        this.description = definition.description;\r\n\r\n        transport.createMetric(this);\r\n    }\r\n\r\n    public update(newValue: T): Promise<void> {\r\n        this.value = newValue;\r\n        return this.transport.updateMetric(this);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class NumberMetric extends BaseMetric<number> implements Glue42Core.Metrics.NumberMetric {\r\n\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: number) {\r\n        super(definition, system, transport, value, metricTypes.NUMBER);\r\n    }\r\n\r\n    public incrementBy(num: number): void {\r\n        this.update(this.value + num);\r\n    }\r\n\r\n    public increment(): void {\r\n        this.incrementBy(1);\r\n    }\r\n\r\n    public decrement(): void {\r\n        this.incrementBy(-1);\r\n    }\r\n\r\n    public decrementBy(num: number): void {\r\n        this.incrementBy(num * -1);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class ObjectMetric extends BaseMetric<object> implements Glue42Core.Metrics.ObjectMetric {\r\n\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: object) {\r\n        super(definition, system, transport, value, metricTypes.OBJECT);\r\n    }\r\n\r\n    public update(newValue: object): Promise<void> {\r\n        this.mergeValues(newValue);\r\n        return this.transport.updateMetric(this);\r\n    }\r\n\r\n    private mergeValues(values: any) {\r\n        return Object.keys(this.value).forEach((k) => {\r\n            if (typeof values[k] !== \"undefined\") {\r\n                (this.value as any)[k] = values[k];\r\n            }\r\n        });\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class StringMetric extends BaseMetric<string> implements Glue42Core.Metrics.StringMetric {\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: string) {\r\n        super(definition, system, transport, value, metricTypes.STRING);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class TimestampMetric extends BaseMetric<Date> implements Glue42Core.Metrics.TimestampMetric {\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: Date) {\r\n        super(definition, system, transport, value, metricTypes.TIMESTAMP);\r\n    }\r\n\r\n    public now(): void {\r\n        this.update(new Date());\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport system from \"./system\";\r\nimport { MetricsSettings, Protocol } from \"./types\";\r\n\r\nexport class Repository implements Glue42Core.Metrics.Repository {\r\n    public root: Glue42Core.Metrics.System;\r\n\r\n    constructor(options: MetricsSettings, protocol: Protocol) {\r\n        protocol.init(this);\r\n        this.root = system(\"\", this, protocol);\r\n\r\n        this.addSystemMetrics(this.root, options.clickStream || options.clickStream === undefined);\r\n    }\r\n\r\n    private addSystemMetrics(rootSystem: Glue42Core.Metrics.System, useClickStream: any) {\r\n        // Create some system metrics\r\n        if (typeof navigator !== \"undefined\") {\r\n            rootSystem.stringMetric(\"UserAgent\", navigator.userAgent);\r\n        }\r\n\r\n        if (useClickStream && typeof document !== \"undefined\") {\r\n            const clickStream: Glue42Core.Metrics.System = rootSystem.subSystem(\"ClickStream\");\r\n\r\n            const documentClickHandler = (e: Event) => {\r\n                if (!e.target) {\r\n                    return;\r\n                }\r\n                const target = e.target as HTMLAnchorElement;\r\n                clickStream.objectMetric(\"LastBrowserEvent\", {\r\n                    type: \"click\",\r\n                    timestamp: new Date(),\r\n                    target: {\r\n                        className: e.target ? target.className : \"\",\r\n                        id: target.id,\r\n                        type: \"<\" + target.tagName.toLowerCase() + \">\",\r\n                        href: target.href || \"\",\r\n                    },\r\n                });\r\n            };\r\n\r\n            // Create click stream record\r\n            clickStream.objectMetric(\"Page\", {\r\n                title: document.title,\r\n                page: window.location.href,\r\n            });\r\n\r\n            if (document.addEventListener) {\r\n                document.addEventListener(\"click\", documentClickHandler);\r\n            } else {\r\n                // For IE versions prior to IE9, attachEvent method should be used to register the specified listener\r\n                // to the EventTarget it is called on, for others addEventListener should be used.\r\n                // (<any>document)\r\n                (document as any).attachEvent(\"onclick\", documentClickHandler);\r\n            }\r\n        }\r\n\r\n        const startTime = rootSystem.stringMetric(\"StartTime\", (new Date()).toString());\r\n        const urlMetric = rootSystem.stringMetric(\"StartURL\", \"\");\r\n        const appNameMetric = rootSystem.stringMetric(\"AppName\", \"\");\r\n        if (typeof window !== \"undefined\") {\r\n            if (typeof window.location !== \"undefined\") {\r\n                const startUrl = window.location.href;\r\n                urlMetric.update(startUrl);\r\n            }\r\n\r\n            if (typeof window.glue42gd !== \"undefined\") {\r\n                appNameMetric.update(window.glue42gd.appName);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { NumberMetric } from \"./metrics/number\";\r\nimport { ObjectMetric } from \"./metrics/object\";\r\nimport { StringMetric } from \"./metrics/string\";\r\nimport { TimestampMetric } from \"./metrics/timestamp\";\r\n\r\nimport { Glue42Core } from \"./../../glue\";\r\nimport MetricTypes from \"./const/metric-types\";\r\nimport { Protocol } from \"./types\";\r\n\r\nexport default function system(name: string, repo: Glue42Core.Metrics.Repository, protocol: Protocol, parent?: Glue42Core.Metrics.System, description?: any): Glue42Core.Metrics.System {\r\n    // Validation\r\n    // if (!name) throw new Error(\"Name is required. \");\r\n\r\n    if (!repo) {\r\n        throw new Error(\"Repository is required\");\r\n    }\r\n\r\n    if (!protocol) {\r\n        throw new Error(\"Transport is required\");\r\n    }\r\n\r\n    const _transport: Protocol = protocol;\r\n\r\n    const _name: string = name;\r\n    const _description: string = description || \"\";\r\n    const _repo: Glue42Core.Metrics.Repository = repo;\r\n    const _parent: Glue42Core.Metrics.System | undefined = parent;\r\n    const _path: string[] = _buildPath(parent);\r\n    let _state: Glue42Core.Metrics.State = {};\r\n\r\n    const id: string = _arrayToString(_path, \"/\") + name;\r\n    const root: Glue42Core.Metrics.System = repo.root;\r\n    const _subSystems: Glue42Core.Metrics.System[] = [];\r\n    const _metrics: Glue42Core.Metrics.Metric[] = [];\r\n\r\n    function subSystem(nameSystem: string, descriptionSystem?: string): Glue42Core.Metrics.System {\r\n        if (!nameSystem || nameSystem.length === 0) {\r\n            throw new Error(\"name is required\");\r\n        }\r\n\r\n        const match: Glue42Core.Metrics.System[] = _subSystems.filter((s) => s.name === nameSystem);\r\n        if (match.length > 0) {\r\n            return match[0];\r\n        }\r\n\r\n        const _system: Glue42Core.Metrics.System = system(nameSystem, _repo, _transport, me, descriptionSystem);\r\n        _subSystems.push(_system);\r\n        return _system;\r\n    }\r\n\r\n    function setState(state: number, stateDescription?: string): void {\r\n        _state = { state, description: stateDescription };\r\n        _transport.updateSystem(me, _state);\r\n    }\r\n\r\n    function stringMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: string): Glue42Core.Metrics.StringMetric {\r\n        return _getOrCreateMetric<StringMetric>(definition, MetricTypes.STRING, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new StringMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function numberMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: number): Glue42Core.Metrics.NumberMetric {\r\n        return _getOrCreateMetric<NumberMetric>(definition, MetricTypes.NUMBER, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new NumberMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function objectMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: any): Glue42Core.Metrics.ObjectMetric {\r\n        return _getOrCreateMetric<ObjectMetric>(definition, MetricTypes.OBJECT, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new ObjectMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function timestampMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: any): Glue42Core.Metrics.TimestampMetric {\r\n        return _getOrCreateMetric<TimestampMetric>(definition, MetricTypes.TIMESTAMP, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new TimestampMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function _getOrCreateMetric<T extends Glue42Core.Metrics.Metric>(metricObject: Glue42Core.Metrics.MetricDefinition | string, expectedType: number, value: any, createMetric: (metricDef: Glue42Core.Metrics.MetricDefinition, me?: Glue42Core.Metrics.System, _transport?: Protocol, value?: any) => T): T {\r\n        let metricDef = { name: \"\" };\r\n        if (typeof metricObject === \"string\") {\r\n            metricDef = { name: metricObject };\r\n        } else {\r\n            metricDef = metricObject;\r\n        }\r\n        const matching: Glue42Core.Metrics.Metric[] = _metrics.filter((shadowedMetric) => shadowedMetric.name === metricDef.name);\r\n\r\n        if (matching.length > 0) {\r\n            const existing: Glue42Core.Metrics.Metric = matching[0];\r\n            if (existing.type !== expectedType) {\r\n                // NOTE: Extend the error with the already defined metric?\r\n                throw new Error(`A metric named ${metricDef.name} is already defined with different type.`);\r\n            }\r\n\r\n            if (typeof value !== \"undefined\") {\r\n                existing\r\n                    .update(value)\r\n                    .catch(() => { /** swallow */});\r\n            }\r\n\r\n            return existing as T;\r\n        }\r\n\r\n        const metric: T = createMetric(metricDef);\r\n        _metrics.push(metric);\r\n        return metric;\r\n    }\r\n\r\n    function _buildPath(shadowedSystem?: Glue42Core.Metrics.System): string[] {\r\n        if (!shadowedSystem || !shadowedSystem.parent) {\r\n            return [];\r\n        }\r\n\r\n        const path = _buildPath(shadowedSystem.parent);\r\n        path.push(shadowedSystem.name);\r\n        return path;\r\n    }\r\n\r\n    function _arrayToString(path: string[], separator: string) {\r\n        return ((path && path.length > 0) ? path.join(separator) : \"\");\r\n    }\r\n\r\n    function getAggregateState(): Glue42Core.Metrics.SystemStateInfo[] {\r\n        const aggState: Glue42Core.Metrics.SystemStateInfo[] = [];\r\n        if (Object.keys(_state).length > 0) {\r\n            aggState.push({\r\n                name: _name,\r\n                path: _path,\r\n                state: _state.state,\r\n                description: _state.description,\r\n            });\r\n        }\r\n\r\n        _subSystems.forEach((shadowedSubSystem) => {\r\n            const result = shadowedSubSystem.getAggregateState();\r\n            if (result.length > 0) {\r\n                aggState.push(...result);\r\n            }\r\n        });\r\n\r\n        return aggState;\r\n    }\r\n\r\n    const me: Glue42Core.Metrics.System = {\r\n        get name() {\r\n            return _name;\r\n        },\r\n\r\n        get description() {\r\n            return _description;\r\n        },\r\n\r\n        get repo() {\r\n            return _repo;\r\n        },\r\n\r\n        get parent() {\r\n            return _parent;\r\n        },\r\n        path: _path,\r\n        id,\r\n        root,\r\n\r\n        get subSystems() {\r\n            return _subSystems;\r\n        },\r\n\r\n        get metrics() {\r\n            return _metrics;\r\n        },\r\n        subSystem,\r\n        getState: () => {\r\n            return _state;\r\n        },\r\n        setState,\r\n        stringMetric,\r\n        timestampMetric,\r\n        objectMetric,\r\n        numberMetric,\r\n        getAggregateState,\r\n    };\r\n\r\n    _transport.createSystem(me);\r\n\r\n    return me;\r\n}\r\n","import { Protocol } from \"../../types\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\n\r\nexport class NullProtocol implements Protocol {\r\n    public init(repo: Glue42Core.Metrics.Repository): void {\r\n        // do nothing\r\n    }\r\n\r\n    public createSystem(system: Glue42Core.Metrics.System): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public updateSystem(metric: Glue42Core.Metrics.System, state: Glue42Core.Metrics.State): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public createMetric(metric: Glue42Core.Metrics.Metric): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public updateMetric(metric: Glue42Core.Metrics.Metric): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { count } from \"console\";\r\n\r\nexport class PerfTracker {\r\n\r\n    private lastCount = 0;\r\n\r\n    private initialPublishTimeout = 10 * 1000; // 10 sec\r\n    private publishInterval = 60 * 1000; // 60 sec\r\n    private system: Glue42Core.Metrics.System;\r\n\r\n    constructor(private api: Glue42Core.Metrics.API, initialPublishTimeout?: number, publishInterval?: number) {\r\n        this.initialPublishTimeout = initialPublishTimeout ?? this.initialPublishTimeout;\r\n        this.publishInterval = publishInterval ?? this.publishInterval;\r\n        this.scheduleCollection();\r\n        this.system = this.api.subSystem(\"performance\", \"Performance data published by the web application\");\r\n    }\r\n\r\n    private scheduleCollection() {\r\n        setTimeout(() => {\r\n            this.collect();\r\n            setInterval(() => {\r\n                this.collect();\r\n            }, this.publishInterval);\r\n        }, this.initialPublishTimeout);\r\n    }\r\n\r\n    private collect() {\r\n        try {\r\n            // tslint:disable-next-line:no-console\r\n            this.collectMemory();\r\n            this.collectEntries();\r\n        } catch {\r\n            // DO NOTHING\r\n        }\r\n    }\r\n\r\n    private collectMemory() {\r\n        // memory - use performance.memory\r\n        const memory = (window.performance as any).memory;\r\n        this.system.stringMetric(\"memory\", JSON.stringify({\r\n            totalJSHeapSize: memory.totalJSHeapSize,\r\n            usedJSHeapSize: memory.usedJSHeapSize\r\n        }));\r\n    }\r\n\r\n    private collectEntries() {\r\n        const allEntries = window.performance.getEntries();\r\n        if (allEntries.length <= this.lastCount) {\r\n            return;\r\n        }\r\n        this.lastCount = allEntries.length;\r\n        const jsonfiedEntries = allEntries.map((i) => i.toJSON());\r\n\r\n        this.system.stringMetric(\"entries\", JSON.stringify(jsonfiedEntries));\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport gw3 from \"./protocols/gw3/gw3\";\r\nimport { Repository } from \"./repository\";\r\nimport { Protocol, MetricsSettings } from \"./types\";\r\nimport { NullProtocol } from \"./protocols/null/null\";\r\nimport { PerfTracker } from \"./pertTracker\";\r\n\r\nexport default (options: MetricsSettings): Glue42Core.Metrics.API => {\r\n\r\n    let protocol: Protocol;\r\n    if (!options.connection || typeof options.connection !== \"object\") {\r\n        protocol = new NullProtocol();\r\n    } else {\r\n        protocol = gw3(options.connection, options);\r\n    }\r\n\r\n    const repo = new Repository(options, protocol);\r\n    let rootSystem = repo.root;\r\n    if (!options.disableAutoAppSystem) {\r\n        rootSystem = rootSystem.subSystem(\"App\");\r\n    }\r\n\r\n    // add FAV support\r\n    const api = addFAVSupport(rootSystem);\r\n    // initialize page performance\r\n    initPerf(api, options.pagePerformanceMetrics);\r\n\r\n    return api;\r\n};\r\n\r\nlet perf: PerfTracker;\r\nfunction initPerf(api: Glue42Core.Metrics.API, config?: Glue42Core.PagePerformanceMetricsConfig) {\r\n    if (typeof window === \"undefined\") {\r\n        return;\r\n    }\r\n\r\n    // allow Glue42 Enterprise to override\r\n    const perfConfig = window?.glue42gd?.metrics?.pagePerformanceMetrics;\r\n    if (perfConfig) {\r\n        // allow Glue42 Enterprise to override\r\n        config = perfConfig;\r\n    }\r\n\r\n    if (config?.enabled) {\r\n        perf = new PerfTracker(api, config.initialPublishTimeout, config.publishInterval);\r\n    }\r\n}\r\n\r\nfunction addFAVSupport(system: Glue42Core.Metrics.System): Glue42Core.Metrics.API {\r\n    // Creating subsystem for reporting and feature metric\r\n    const reportingSystem: Glue42Core.Metrics.System = system.subSystem(\"reporting\");\r\n    const def = {\r\n        name: \"features\"\r\n    };\r\n\r\n    let featureMetric: Glue42Core.Metrics.ObjectMetric;\r\n\r\n    const featureMetricFunc = (name: string, action: string, payload: string) => {\r\n        if (typeof name === \"undefined\" || name === \"\") {\r\n            throw new Error(\"name is mandatory\");\r\n        } else if (typeof action === \"undefined\" || action === \"\") {\r\n            throw new Error(\"action is mandatory\");\r\n        } else if (typeof payload === \"undefined\" || payload === \"\") {\r\n            throw new Error(\"payload is mandatory\");\r\n        }\r\n\r\n        if (!featureMetric) {\r\n            featureMetric = reportingSystem.objectMetric(def, { name, action, payload });\r\n        } else {\r\n            featureMetric.update({\r\n                name,\r\n                action,\r\n                payload\r\n            });\r\n        }\r\n    };\r\n    (system as any).featureMetric = featureMetricFunc;\r\n    return system as Glue42Core.Metrics.API;\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { Protocol, MetricsSettings } from \"../../types\";\r\nimport { composeMsgForRootStateMetric, getMetricValueByType, normalizeMetricName, serializeMetric } from \"./serializer\";\r\nimport Connection from \"../../../connection/connection\";\r\n\r\nexport default function (connection: Connection, config: MetricsSettings): Protocol {\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n\r\n    let joinPromise: Promise<any>;\r\n    let session: Glue42Core.Connection.GW3DomainSession;\r\n\r\n    const init = (repo: Glue42Core.Metrics.Repository): void => {\r\n        let resolveReadyPromise: (() => void) | undefined;\r\n        joinPromise = new Promise((resolve) => {\r\n            resolveReadyPromise = resolve;\r\n        });\r\n\r\n        session = connection.domain(\"metrics\");\r\n\r\n        session.onJoined((reconnect) => {\r\n            if (!reconnect && resolveReadyPromise) {\r\n                resolveReadyPromise();\r\n                resolveReadyPromise = undefined;\r\n            }\r\n\r\n            // Creating root state metric\r\n            const rootStateMetric: any = {\r\n                name: \"/State\",\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n\r\n            const defineRootMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [rootStateMetric],\r\n            };\r\n\r\n            session.send(defineRootMetricsMsg);\r\n\r\n            if (reconnect) {\r\n                replayRepo(repo);\r\n            }\r\n\r\n        });\r\n\r\n        session.join({\r\n            system: config.system,\r\n            service: config.service,\r\n            instance: config.instance\r\n        });\r\n    };\r\n\r\n    const replayRepo = (repo: Glue42Core.Metrics.Repository) => {\r\n        replaySystem(repo.root);\r\n    };\r\n\r\n    const replaySystem = (system: Glue42Core.Metrics.System) => {\r\n        // replay system\r\n        createSystem(system);\r\n\r\n        // replay all metrics in the system\r\n        system.metrics.forEach((m) => {\r\n            createMetric(m);\r\n        });\r\n\r\n        // replay all sub-systems\r\n        system.subSystems.forEach((ss) => {\r\n            replaySystem(ss);\r\n        });\r\n    };\r\n\r\n    const createSystem = async (system: Glue42Core.Metrics.System): Promise<void> => {\r\n        if (system.parent === undefined) {\r\n            return;\r\n        }\r\n\r\n        await joinPromise;\r\n        const metric = {\r\n            name: normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n            type: \"object\",\r\n            composite: {\r\n                Description: {\r\n                    type: \"string\",\r\n                    description: \"\",\r\n                },\r\n                Value: {\r\n                    type: \"number\",\r\n                    description: \"\",\r\n                },\r\n            },\r\n            description: \"System state\",\r\n            context: {},\r\n        };\r\n\r\n        const createMetricsMsg = {\r\n            type: \"define\",\r\n            metrics: [metric],\r\n        };\r\n\r\n        session.send(createMetricsMsg);\r\n    };\r\n\r\n    const updateSystem = async (system: Glue42Core.Metrics.System, state: Glue42Core.Metrics.State): Promise<void> => {\r\n        await joinPromise;\r\n\r\n        const shadowedUpdateMetric = {\r\n            type: \"publish\",\r\n            values: [{\r\n                name: normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                value: {\r\n                    Description: state.description,\r\n                    Value: state.state,\r\n                },\r\n                timestamp: Date.now(),\r\n            }],\r\n        };\r\n\r\n        session.send(shadowedUpdateMetric);\r\n\r\n        const stateObj = composeMsgForRootStateMetric(system);\r\n        const rootMetric = {\r\n            type: \"publish\",\r\n            peer_id: connection.peerId,\r\n            values: [{\r\n                name: \"/State\",\r\n                value: {\r\n                    Description: stateObj.description,\r\n                    Value: stateObj.value,\r\n                },\r\n                timestamp: Date.now(),\r\n            }],\r\n        };\r\n\r\n        session.send(rootMetric);\r\n    };\r\n\r\n    const createMetric = async (metric: Glue42Core.Metrics.Metric): Promise<void> => {\r\n        const metricClone = cloneMetric(metric);\r\n        await joinPromise;\r\n        const m = serializeMetric(metricClone);\r\n\r\n        const createMetricsMsg = {\r\n            type: \"define\",\r\n            metrics: [m],\r\n        };\r\n\r\n        session.send(createMetricsMsg);\r\n        if (typeof metricClone.value !== \"undefined\") {\r\n            // do not use updateMetric because it will dispatch the call (joinPromise.then)\r\n            // which leads to method calls reorder. It is safe to call updateMetricCore directly\r\n            // because we are being executed in joinPromise.then\r\n            updateMetricCore(metricClone);\r\n        }\r\n    };\r\n\r\n    const updateMetric = async (metric: Glue42Core.Metrics.Metric): Promise<void> => {\r\n        const metricClone = cloneMetric(metric);\r\n        await joinPromise;\r\n        updateMetricCore(metricClone);\r\n    };\r\n\r\n    const updateMetricCore = (metric: Glue42Core.Metrics.Metric): Promise<void> => {\r\n        if (canUpdate()) {\r\n            const value = getMetricValueByType(metric);\r\n            const publishMetricsMsg = {\r\n                type: \"publish\",\r\n                values: [{\r\n                    name: normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name),\r\n                    value,\r\n                    timestamp: Date.now(),\r\n                }],\r\n            };\r\n            return session.sendFireAndForget(publishMetricsMsg);\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n\r\n    const cloneMetric = (metric: Glue42Core.Metrics.Metric): Glue42Core.Metrics.Metric => {\r\n        const metricClone: Glue42Core.Metrics.Metric = { ...metric };\r\n        if (typeof metric.value === \"object\" && metric.value !== null) {\r\n            metricClone.value = { ...metric.value };\r\n        }\r\n        return metricClone;\r\n    };\r\n\r\n    const canUpdate = (): boolean => {\r\n        try {\r\n            const func = config.canUpdateMetric ?? (() => true);\r\n            return func();\r\n        } catch {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    return {\r\n        init,\r\n        createSystem,\r\n        updateSystem,\r\n        createMetric,\r\n        updateMetric,\r\n    };\r\n}\r\n","\"use strict\";\r\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback, replayArgumentsArr) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        if (replayArgumentsArr) {\r\n            setTimeout(function () {\r\n                replayArgumentsArr.forEach(function (replayArgument) {\r\n                    var _a;\r\n                    if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {\r\n                        try {\r\n                            if (Array.isArray(replayArgument)) {\r\n                                callback.apply(undefined, replayArgument);\r\n                            }\r\n                            else {\r\n                                callback.apply(undefined, [replayArgument]);\r\n                            }\r\n                        }\r\n                        catch (err) {\r\n                            _handleError(err, key);\r\n                        }\r\n                    }\r\n                });\r\n            }, 0);\r\n        }\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            if (allForKey.length === 0) {\r\n                delete callbacks[key];\r\n            }\r\n            else {\r\n                callbacks[key] = allForKey;\r\n            }\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    function clearKey(key) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            return;\r\n        }\r\n        delete callbacks[key];\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear,\r\n        clearKey: clearKey\r\n    };\r\n}\r\n;\r\ncreateRegistry.default = createRegistry;\r\nmodule.exports = createRegistry;\r\n//# sourceMappingURL=index.js.map","import { Transport } from \"../types\";\r\nimport { default as CallbackRegistryFactory, CallbackRegistry, UnsubscribeFunction } from \"callback-registry\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { Logger } from \"../../logger/logger\";\r\n\r\nexport default class InProcTransport implements Transport {\r\n\r\n    private gw: Glue42Core.Connection.GW3Facade;\r\n    private registry: CallbackRegistry = CallbackRegistryFactory();\r\n    private client?: Glue42Core.Connection.GW3Client;\r\n\r\n    constructor(settings: Glue42Core.InprocGWSettings, logger: Logger) {\r\n        this.gw = settings.facade;\r\n        this.gw.connect((_client, message) => {\r\n            this.messageHandler(message);\r\n        }).then((client) => {\r\n            this.client = client;\r\n        });\r\n    }\r\n\r\n    public get isObjectBasedTransport() {\r\n        return true;\r\n    }\r\n\r\n    public sendObject(msg: object): Promise<void> {\r\n        if (this.client) {\r\n            this.client.send(msg);\r\n            return Promise.resolve(undefined);\r\n        } else {\r\n            return Promise.reject(`not connected`);\r\n        }\r\n    }\r\n\r\n    public send(_msg: string) {\r\n        return Promise.reject(\"not supported\");\r\n    }\r\n\r\n    public onMessage(callback: (msg: string | object) => void): UnsubscribeFunction {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean) => void) {\r\n        callback(true);\r\n    }\r\n\r\n    public close() {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public open() {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public name(): string {\r\n        return \"in-memory\";\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private messageHandler(msg: object) {\r\n        this.registry.execute(\"onMessage\", msg);\r\n    }\r\n}\r\n","import { Transport } from \"../types\";\r\nimport {\r\n    default as CallbackRegistryFactory,\r\n    CallbackRegistry,\r\n    UnsubscribeFunction,\r\n} from \"callback-registry\";\r\nimport { Logger } from \"../../logger/logger\";\r\n\r\n// tslint:disable-next-line:no-namespace\r\ndeclare namespace SharedWorker {\r\n    interface AbstractWorker extends EventTarget {\r\n        onerror: (ev: ErrorEvent) => any;\r\n    }\r\n\r\n    export interface SharedWorker extends AbstractWorker {\r\n        /**\r\n         * the value it was assigned by the object's constructor.\r\n         * It represents the MessagePort for communicating with the shared worker.\r\n         * @type {MessagePort}\r\n         */\r\n        port: MessagePort;\r\n    }\r\n\r\n    export interface SharedWorkerGlobalScope extends Worker {\r\n        onconnect: (event: MessageEvent) => void;\r\n    }\r\n}\r\n\r\n/**\r\n * Shared worker transport\r\n */\r\nexport default class SharedWorkerTransport implements Transport {\r\n    private worker: any;\r\n    private registry: CallbackRegistry = CallbackRegistryFactory();\r\n\r\n    constructor(workerFile: string, private logger: Logger) {\r\n        this.worker = new SharedWorker(workerFile);\r\n        this.worker.port.onmessage = (e: { data: any; timestamp: number }) => {\r\n            this.messageHandler(e.data);\r\n        };\r\n    }\r\n\r\n    public get isObjectBasedTransport() {\r\n        return true;\r\n    }\r\n\r\n    public sendObject(msg: object): Promise<void> {\r\n        this.worker.port.postMessage(msg);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public send(_msg: string) {\r\n        return Promise.reject(\"not supported\");\r\n    }\r\n\r\n    public onMessage(\r\n        callback: (msg: string | object) => void\r\n    ): UnsubscribeFunction {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean) => void) {\r\n        callback(true);\r\n    }\r\n\r\n    public close() {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public open() {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public name(): string {\r\n        return \"shared-worker\";\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private messageHandler(msg: object) {\r\n        this.registry.execute(\"onMessage\", msg);\r\n    }\r\n}\r\n\r\ninterface SharedWorkerOptions {\r\n    credentials?: RequestCredentials;\r\n    name?: string;\r\n    type?: WorkerType;\r\n}\r\n\r\n// eslint-disable-next-line\r\ndeclare var SharedWorker: {\r\n    prototype: SharedWorker.SharedWorker;\r\n\r\n    /**\r\n     *\r\n     * @param {string} stringUrl                          Pathname to JavaScript file\r\n     * @param {string|SharedWorkerOptions} [options]      Name of the worker to execute\r\n     *                                                    or an object containing option properties\r\n     */\r\n    new(\r\n        stringUrl: string,\r\n        options?: string | SharedWorkerOptions\r\n    ): SharedWorker.SharedWorker;\r\n};\r\n","export default class Utils {\r\n\r\n    public static getGDMajorVersion(): number | undefined {\r\n        if (typeof window === \"undefined\") {\r\n            return undefined;\r\n        }\r\n        if (!window.glueDesktop) {\r\n            return undefined;\r\n        }\r\n        if (!window.glueDesktop.version) {\r\n            return undefined;\r\n        }\r\n        const ver = Number(window.glueDesktop.version.substr(0, 1));\r\n        return isNaN(ver) ? undefined : ver;\r\n    }\r\n\r\n    public static isNode() {\r\n        if (typeof Utils._isNode !== \"undefined\") {\r\n            return Utils._isNode;\r\n        }\r\n\r\n        if (typeof window !== \"undefined\") {\r\n            Utils._isNode = false;\r\n            return false;\r\n        }\r\n\r\n        // Only Node.JS has a process variable that is of [[Class]] process\r\n        try {\r\n            Utils._isNode = Object.prototype.toString.call(global.process) === \"[object process]\";\r\n        } catch (e) {\r\n            Utils._isNode = false;\r\n        }\r\n        return Utils._isNode;\r\n    }\r\n    private static _isNode?: boolean;\r\n}\r\n","export class PromiseWrapper<T> {\r\n\r\n    public static delay(time: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, time));\r\n    }\r\n\r\n    public resolve!: (arg?: T | PromiseLike<T>) => void;\r\n    public reject!: (err: any) => void;\r\n    public promise: Promise<T>;\r\n    public rejected: boolean = false;\r\n    public resolved: boolean = false;\r\n    public get ended(): boolean {\r\n        return this.rejected || this.resolved;\r\n    }\r\n\r\n    constructor() {\r\n        this.promise = new Promise<T>((resolve, reject) => {\r\n            this.resolve = (t: any) => {\r\n                this.resolved = true;\r\n                resolve(t);\r\n            };\r\n\r\n            this.reject = (err: any) => {\r\n                this.rejected = true;\r\n                reject(err);\r\n            };\r\n        });\r\n    }\r\n}\r\n","import { Timer, Mark } from \"../types\";\r\n\r\nconst timers: { [index: string]: Timer } = {};\r\n\r\nexport function getAllTimers() {\r\n    return timers;\r\n}\r\n\r\nexport default function (timerName: string): Timer {\r\n    const existing = timers[timerName];\r\n    if (existing) {\r\n        return existing;\r\n    }\r\n\r\n    const marks: Mark[] = [];\r\n    function now(): number {\r\n        return new Date().getTime();\r\n    }\r\n\r\n    const startTime = now();\r\n    mark(\"start\", startTime);\r\n    let endTime: number;\r\n    let period: number;\r\n\r\n    function stop(): number {\r\n        endTime = now();\r\n        mark(\"end\", endTime);\r\n        period = endTime - startTime;\r\n        return period;\r\n    }\r\n\r\n    function mark(name: string, time?: number): void {\r\n        const currentTime = time ?? now();\r\n        let diff = 0;\r\n        if (marks.length > 0) {\r\n            diff = currentTime - marks[marks.length - 1].time;\r\n        }\r\n        marks.push({ name, time: currentTime, diff });\r\n    }\r\n\r\n    const timerObj = {\r\n        get startTime(): number {\r\n            return startTime;\r\n        },\r\n        get endTime(): number {\r\n            return endTime;\r\n        },\r\n        get period(): number {\r\n            return period;\r\n        },\r\n        stop,\r\n        mark,\r\n        marks\r\n    };\r\n\r\n    timers[timerName] = timerObj;\r\n    return timerObj;\r\n}\r\n","import {\r\n    default as CallbackRegistryFactory,\r\n    CallbackRegistry,\r\n} from \"callback-registry\";\r\nimport { Transport, ConnectionSettings } from \"../types\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport Utils from \"../../utils/utils\";\r\nimport { PromiseWrapper } from \"../../utils/pw\";\r\nimport timer from \"../../utils/timer\";\r\n\r\nconst WebSocketConstructor = Utils.isNode() ? require(\"ws\") : window.WebSocket;\r\n\r\nexport default class WS implements Transport {\r\n    private ws: WebSocket | undefined;\r\n    private logger: Logger;\r\n    private settings: ConnectionSettings;\r\n    private startupTimer = timer(\"connection\");\r\n\r\n    /**\r\n     * If the flag is true the connection should keep trying to connect.\r\n     * If false the user explicitly closed it and it should not reconnect\r\n     */\r\n    private _running = true;\r\n\r\n    private _registry: CallbackRegistry = CallbackRegistryFactory();\r\n    private wsRequests: Array<{ callback: () => void, failed?: (err?: string) => void }> = [];\r\n\r\n    constructor(settings: ConnectionSettings, logger: Logger) {\r\n        this.settings = settings;\r\n        this.logger = logger;\r\n        if (!this.settings.ws) {\r\n            throw new Error(\"ws is missing\");\r\n        }\r\n    }\r\n\r\n    public onMessage(callback: (msg: string) => void): () => void {\r\n        return this._registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    // Create a function for sending a message\r\n    public send(msg: string, options?: Glue42Core.Connection.SendMessageOptions): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n            options = options || {};\r\n            this.waitForSocketConnection(\r\n                () => {\r\n                    try {\r\n                        this.ws?.send(msg);\r\n                        resolve();\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                },\r\n                reject\r\n            );\r\n        });\r\n    }\r\n\r\n    public open() {\r\n        this.logger.info(`opening ws...`);\r\n        this._running = true;\r\n        return new Promise<void>((resolve, reject) => {\r\n            this.waitForSocketConnection(\r\n                resolve,\r\n                reject\r\n            );\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        this._running = false;\r\n        if (this.ws) {\r\n            this.ws.close();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean, reason?: string) => void): () => void {\r\n        return this._registry.add(\"onConnectedChanged\", callback);\r\n    }\r\n\r\n    public name(): string {\r\n        return `ws ${this.settings.ws}`;\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        this.ws?.close();\r\n        const pw = new PromiseWrapper<void>();\r\n        this.waitForSocketConnection(() => {\r\n            pw.resolve();\r\n        });\r\n        return pw.promise;\r\n    }\r\n\r\n    // Holds callback execution until socket connection is established.\r\n    private waitForSocketConnection(\r\n        callback: () => void,\r\n        failed?: (err?: string) => void\r\n    ) {\r\n        failed = failed ?? (() => { /** DO nothing */ });\r\n\r\n        // check if we're still running\r\n        if (!this._running) {\r\n            failed(\r\n                `wait for socket on ${this.settings.ws} failed - socket closed by user`\r\n            );\r\n            return;\r\n        }\r\n\r\n        // if socket is opened - returned immediately\r\n        if (this.ws?.readyState === 1) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        // store the callback\r\n        this.wsRequests.push({ callback, failed });\r\n        // if someone has already initiated the socket return\r\n        if (this.wsRequests.length > 1) {\r\n            return;\r\n        }\r\n\r\n        this.openSocket();\r\n    }\r\n\r\n    private async openSocket(retryInterval?: number, retriesLeft?: number) {\r\n        this.startupTimer.mark(\"opening-socket\");\r\n        if (retryInterval === undefined) {\r\n            retryInterval = this.settings.reconnectInterval;\r\n        }\r\n\r\n        if (retriesLeft !== undefined) {\r\n            if (retriesLeft === 0) {\r\n                this.notifyForSocketState(\r\n                    `wait for socket on ${this.settings.ws} failed - no more retries left`\r\n                );\r\n                return;\r\n            }\r\n            this.logger.debug(\r\n                `will retry ${retriesLeft} more times (every ${retryInterval} ms)`\r\n            );\r\n        }\r\n\r\n        try {\r\n            await this.initiateSocket();\r\n            this.startupTimer.mark(\"socket-initiated\");\r\n            this.notifyForSocketState();\r\n        } catch {\r\n            setTimeout(() => {\r\n                const retries =\r\n                    retriesLeft === undefined ? undefined : retriesLeft - 1;\r\n                this.openSocket(\r\n                    retryInterval,\r\n                    retries,\r\n                );\r\n            }, retryInterval); // wait X milliseconds for the connection...\r\n        }\r\n    }\r\n\r\n    private initiateSocket(): Promise<void> {\r\n        const pw = new PromiseWrapper<void>();\r\n        this.logger.debug(`initiating ws to ${this.settings.ws}...`);\r\n        this.ws = new WebSocketConstructor(this.settings.ws || \"\") as WebSocket;\r\n        this.ws.onerror = (err: any) => {\r\n            let reason: string = \"\";\r\n            try {\r\n                reason = JSON.stringify(err);\r\n            } catch (error) {\r\n                const seen = new WeakSet();\r\n                const replacer = (key: string, value: any) => {\r\n                    if (typeof value === \"object\" && value !== null) {\r\n                        if (seen.has(value)) {\r\n                            return;\r\n                        }\r\n                        seen.add(value);\r\n                    }\r\n                    return value;\r\n                };\r\n\r\n                reason = JSON.stringify(err, replacer);\r\n            }\r\n\r\n            pw.reject(\"error\");\r\n            this.notifyStatusChanged(false, reason);\r\n        };\r\n        this.ws.onclose = (err) => {\r\n            this.logger.info(`ws closed ${err}`);\r\n            pw.reject(\"closed\");\r\n            this.notifyStatusChanged(false);\r\n        };\r\n        // Log on connection\r\n        this.ws.onopen = () => {\r\n            // tslint:disable-next-line:no-console\r\n            this.startupTimer.mark(\"ws-opened\");\r\n            this.logger.info(`ws opened ${this.settings.identity?.application}`);\r\n            pw.resolve();\r\n            this.notifyStatusChanged(true);\r\n        };\r\n        // Attach handler\r\n        this.ws.onmessage = (message: { data: object }) => {\r\n            this._registry.execute(\"onMessage\", message.data);\r\n        };\r\n\r\n        return pw.promise;\r\n    }\r\n\r\n    private notifyForSocketState(error?: string) {\r\n        this.wsRequests.forEach((wsRequest) => {\r\n            if (error) {\r\n                if (wsRequest.failed) {\r\n                    wsRequest.failed(error);\r\n                }\r\n            } else {\r\n                wsRequest.callback();\r\n            }\r\n        });\r\n        this.wsRequests = [];\r\n    }\r\n\r\n    private notifyStatusChanged(status: boolean, reason?: string) {\r\n        this._registry.execute(\"onConnectedChanged\", status, reason);\r\n    }\r\n}\r\n","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nmodule.exports = {\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nfunction randomByte() {\n    if (!crypto || !crypto.getRandomValues) {\n        return Math.floor(Math.random() * 256) & 0x30;\n    }\n    var dest = new Uint8Array(1);\n    crypto.getRandomValues(dest);\n    return dest[0] & 0x30;\n}\n\nmodule.exports = randomByte;\n","'use strict';\n\nvar randomByte = require('./random/random-byte');\n\nfunction encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = encode;\n","'use strict';\nvar alphabet = require('./alphabet');\n\n/**\n * Decode the id to get the version and worker\n * Mainly for debugging and testing.\n * @param id - the shortid-generated id.\n */\nfunction decode(id) {\n    var characters = alphabet.shuffled();\n    return {\n        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n    };\n}\n\nmodule.exports = decode;\n","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var characters = alphabet.characters();\n    var len = id.length;\n    for(var i = 0; i < len;i++) {\n        if (characters.indexOf(id[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nmodule.exports = isShortId;\n","'use strict';\n\nvar alphabet = require('./alphabet');\nvar encode = require('./encode');\nvar decode = require('./decode');\nvar isValid = require('./is-valid');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode(alphabet.lookup, version);\n    str = str + encode(alphabet.lookup, clusterWorkerId);\n    if (counter > 0) {\n        str = str + encode(alphabet.lookup, counter);\n    }\n    str = str + encode(alphabet.lookup, seconds);\n\n    return str;\n}\n\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.decode = decode;\nmodule.exports.isValid = isValid;\n","'use strict';\nmodule.exports = require('./lib/index');\n","import { Glue42Core } from \"../../../glue\";\r\nimport { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport generate from \"shortid\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport Connection from \"../connection\";\r\n\r\ninterface GW3Message {\r\n    request_id?: string;\r\n    domain?: string;\r\n    peer_id?: string;\r\n    _tag?: object;\r\n}\r\n\r\n/**\r\n * Handles domain session lifetime and events for a given connection/domain pair\r\n */\r\nexport default function (domain: string, connection: Connection, logger: Logger, successMessages?: string[], errorMessages?: string[]): Glue42Core.Connection.GW3DomainSession {\r\n\r\n    if (domain == null) {\r\n        domain = \"global\";\r\n    }\r\n\r\n    successMessages = successMessages || [\"success\"];\r\n    errorMessages = errorMessages || [\"error\"];\r\n\r\n    let isJoined = false;\r\n    let tryReconnecting = false;\r\n    /** holds latest options passed to join - used when doing reconnects */\r\n    let _latestOptions: object | undefined;\r\n    // #deleteme TODO: verify this gets properly set to true\r\n    let _connectionOn: boolean = false;\r\n\r\n    const callbacks: CallbackRegistry = CallbackRegistryFactory();\r\n\r\n    // attach event handlers to connection\r\n    connection.disconnected(handleConnectionDisconnected);\r\n    connection.loggedIn(handleConnectionLoggedIn);\r\n    connection.on(\"success\", (msg: GW3Message) => handleSuccessMessage(msg));\r\n    connection.on(\"error\", (msg: GW3Message) => handleErrorMessage(msg));\r\n    connection.on(\"result\", (msg: GW3Message) => handleSuccessMessage(msg));\r\n\r\n    if (successMessages) {\r\n        successMessages.forEach((sm) => {\r\n            connection.on(sm, (msg: GW3Message) => handleSuccessMessage(msg));\r\n        });\r\n    }\r\n    if (errorMessages) {\r\n        errorMessages.forEach((sm) => {\r\n            connection.on(sm, (msg: GW3Message) => handleErrorMessage(msg));\r\n        });\r\n    }\r\n\r\n    interface RequestHandler {\r\n        success: (success: { _tag?: object }) => void;\r\n        error: (error: { _tag?: object, err?: string }) => void;\r\n    }\r\n\r\n    const requestsMap: { [key: string]: RequestHandler } = {};\r\n\r\n    function join(options?: object): Promise<{}> {\r\n        _latestOptions = options;\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (isJoined) {\r\n                resolve();\r\n                return;\r\n            }\r\n            let joinPromise: Promise<{}>;\r\n\r\n            if (domain === \"global\") {\r\n                joinPromise = _connectionOn ? Promise.resolve<{}>({}) : Promise.reject<{}>(\"not connected to gateway\");\r\n            } else {\r\n                logger.debug(`joining domain ${domain}`);\r\n\r\n                const joinMsg = {\r\n                    type: \"join\",\r\n                    destination: domain,\r\n                    domain: \"global\",\r\n                    options,\r\n                };\r\n\r\n                // #deleteme TODO: what happens if multiple clients try to open the same domain?\r\n                // e.g. contexts\r\n                joinPromise = send(joinMsg);\r\n            }\r\n            joinPromise\r\n                .then(() => {\r\n                    handleJoined();\r\n                    resolve();\r\n                })\r\n                .catch((err) => {\r\n                    logger.debug(\"error joining \" + domain + \" domain: \" + JSON.stringify(err));\r\n                    reject(err);\r\n                });\r\n        });\r\n    }\r\n\r\n    // terminology: join vs leave (domain), connect vs login vs disconnect (to/from GW)\r\n    function leave(): Promise<void> {\r\n        if (domain === \"global\") {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        logger.debug(\"stopping session \" + domain + \"...\");\r\n        const leaveMsg = {\r\n            type: \"leave\",\r\n            destination: domain,\r\n            domain: \"global\",\r\n        };\r\n        tryReconnecting = false;\r\n        // #deleteme - handling\r\n        return send(leaveMsg).then(() => {\r\n            isJoined = false;\r\n            callbacks.execute(\"onLeft\");\r\n        });\r\n    }\r\n\r\n    function handleJoined() {\r\n        logger.debug(\"did join \" + domain);\r\n\r\n        isJoined = true;\r\n        const wasReconnect = tryReconnecting;\r\n        tryReconnecting = false;\r\n        callbacks.execute(\"onJoined\", wasReconnect);\r\n    }\r\n\r\n    function handleConnectionDisconnected() {\r\n        _connectionOn = false;\r\n        logger.debug(\"connection is down\");\r\n        isJoined = false;\r\n        tryReconnecting = true;\r\n        callbacks.execute(\"onLeft\", { disconnected: true });\r\n    }\r\n\r\n    function handleConnectionLoggedIn() {\r\n        _connectionOn = true;\r\n        if (tryReconnecting) {\r\n            logger.debug(\"connection is now up - trying to reconnect...\");\r\n            join(_latestOptions);\r\n        }\r\n    }\r\n\r\n    function onJoined(callback: (wasReconnect: boolean) => void) {\r\n        if (isJoined) {\r\n            callback(false);\r\n        }\r\n\r\n        return callbacks.add(\"onJoined\", callback);\r\n    }\r\n\r\n    function onLeft(callback: () => void) {\r\n        if (!isJoined) {\r\n            callback();\r\n        }\r\n\r\n        return callbacks.add(\"onLeft\", callback);\r\n    }\r\n\r\n    function handleErrorMessage(msg: GW3Message) {\r\n        if (domain !== msg.domain) {\r\n            return;\r\n        }\r\n\r\n        const requestId = msg.request_id;\r\n        if (!requestId) {\r\n            return;\r\n        }\r\n        const entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n\r\n        entry.error(msg);\r\n    }\r\n\r\n    function handleSuccessMessage(msg: GW3Message) {\r\n        if (msg.domain !== domain) {\r\n            return;\r\n        }\r\n        const requestId = msg.request_id;\r\n        if (!requestId) {\r\n            return;\r\n        }\r\n        const entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.success(msg);\r\n    }\r\n\r\n    function getNextRequestId() {\r\n        return generate();\r\n    }\r\n\r\n    /**\r\n     * Send a message\r\n     * @param msg message to send\r\n     * @param tag a custom object (tag) - it will be transferred to success/error callback\r\n     * @param success\r\n     * @param error\r\n     */\r\n    function send<T>(msg: GW3Message, tag?: object, options?: Glue42Core.Connection.SendMessageOptions): Promise<T> {\r\n        options = options || {};\r\n        // Allows function caller to override request_id\r\n        msg.request_id = msg.request_id || getNextRequestId();\r\n        // Allows function caller to override domain (join/leave messages are in global domain)\r\n        msg.domain = msg.domain || domain;\r\n        if (!options.skipPeerId) {\r\n            msg.peer_id = connection.peerId;\r\n        }\r\n\r\n        const requestId = msg.request_id;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            requestsMap[requestId] = {\r\n                success: (successMsg: any) => {\r\n                    delete requestsMap[requestId];\r\n                    successMsg._tag = tag;\r\n                    resolve(successMsg);\r\n                },\r\n                error: (errorMsg: { _tag?: any, error?: string }) => {\r\n                    logger.warn(`GW error - ${JSON.stringify(errorMsg)} for request ${JSON.stringify(msg)}`);\r\n                    delete requestsMap[requestId];\r\n                    errorMsg._tag = tag;\r\n                    reject(errorMsg);\r\n                },\r\n            };\r\n            connection\r\n                .send(msg, options)\r\n                .catch((err: string) => {\r\n                    requestsMap[requestId].error({ err });\r\n                });\r\n        });\r\n    }\r\n\r\n    function sendFireAndForget(msg: GW3Message): Promise<void> {\r\n        // Allows function caller to override request_id\r\n        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();\r\n        // Allows function caller to override domain (join/leave messages are in global domain)\r\n        msg.domain = msg.domain || domain;\r\n        msg.peer_id = connection.peerId;\r\n\r\n        return connection.send(msg);\r\n    }\r\n\r\n    return {\r\n        join,\r\n        leave,\r\n        onJoined,\r\n        onLeft,\r\n        send,\r\n        sendFireAndForget,\r\n        on: <T>(type: string, callback: (msg: T) => void) => {\r\n            connection.on(type, (msg: any) => {\r\n                if (msg.domain !== domain) {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    callback(msg);\r\n                } catch (e) {\r\n                    logger.error(`Callback  failed: ${e} \\n ${e.stack} \\n msg was: ${JSON.stringify(msg)}`, e);\r\n                }\r\n            });\r\n        },\r\n        loggedIn: (callback: () => void) => connection.loggedIn(callback),\r\n        connected: (callback: (server: string) => void) => connection.connected(callback),\r\n        disconnected: (callback: () => void) => connection.disconnected(callback),\r\n        get peerId() {\r\n            return connection.peerId;\r\n        },\r\n        get domain() {\r\n            return domain;\r\n        },\r\n    };\r\n}\r\n","import domainSession from \"./gw3Domain\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport { GW3Protocol, Identity, ConnectionSettings } from \"../types\";\r\nimport Connection from \"../connection\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport { WelcomeMessage, CreateTokenReq, CreateTokenRes } from \"./messages\";\r\nexport default class GW3ProtocolImpl implements GW3Protocol {\r\n    public protocolVersion: number = 3;\r\n\r\n    private datePrefix = \"#T42_DATE#\";\r\n    private datePrefixLen = this.datePrefix.length;\r\n    private dateMinLen = this.datePrefixLen + 1; // prefix + at least one char (1970/01/01 = 0)\r\n    private datePrefixFirstChar = this.datePrefix[0];\r\n    private registry: CallbackRegistry = CallbackRegistryFactory();\r\n\r\n    private globalDomain: Glue42Core.Connection.GW3DomainSession | undefined;\r\n\r\n    /* Flag indicating if the user is currently logged in */\r\n    private _isLoggedIn = false;\r\n\r\n    /*\r\n     * If true(default) the user wants to be connected.\r\n     * If the user explicitly calls logout this will become false.\r\n     * This is used to determine if it should retry trying to login.\r\n     */\r\n    private shouldTryLogin = true;\r\n\r\n    /* True only if this is the initial login attempt. */\r\n    private initialLogin = true;\r\n    private initialLoginAttempts = 3;\r\n    private pingTimer: any;\r\n    private sessions: Glue42Core.Connection.GW3DomainSession[] = [];\r\n    private loginConfig: Glue42Core.Auth | undefined;\r\n\r\n    constructor(private connection: Connection, private settings: ConnectionSettings, private logger: Logger) {\r\n        connection.disconnected(() => {\r\n            this.handleDisconnected();\r\n        });\r\n\r\n        this.ping();\r\n    }\r\n\r\n    public get isLoggedIn() {\r\n        return this._isLoggedIn;\r\n    }\r\n\r\n    public processStringMessage(message: string): { msg: object, msgType: string } {\r\n        const msg: { type: string } = JSON.parse(message, (key, value) => {\r\n\r\n            // check for date - we have custom protocol for dates\r\n            if (typeof value !== \"string\") {\r\n                return value;\r\n            }\r\n            if (value.length < this.dateMinLen) {\r\n                return value;\r\n            }\r\n            if (value[0] !== this.datePrefixFirstChar) {\r\n                return value;\r\n            }\r\n            if (value.substring(0, this.datePrefixLen) !== this.datePrefix) {\r\n                return value;\r\n            }\r\n            try {\r\n                const milliseconds = parseInt(value.substring(this.datePrefixLen, value.length), 10);\r\n                if (isNaN(milliseconds)) {\r\n                    return value;\r\n                }\r\n                return new Date(milliseconds);\r\n            } catch (ex) {\r\n                return value;\r\n            }\r\n        });\r\n\r\n        return {\r\n            msg,\r\n            msgType: msg.type,\r\n        };\r\n    }\r\n\r\n    public createStringMessage(message: object): string {\r\n        const oldToJson = Date.prototype.toJSON;\r\n        try {\r\n            const datePrefix = this.datePrefix;\r\n            Date.prototype.toJSON = function () {\r\n                return datePrefix + this.getTime();\r\n            };\r\n            const result = JSON.stringify(message);\r\n            return result;\r\n        } finally {\r\n            Date.prototype.toJSON = oldToJson;\r\n        }\r\n    }\r\n\r\n    public processObjectMessage(message: { type: string }): { msg: object, msgType: string } {\r\n        if (!message.type) {\r\n            throw new Error(\"Object should have type property\");\r\n        }\r\n        return {\r\n            msg: message,\r\n            msgType: message.type,\r\n        };\r\n    }\r\n\r\n    public createObjectMessage(message: object): object {\r\n        return message;\r\n    }\r\n\r\n    public async login(config: Glue42Core.Auth, reconnect?: boolean): Promise<Identity> {\r\n        this.logger.debug(\"logging in...\");\r\n        this.loginConfig = config;\r\n\r\n        if (!this.loginConfig) {\r\n            // in case of no auth send empty username and password\r\n            this.loginConfig = { username: \"\", password: \"\" };\r\n        }\r\n        this.shouldTryLogin = true;\r\n\r\n        const authentication: {\r\n            method?: string,\r\n            token?: string,\r\n            login?: string,\r\n            secret?: string,\r\n            provider?: string\r\n        } = {};\r\n\r\n        this.connection.gatewayToken = config.gatewayToken;\r\n        if (config.gatewayToken) {\r\n            // in case of re-connect try to refresh the GW token\r\n            if (reconnect) {\r\n                try {\r\n                    const token = await this.getNewGWToken();\r\n                    config.gatewayToken = token;\r\n                } catch (e) {\r\n                    this.logger.warn(`failed to get GW token when reconnecting ${e?.message || e}`);\r\n                }\r\n            }\r\n            authentication.method = \"gateway-token\";\r\n            authentication.token = config.gatewayToken;\r\n            this.connection.gatewayToken = config.gatewayToken;\r\n        } else if (config.flowName === \"sspi\") {\r\n            authentication.provider = \"win\";\r\n            authentication.method = \"access-token\";\r\n\r\n            if (config.flowCallback && config.sessionId) {\r\n                authentication.token =\r\n                    (await config.flowCallback(config.sessionId, null))\r\n                        .data\r\n                        .toString(\"base64\");\r\n            } else {\r\n                throw new Error(\"Invalid SSPI config\");\r\n            }\r\n        } else if (config.token) {\r\n            authentication.method = \"access-token\";\r\n            authentication.token = config.token;\r\n        } else if (config.username) {\r\n            authentication.method = \"secret\";\r\n            authentication.login = config.username;\r\n            authentication.secret = config.password;\r\n        } else {\r\n            throw new Error(\"invalid auth message\" + JSON.stringify(config));\r\n        }\r\n\r\n        const helloMsg: any = {\r\n            type: \"hello\",\r\n            identity: this.settings.identity,\r\n            authentication\r\n        };\r\n\r\n        if (config.sessionId) {\r\n            helloMsg.request_id = config.sessionId;\r\n        }\r\n\r\n        this.globalDomain = domainSession(\r\n            \"global\",\r\n            this.connection,\r\n            this.logger.subLogger(\"global-domain\"),\r\n            [\r\n                \"welcome\",\r\n                \"token\",\r\n                \"authentication-request\"\r\n            ]);\r\n\r\n        const sendOptions: Glue42Core.Connection.SendMessageOptions = { skipPeerId: true };\r\n        if (this.initialLogin) {\r\n            sendOptions.retryInterval = this.settings.reconnectInterval;\r\n            sendOptions.maxRetries = this.settings.reconnectAttempts;\r\n        }\r\n\r\n        try {\r\n            let welcomeMsg: WelcomeMessage;\r\n\r\n            while (true) {\r\n                const msg: any = await this.globalDomain.send(helloMsg, undefined, sendOptions);\r\n                if (msg.type === \"authentication-request\") {\r\n                    // respond to auth challenge\r\n                    const token = Buffer.from(msg.authentication.token, \"base64\");\r\n                    if (config.flowCallback && config.sessionId) {\r\n                        helloMsg.authentication.token =\r\n                            (await config.flowCallback(config.sessionId, token))\r\n                                .data\r\n                                .toString(\"base64\");\r\n                    }\r\n                    helloMsg.request_id = config.sessionId;\r\n                    continue;\r\n                } else if (msg.type === \"welcome\") {\r\n                    // we're in\r\n                    welcomeMsg = msg as WelcomeMessage;\r\n                    break;\r\n                } else if (msg.type === \"error\") {\r\n                    throw new Error(\"Authentication failed: \" + msg.reason);\r\n                } else {\r\n                    throw new Error(\"Unexpected message type during authentication: \" + msg.type);\r\n                }\r\n            }\r\n            // we've logged in once - set this to false for the rest of the lifetime\r\n            this.initialLogin = false;\r\n            this.logger.debug(\"login successful with peerId \" + welcomeMsg.peer_id);\r\n\r\n            this.connection.peerId = welcomeMsg.peer_id;\r\n            this.connection.resolvedIdentity = welcomeMsg.resolved_identity;\r\n            this.connection.availableDomains = welcomeMsg.available_domains as any;\r\n            if (welcomeMsg.options) {\r\n                this.connection.token = welcomeMsg.options.access_token;\r\n                this.connection.info = welcomeMsg.options.info;\r\n            }\r\n            this.setLoggedIn(true);\r\n            return welcomeMsg.resolved_identity;\r\n        } catch (err) {\r\n            this.logger.error(\"error sending hello message - \" + (err.message || err.msg || err.reason || err), err);\r\n            throw err;\r\n        } finally {\r\n            if (config && config.flowCallback && config.sessionId) {\r\n                config.flowCallback(config.sessionId, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async logout(): Promise<void> {\r\n        this.logger.debug(\"logging out...\");\r\n        this.shouldTryLogin = false;\r\n\r\n        if (this.pingTimer) {\r\n            clearTimeout(this.pingTimer);\r\n        }\r\n\r\n        // go through all sessions and leave the corresponding domain\r\n        const promises = this.sessions.map((session) => {\r\n            session.leave();\r\n        });\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    public loggedIn(callback: (() => void)): () => void {\r\n        if (this._isLoggedIn) {\r\n            callback();\r\n        }\r\n        return this.registry.add(\"onLoggedIn\", callback);\r\n    }\r\n\r\n    public domain(domainName: string, domainLogger: Logger, successMessages?: string[], errorMessages?: string[]): Glue42Core.Connection.GW3DomainSession {\r\n        let session = this.sessions.filter((s) => s.domain === domainName)[0];\r\n        if (!session) {\r\n            session = domainSession(domainName, this.connection, domainLogger, successMessages, errorMessages);\r\n            this.sessions.push(session);\r\n        }\r\n        return session;\r\n    }\r\n\r\n    public handleDisconnected() {\r\n        this.setLoggedIn(false);\r\n        const tryToLogin = this.shouldTryLogin;\r\n        if (tryToLogin && this.initialLogin) {\r\n            if (this.initialLoginAttempts <= 0) {\r\n                return;\r\n            }\r\n            this.initialLoginAttempts--;\r\n        }\r\n\r\n        this.logger.debug(\"disconnected - will try new login?\" + this.shouldTryLogin);\r\n        if (this.shouldTryLogin) {\r\n            if (!this.loginConfig) {\r\n                throw new Error(\"no login info\");\r\n            }\r\n\r\n            this.connection.login(this.loginConfig, true)\r\n                .catch(() => {\r\n                    setTimeout(this.handleDisconnected.bind(this), this.settings.reconnectInterval || 1000);\r\n                });\r\n        }\r\n    }\r\n\r\n    public setLoggedIn(value: boolean) {\r\n        this._isLoggedIn = value;\r\n        if (this._isLoggedIn) {\r\n            this.registry.execute(\"onLoggedIn\");\r\n        }\r\n    }\r\n\r\n    public ping() {\r\n        // if we don't want to be connected return\r\n        if (!this.shouldTryLogin) {\r\n            return;\r\n        }\r\n\r\n        // if logged in ping\r\n        if (this._isLoggedIn) {\r\n            this.connection.send({ type: \"ping\" });\r\n        }\r\n\r\n        // schedule next after 30 sec\r\n        this.pingTimer = setTimeout(() => {\r\n            this.ping();\r\n        }, 30 * 1000);\r\n    }\r\n\r\n    public authToken(): Promise<string> {\r\n        const createTokenReq: CreateTokenReq = {\r\n            type: \"create-token\"\r\n        };\r\n\r\n        if (!this.globalDomain) {\r\n            return Promise.reject(new Error(\"no global domain session\"));\r\n        }\r\n\r\n        return this.globalDomain.send<CreateTokenRes>(createTokenReq)\r\n            .then((res: CreateTokenRes) => {\r\n                return res.token;\r\n            });\r\n    }\r\n\r\n    private getNewGWToken(): Promise<string | undefined> {\r\n        if (typeof window !== undefined) {\r\n            // pull up a new token from gd\r\n            const glue42gd = window.glue42gd;\r\n            if (glue42gd) {\r\n                return glue42gd.getGWToken();\r\n            }\r\n        }\r\n        return Promise.reject(new Error(\"not running in GD\"));\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\n\r\nexport class MessageReplayerImpl implements Glue42Core.Connection.MessageReplayer {\r\n    private specs: { [name: string]: Glue42Core.Connection.MessageReplaySpec };\r\n    private specsNames: string[] = [];\r\n    private messages: { [type: string]: object[] } = {};\r\n    private isDone: boolean | undefined;\r\n    private subs: { [type: string]: any } = {};\r\n    private subsRefCount: { [type: string]: number } = {};\r\n    private connection: Glue42Core.Connection.API | undefined;\r\n\r\n    constructor(specs: Glue42Core.Connection.MessageReplaySpec[]) {\r\n        this.specs = {};\r\n        for (const spec of specs) {\r\n            this.specs[spec.name] = spec;\r\n            this.specsNames.push(spec.name);\r\n        }\r\n    }\r\n\r\n    public init(connection: Glue42Core.Connection.API) {\r\n        this.connection = connection;\r\n        for (const name of this.specsNames) {\r\n            for (const type of this.specs[name].types) {\r\n                let refCount = this.subsRefCount[type];\r\n                if (!refCount) {\r\n                    refCount = 0;\r\n                }\r\n                refCount += 1;\r\n                this.subsRefCount[type] = refCount;\r\n                if (refCount > 1) {\r\n                    continue;\r\n                }\r\n\r\n                const sub = connection.on<object>(\r\n                    type,\r\n                    (msg) => this.processMessage(type, msg));\r\n\r\n                this.subs[type] = sub;\r\n            }\r\n        }\r\n    }\r\n\r\n    public processMessage(type: string, msg: object) {\r\n        if (this.isDone || !msg) {\r\n            return;\r\n        }\r\n\r\n        for (const name of this.specsNames) {\r\n            if (this.specs[name].types.indexOf(type) !== -1) {\r\n                const messages = this.messages[name] || [];\r\n                this.messages[name] = messages;\r\n                messages.push(msg);\r\n            }\r\n        }\r\n    }\r\n\r\n    public drain(name: string, callback?: (msg: object) => void) {\r\n        if (callback) {\r\n            (this.messages[name] || []).forEach(callback);\r\n        }\r\n\r\n        delete this.messages[name];\r\n\r\n        for (const type of this.specs[name].types) {\r\n            this.subsRefCount[type] -= 1;\r\n            if (this.subsRefCount[type] <= 0) {\r\n                this.connection?.off(this.subs[type]);\r\n                delete this.subs[type];\r\n                delete this.subsRefCount[type];\r\n            }\r\n        }\r\n\r\n        delete this.specs[name];\r\n\r\n        if (!this.specs.length) {\r\n            this.isDone = true;\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nexport const PromisePlus = <T>(executor: (resolve: (value?: T | PromiseLike<T> | undefined) => void, reject: (reason?: any) => void) => void, timeoutMilliseconds: number, timeoutMessage?: string): Promise<T> => {\r\n\r\n    return new Promise<T>((resolve, reject) => {\r\n        const timeout = setTimeout(() => {\r\n\r\n            const message = timeoutMessage || `Promise timeout hit: ${timeoutMilliseconds}`;\r\n\r\n            reject(message);\r\n        }, timeoutMilliseconds);\r\n\r\n        const providedPromise = new Promise<T>(executor);\r\n\r\n        providedPromise\r\n            .then((result) => {\r\n                clearTimeout(timeout);\r\n                resolve(result);\r\n            })\r\n            .catch((error) => {\r\n                clearTimeout(timeout);\r\n                reject(error);\r\n            });\r\n    });\r\n\r\n};\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Identity, Transport } from \"../types\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport {\r\n    default as CallbackRegistryFactory,\r\n    CallbackRegistry,\r\n    UnsubscribeFunction,\r\n} from \"callback-registry\";\r\nimport generate from \"shortid\";\r\nimport { PromisePlus } from \"../../utils/promise-plus\";\r\n\r\ntype MessageType = \"connectionAccepted\" | \"connectionRejected\" | \"connectionRequest\" | \"parentReady\" | \"parentPing\" | \"platformPing\" | \"platformUnload\" | \"platformReady\" | \"clientUnload\" | \"manualUnload\";\r\n\r\nexport default class WebPlatformTransport implements Transport {\r\n\r\n    private publicWindowId: string | undefined;\r\n    private parentReady = false;\r\n    private iAmConnected = false;\r\n    private rejected = false;\r\n    private parentPingResolve: ((value?: void | PromiseLike<void> | undefined) => void) | undefined;\r\n    private connectionResolve: ((value?: void | PromiseLike<void> | undefined) => void) | undefined;\r\n    private connectionReject: ((reason?: unknown) => void) | undefined;\r\n    private port: MessagePort | undefined;\r\n    private myClientId: string | undefined;\r\n    private children: Array<{ grandChildId: string; source: Window; connected: boolean; origin: string }> = [];\r\n\r\n    private readonly parent: Window | undefined;\r\n    private readonly parentType: \"opener\" | \"top\" | \"workspace\" | undefined;\r\n    private readonly parentPingTimeout = 3000;\r\n    private readonly connectionRequestTimeout = 5000;\r\n    private readonly defaultTargetString = \"*\";\r\n    private readonly registry: CallbackRegistry = CallbackRegistryFactory();\r\n    private readonly messages: { [key in MessageType]: { name: string; handle: (event: MessageEvent) => void } } = {\r\n        connectionAccepted: { name: \"connectionAccepted\", handle: this.handleConnectionAccepted.bind(this) },\r\n        connectionRejected: { name: \"connectionRejected\", handle: this.handleConnectionRejected.bind(this) },\r\n        connectionRequest: { name: \"connectionRequest\", handle: this.handleConnectionRequest.bind(this) },\r\n        parentReady: { name: \"parentReady\", handle: this.handleParentReady.bind(this) },\r\n        parentPing: { name: \"parentPing\", handle: this.handleParentPing.bind(this) },\r\n        platformPing: { name: \"platformPing\", handle: this.handlePlatformPing.bind(this) },\r\n        platformUnload: { name: \"platformUnload\", handle: this.handlePlatformUnload.bind(this) },\r\n        platformReady: { name: \"platformReady\", handle: this.handlePlatformReady.bind(this) },\r\n        clientUnload: { name: \"clientUnload\", handle: this.handleClientUnload.bind(this) },\r\n        manualUnload: { name: \"manualUnload\", handle: this.handleManualUnload.bind(this) }\r\n    };\r\n\r\n    constructor(private readonly settings: Glue42Core.WebPlatformConnection, private readonly logger: Logger, private readonly identity?: Identity) {\r\n        this.setUpMessageListener();\r\n        this.setUpUnload();\r\n\r\n        if (!this.settings.port) {\r\n            this.parent = window.opener || window.top;\r\n\r\n            this.parentType = window.opener ? \"opener\" :\r\n                window.name.indexOf(\"#wsp\") !== -1 ? \"workspace\" : \"top\";\r\n        }\r\n    }\r\n\r\n    public get transportWindowId(): string | undefined {\r\n        return this.publicWindowId;\r\n    }\r\n\r\n    public async sendObject(msg: object): Promise<void> {\r\n        if (!this.port) {\r\n            throw new Error(\"Cannot send message, because the port was not opened yet\");\r\n        }\r\n        this.port.postMessage(msg);\r\n    }\r\n\r\n    public get isObjectBasedTransport(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public onMessage(callback: (msg: string | object) => void): UnsubscribeFunction {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    public send(): Promise<void> {\r\n        return Promise.reject(\"not supported\");\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean, reason?: string) => void): UnsubscribeFunction {\r\n        return this.registry.add(\"onConnectedChanged\", callback);\r\n    }\r\n\r\n    public async open(): Promise<void> {\r\n\r\n        this.logger.debug(\"opening a connection to the web platform gateway.\");\r\n\r\n        await this.connect();\r\n\r\n        this.notifyStatusChanged(true);\r\n    }\r\n\r\n    public close(): Promise<void> {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public name(): string {\r\n        return \"web-platform\";\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private async connect(): Promise<void> {\r\n\r\n        if (this.parentReady) {\r\n            this.logger.debug(\"cancelling connection attempt, because this client's parent has already given a ready signal\");\r\n            return;\r\n        }\r\n\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"opening an internal web platform connection\");\r\n            this.port = this.settings.port;\r\n\r\n            this.publicWindowId = this.settings.windowId;\r\n\r\n            if (this.identity) {\r\n                this.identity.windowId = this.publicWindowId;\r\n            }\r\n\r\n            this.port.onmessage = (event): object[] => this.registry.execute(\"onMessage\", event.data);\r\n            this.logger.debug(\"internal web platform connection completed\");\r\n            return;\r\n        }\r\n\r\n        if (!this.parentType || !this.parent) {\r\n            throw new Error(\"Cannot initiate a connection, because there is no opener, no top and no port.\");\r\n        }\r\n\r\n        this.logger.debug(`opening a ${this.parentType === \"opener\" ? \"child\" : \"grandchild\"} client web platform connection`);\r\n\r\n        await this.waitParent(this.parent, this.parentType);\r\n        await this.initiateRemoteConnection(this.parent, this.parentType);\r\n        // I AM READY HERE\r\n        this.logger.debug(`the ${this.parentType === \"opener\" ? \"child\" : \"grandchild\"} client is connected`);\r\n    }\r\n\r\n    private initiateRemoteConnection(target: Window, parentType: \"opener\" | \"top\" | \"workspace\"): Promise<void> {\r\n\r\n        return PromisePlus<void>((resolve, reject) => {\r\n            this.connectionResolve = resolve;\r\n            this.connectionReject = reject;\r\n\r\n            this.myClientId = generate();\r\n\r\n            const bridgeInstanceId = this.parentType === \"workspace\" ? window.name.substring(0, window.name.indexOf(\"#wsp\")) : window.name;\r\n\r\n            const request = {\r\n                glue42core: {\r\n                    type: this.messages.connectionRequest.name,\r\n                    clientId: this.myClientId,\r\n                    clientType: parentType === \"top\" || parentType === \"workspace\" ? \"grandChild\" : \"child\",\r\n                    bridgeInstanceId\r\n                }\r\n            };\r\n\r\n            this.logger.debug(`sending connection request to ${parentType}`);\r\n\r\n            target.postMessage(request, this.defaultTargetString);\r\n        }, this.connectionRequestTimeout, \"The connection to the opener/top window timed out\");\r\n\r\n    }\r\n\r\n    private waitParent(target: Window, parentType: \"opener\" | \"top\" | \"workspace\"): Promise<void> {\r\n        return PromisePlus<void>((resolve) => {\r\n            this.parentPingResolve = resolve;\r\n\r\n            const message = {\r\n                glue42core: {\r\n                    type: parentType === \"opener\" ? this.messages.platformPing.name : this.messages.parentPing.name\r\n                }\r\n            };\r\n\r\n            this.logger.debug(`checking for ${parentType} window availability`);\r\n\r\n            target.postMessage(message, this.defaultTargetString);\r\n        }, this.parentPingTimeout, \"Cannot initiate glue, because this window was not opened or created by a glue client\");\r\n    }\r\n\r\n    private setUpMessageListener(): void {\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"skipping generic message listener, because this is an internal client\");\r\n            // do not set up listener, because this is running as an internal client for the platform\r\n            return;\r\n        }\r\n\r\n        window.addEventListener(\"message\", (event) => {\r\n            const data = event.data?.glue42core;\r\n\r\n            if (!data || this.rejected) {\r\n                return;\r\n            }\r\n\r\n            if (!this.checkMessageTypeValid(data.type)) {\r\n                this.logger.error(`cannot handle the incoming glue42 core message, because the type is invalid: ${data.type}`);\r\n                return;\r\n            }\r\n\r\n            const messageType = data.type as MessageType;\r\n\r\n            this.logger.debug(`received valid glue42core message of type: ${messageType}`);\r\n\r\n            this.messages[messageType].handle(event);\r\n        });\r\n    }\r\n\r\n    private setUpUnload(): void {\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"skipping unload event listener, because this is an internal client\");\r\n            // do not set up listener, because this is running as an internal client for the platform\r\n            return;\r\n        }\r\n\r\n        window.addEventListener(\"beforeunload\", () => {\r\n            const message = {\r\n                glue42core: {\r\n                    type: this.messages.clientUnload.name,\r\n                    data: {\r\n                        clientId: this.myClientId,\r\n                        ownWindowId: this.identity?.windowId\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (this.parent) {\r\n                this.parent.postMessage(message, this.defaultTargetString);\r\n            }\r\n\r\n            this.port?.postMessage(message);\r\n        });\r\n    }\r\n\r\n    private handleParentReady(): void {\r\n        this.logger.debug(\"handling the ready signal from the parent, by resoling the pending promise.\");\r\n        this.parentReady = true;\r\n\r\n        if (this.parentPingResolve) {\r\n            this.parentPingResolve();\r\n            delete this.parentPingResolve;\r\n            return;\r\n        }\r\n\r\n        this.logger.debug(\"silently handling the ready signal from the top parent, because there is no defined promise\");\r\n    }\r\n\r\n    private handlePlatformReady(): void {\r\n        this.logger.debug(\"the web platform gave the ready signal\");\r\n        this.parentReady = true;\r\n\r\n        if (this.parentPingResolve) {\r\n            this.parentPingResolve();\r\n            delete this.parentPingResolve;\r\n            return;\r\n        }\r\n\r\n        this.logger.debug(\"silently handling the ready signal from the top parent, because there is no defined promise\");\r\n    }\r\n\r\n    private handleConnectionAccepted(event: MessageEvent): void {\r\n        const data = event.data?.glue42core;\r\n\r\n        if (this.myClientId === data.clientId) {\r\n            return this.handleAcceptanceOfMyRequest(data);\r\n        }\r\n\r\n        return this.handleAcceptanceOfGrandChildRequest(data, event);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private handleAcceptanceOfMyRequest(data: any): void {\r\n        this.logger.debug(\"handling a connection accepted signal targeted at me.\");\r\n\r\n        if (!data.port) {\r\n            this.logger.error(\"cannot set up my connection, because I was not provided with a port\");\r\n            return;\r\n        }\r\n\r\n        this.publicWindowId = this.parentType === \"opener\" ? window.name :\r\n            this.parentType === \"top\" ? data.parentWindowId :\r\n                window.name.substring(0, window.name.indexOf(\"#wsp\"));\r\n\r\n        if (this.identity && this.parentType !== \"top\") {\r\n            this.identity.windowId = this.publicWindowId;\r\n        }\r\n\r\n        if (this.identity && data.appName) {\r\n            this.identity.application = data.appName;\r\n            this.identity.applicationName = data.appName;\r\n        }\r\n\r\n        this.port = data.port as MessagePort;\r\n        this.port.onmessage = (e): object[] => this.registry.execute(\"onMessage\", e.data);\r\n\r\n        if (this.connectionResolve) {\r\n            this.logger.debug(\"my connection is set up, calling the connection resolve.\");\r\n            this.connectionResolve();\r\n            delete this.connectionResolve;\r\n            return;\r\n        }\r\n\r\n        this.logger.error(\"unable to call the connection resolve, because no connection promise was found\");\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private handleAcceptanceOfGrandChildRequest(data: any, event: MessageEvent): void {\r\n        this.logger.debug(`handling a connection accepted signal targeted at a grandchild: ${data.clientId}`);\r\n\r\n        const child = this.children.find((c) => c.grandChildId === data.clientId);\r\n\r\n        if (!child) {\r\n            this.logger.error(`cannot handle connection accepted for grandchild: ${data.clientId}, because there is no grandchild with this id`);\r\n            return;\r\n        }\r\n\r\n        child.connected = true;\r\n\r\n        this.logger.debug(`the grandchild connection for ${data.clientId} is set up, forwarding the success message and the gateway port`);\r\n\r\n        data.parentWindowId = this.publicWindowId;\r\n\r\n        child.source.postMessage(event.data, child.origin, [data.port]);\r\n        return;\r\n    }\r\n\r\n    private handleConnectionRejected(): void {\r\n        this.logger.debug(\"handling a connection rejection. Most likely the reason is that this window was not created by a glue API call\");\r\n        if (this.connectionReject) {\r\n            this.connectionReject(\"The platform connection was rejected. Most likely because this window was not created by a glue API call\");\r\n            delete this.connectionReject;\r\n        }\r\n    }\r\n\r\n    private handleConnectionRequest(event: MessageEvent): void {\r\n        const source = event.source as Window;\r\n        const data = event.data.glue42core;\r\n\r\n        if (!data.clientType || data.clientType !== \"grandChild\") {\r\n            return this.rejectConnectionRequest(source, event.origin, \"rejecting a connection request, because the source was not opened by a glue API call\");\r\n        }\r\n\r\n        if (!data.clientId) {\r\n            return this.rejectConnectionRequest(source, event.origin, \"rejecting a connection request, because the source did not provide a valid id\");\r\n        }\r\n\r\n        if (this.parentType !== \"opener\" || !this.parent) {\r\n            return this.rejectConnectionRequest(source, event.origin, \"Cannot forward the connection request, because no direct connection to the platform was found\");\r\n        }\r\n\r\n        this.logger.debug(`handling a connection request for a grandchild: ${data.clientId}`);\r\n\r\n        this.children.push({ grandChildId: data.clientId, source, connected: false, origin: event.origin });\r\n\r\n        this.logger.debug(`grandchild: ${data.clientId} is prepared, forwarding connection request to the platform`);\r\n\r\n        this.parent.postMessage(event.data, this.defaultTargetString);\r\n    }\r\n\r\n    private handleParentPing(event: MessageEvent): void {\r\n\r\n        if (!this.parentReady) {\r\n            this.logger.debug(\"my parent is not ready, I am ignoring the parent ping\");\r\n            return;\r\n        }\r\n\r\n        if (!this.iAmConnected) {\r\n            this.logger.debug(\"i am not fully connected yet, I am ignoring the parent ping\");\r\n            return;\r\n        }\r\n\r\n        const message = {\r\n            glue42core: {\r\n                type: this.messages.parentReady.name\r\n            }\r\n        };\r\n\r\n        const source = event.source as Window;\r\n\r\n        this.logger.debug(\"responding to a parent ping with a ready message\");\r\n\r\n        source.postMessage(message, event.origin);\r\n    }\r\n\r\n    private handlePlatformUnload(event: MessageEvent): void {\r\n        this.logger.debug(\"detected a web platform unload\");\r\n\r\n        this.parentReady = false;\r\n\r\n        if (this.children.length) {\r\n            this.logger.debug(\"forwarding the platform unload to all known children and starting platform discovery polling\");\r\n            this.children.forEach((child) => child.source.postMessage(event.data, child.origin));\r\n        }\r\n\r\n        this.notifyStatusChanged(false, \"Gateway unloaded\");\r\n\r\n    }\r\n\r\n    private handleManualUnload(): void {\r\n        const message = {\r\n            glue42core: {\r\n                type: this.messages.clientUnload.name,\r\n                data: {\r\n                    clientId: this.myClientId,\r\n                    ownWindowId: this.identity?.windowId\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this.parent) {\r\n            this.parent.postMessage(message, this.defaultTargetString);\r\n        }\r\n\r\n        this.port?.postMessage(message);\r\n    }\r\n\r\n    private handleClientUnload(event: MessageEvent): void {\r\n        const data = event.data.glue42core;\r\n        const clientId = data?.data.clientId;\r\n\r\n        if (!clientId) {\r\n            this.logger.warn(\"cannot process grand child unload, because the provided id was not valid\");\r\n            return;\r\n        }\r\n\r\n        const foundChild = this.children.find((child) => child.grandChildId === clientId);\r\n\r\n        if (!foundChild) {\r\n            this.logger.warn(\"cannot process grand child unload, because this client is unaware of this grandchild\");\r\n            return;\r\n        }\r\n\r\n        this.logger.debug(`handling grandchild unload for id: ${clientId}`);\r\n\r\n        this.children = this.children.filter((child) => child.grandChildId !== clientId);\r\n    }\r\n\r\n    private handlePlatformPing(): void {\r\n        this.logger.error(\"cannot handle platform ping, because this is not a platform calls handling component\");\r\n    }\r\n\r\n    private notifyStatusChanged(status: boolean, reason?: string): void {\r\n        this.iAmConnected = status;\r\n        this.registry.execute(\"onConnectedChanged\", status, reason);\r\n    }\r\n\r\n    private checkMessageTypeValid(typeToValidate: string): boolean {\r\n        return typeof typeToValidate === \"string\" && !!this.messages[typeToValidate as MessageType];\r\n    }\r\n\r\n    private rejectConnectionRequest(source: Window, origin: string, reason: string): void {\r\n        this.rejected = true;\r\n        this.logger.error(reason);\r\n\r\n        const rejection = {\r\n            glue42core: {\r\n                type: this.messages.connectionRejected.name\r\n            }\r\n        };\r\n\r\n        source.postMessage(rejection, origin);\r\n    }\r\n}\r\n","import {\r\n    default as CallbackFactory,\r\n    CallbackRegistry,\r\n} from \"callback-registry\";\r\nimport {\r\n    GW3Protocol,\r\n    Transport,\r\n    ConnectionSettings,\r\n    Identity,\r\n} from \"./types\";\r\nimport { Logger } from \"../logger/logger\";\r\n\r\nimport { Glue42Core } from \"../../glue\";\r\nimport InProcTransport from \"./transports/inProc\";\r\nimport SharedWorkerTransport from \"./transports/worker\";\r\nimport WS from \"./transports/ws\";\r\nimport GW3ProtocolImpl from \"./protocols/gw3\";\r\nimport { MessageReplayerImpl } from \"./replayer\";\r\nimport timer from \"../utils/timer\";\r\nimport WebPlatformTransport from \"./transports/webPlatform\";\r\n\r\n/**\r\n * A template for gateway connections - this is extended from specific protocols and transports.\r\n */\r\nexport default class Connection implements Glue42Core.Connection.API {\r\n\r\n    public peerId!: string;\r\n    public token!: string;\r\n    public info!: object;\r\n    public resolvedIdentity!: any;\r\n    public availableDomains!: Glue42Core.Connection.GWDomainInfo[];\r\n    public gatewayToken: string | undefined;\r\n    public replayer?: MessageReplayerImpl;\r\n\r\n    protected protocol: GW3Protocol;\r\n\r\n    // The message handlers that have to be executed for each received message\r\n    protected messageHandlers: {\r\n        [key: string]: { [key: string]: (msg: any) => void };\r\n    } = {};\r\n    protected ids = 1;\r\n    protected registry: CallbackRegistry = CallbackFactory();\r\n    protected _connected = false;\r\n    private isTrace = false;\r\n    private transport: Transport;\r\n\r\n    public get protocolVersion() {\r\n        return this.protocol?.protocolVersion;\r\n    }\r\n\r\n    constructor(private settings: ConnectionSettings, private logger: Logger) {\r\n        settings = settings || {};\r\n        settings.reconnectAttempts = settings.reconnectAttempts || 10;\r\n        settings.reconnectInterval = settings.reconnectInterval || 1000;\r\n\r\n        if (settings.inproc) {\r\n            this.transport = new InProcTransport(settings.inproc, logger.subLogger(\"inMemory\"));\r\n        } else if (settings.sharedWorker) {\r\n            this.transport = new SharedWorkerTransport(settings.sharedWorker, logger.subLogger(\"shared-worker\"));\r\n        } else if (settings.webPlatform) {\r\n            this.transport = new WebPlatformTransport(settings.webPlatform, logger.subLogger(\"web-platform\"), settings.identity);\r\n        } else if (settings.ws !== undefined) {\r\n            this.transport = new WS(settings, logger.subLogger(\"ws\"));\r\n        } else {\r\n            throw new Error(\"No connection information specified\");\r\n        }\r\n\r\n        this.isTrace = logger.canPublish(\"trace\");\r\n        logger.debug(`starting with ${this.transport.name()} transport`);\r\n\r\n        this.protocol = new GW3ProtocolImpl(this, settings, logger.subLogger(\"protocol\"));\r\n        this.transport.onConnectedChanged(\r\n            this.handleConnectionChanged.bind(this)\r\n        );\r\n        this.transport.onMessage(this.handleTransportMessage.bind(this));\r\n\r\n        if (settings.replaySpecs && settings.replaySpecs.length) {\r\n            this.replayer = new MessageReplayerImpl(settings.replaySpecs);\r\n            this.replayer.init(this);\r\n        }\r\n    }\r\n\r\n    public send(message: object, options?: Glue42Core.Connection.SendMessageOptions): Promise<void> {\r\n        // create a message using the protocol\r\n        if (\r\n            this.transport.sendObject &&\r\n            this.transport.isObjectBasedTransport\r\n        ) {\r\n            const msg = this.protocol.createObjectMessage(message);\r\n            if (this.isTrace) {\r\n                this.logger.trace(`>> ${JSON.stringify(msg)}`);\r\n            }\r\n            return this.transport.sendObject(msg, options);\r\n        } else {\r\n            const strMessage = this.protocol.createStringMessage(message);\r\n            if (this.isTrace) {\r\n                this.logger.trace(`>> ${strMessage}`);\r\n            }\r\n            return this.transport.send(strMessage, options);\r\n        }\r\n    }\r\n\r\n    public on<T>(\r\n        type: string,\r\n        messageHandler: (msg: T) => void\r\n    ): any {\r\n        type = type.toLowerCase();\r\n        if (this.messageHandlers[type] === undefined) {\r\n            this.messageHandlers[type] = {};\r\n        }\r\n\r\n        const id = this.ids++;\r\n        this.messageHandlers[type][id] = messageHandler;\r\n\r\n        return {\r\n            type,\r\n            id,\r\n        };\r\n    }\r\n\r\n    // Remove a handler\r\n    public off(info: { type: string; id: number }) {\r\n        delete this.messageHandlers[info.type.toLowerCase()][info.id];\r\n    }\r\n\r\n    public get isConnected() {\r\n        return this.protocol.isLoggedIn;\r\n    }\r\n\r\n    public connected(callback: (server: string) => void): () => void {\r\n        return this.protocol.loggedIn(() => {\r\n            callback(this.settings.ws || this.settings.sharedWorker || \"\");\r\n        });\r\n    }\r\n\r\n    public disconnected(callback: () => void): () => void {\r\n        return this.registry.add(\"disconnected\", callback);\r\n    }\r\n\r\n    public async login(authRequest: Glue42Core.Auth, reconnect?: boolean): Promise<Identity> {\r\n        // open the protocol in case it was closed by explicity logout\r\n        await this.transport.open();\r\n        timer(\"connection\").mark(\"transport-opened\");\r\n        const identity = this.protocol.login(authRequest, reconnect);\r\n        timer(\"connection\").mark(\"protocol-logged-in\");\r\n        return identity;\r\n    }\r\n\r\n    public async logout() {\r\n        await this.protocol.logout();\r\n        await this.transport.close();\r\n    }\r\n\r\n    public loggedIn(callback: () => void) {\r\n        return this.protocol.loggedIn(callback);\r\n    }\r\n\r\n    public domain(\r\n        domain: string,\r\n        successMessages?: string[],\r\n        errorMessages?: string[]\r\n    ): Glue42Core.Connection.GW3DomainSession {\r\n        return this.protocol.domain(\r\n            domain,\r\n            this.logger.subLogger(`domain=${domain}`),\r\n            successMessages,\r\n            errorMessages\r\n        );\r\n    }\r\n\r\n    public authToken(): Promise<string> {\r\n        return this.protocol.authToken();\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        return this.transport.reconnect();\r\n    }\r\n\r\n    private distributeMessage(message: object, type: string) {\r\n        // Retrieve handlers for the message type\r\n        const handlers = this.messageHandlers[type.toLowerCase()];\r\n        if (handlers !== undefined) {\r\n            // Execute them\r\n            Object.keys(handlers).forEach((handlerId) => {\r\n                const handler = handlers[handlerId];\r\n                if (handler !== undefined) {\r\n                    try {\r\n                        handler(message);\r\n                    } catch (error) {\r\n                        try {\r\n                            // logger might not be there yet\r\n                            this.logger.error(`Message handler failed with ${error.stack}`, error);\r\n                        } catch (loggerError) {\r\n                            // tslint:disable-next-line:no-console\r\n                            console.log(\"Message handler failed\", error);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private handleConnectionChanged(connected: boolean) {\r\n        if (this._connected === connected) {\r\n            return;\r\n        }\r\n        this._connected = connected;\r\n\r\n        if (connected) {\r\n            this.registry.execute(\"connected\");\r\n        } else {\r\n            this.registry.execute(\"disconnected\");\r\n        }\r\n    }\r\n\r\n    private handleTransportMessage(msg: string | object) {\r\n        let msgObj;\r\n        if (typeof msg === \"string\") {\r\n            msgObj = this.protocol.processStringMessage(msg);\r\n        } else {\r\n            msgObj = this.protocol.processObjectMessage(msg);\r\n        }\r\n\r\n        if (this.isTrace) {\r\n            this.logger.trace(`<< ${JSON.stringify(msgObj)}`);\r\n        }\r\n\r\n        this.distributeMessage(msgObj.msg, msgObj.msgType);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\n\r\nconst order: Glue42Core.LogLevel[] = [\"trace\", \"debug\", \"info\", \"warn\", \"error\", \"off\"];\r\n\r\nexport class Logger implements Glue42Core.Logger.API {\r\n    public static Interop: Glue42Core.Interop.API;\r\n    public static InteropMethodName = \"T42.AppLogger.Log\";\r\n\r\n    public static Instance: string;\r\n    public readonly path: string;\r\n\r\n    private subLoggers: Logger[] = [];\r\n    private _consoleLevel: Glue42Core.LogLevel | undefined;\r\n    private _publishLevel: Glue42Core.LogLevel | undefined;\r\n    private loggerFullName: string;\r\n    private includeTimeAndLevel: boolean;\r\n    private logFn: Glue42Core.CustomLogger = console;\r\n    private customLogFn: boolean = false;\r\n\r\n    constructor(public readonly name: string, private parent?: Logger, logFn?: Glue42Core.CustomLogger) {\r\n        this.name = name;\r\n\r\n        if (parent) {\r\n            this.path = `${parent.path}.${name}`;\r\n        } else {\r\n            this.path = name;\r\n        }\r\n\r\n        this.loggerFullName = `[${this.path}]`;\r\n        this.includeTimeAndLevel = !logFn;\r\n        if (logFn) {\r\n            this.logFn = logFn;\r\n            this.customLogFn = true;\r\n        }\r\n    }\r\n\r\n    public subLogger(name: string): Logger {\r\n        // Check if the sub-logger is already created\r\n        const existingSub = this.subLoggers.filter((subLogger) => {\r\n            return subLogger.name === name;\r\n        })[0];\r\n\r\n        if (existingSub !== undefined) {\r\n            return existingSub;\r\n        }\r\n\r\n        // Check if the name isn't the same as one of the parent properties\r\n        Object.keys(this).forEach((key) => {\r\n            if (key === name) {\r\n                throw new Error(\"This sub logger name is not allowed.\");\r\n            }\r\n        });\r\n\r\n        const sub = new Logger(name, this, this.customLogFn ? this.logFn : undefined);\r\n\r\n        // add sub-logger to sub-loggers array\r\n        this.subLoggers.push(sub);\r\n\r\n        return sub;\r\n    }\r\n\r\n    public publishLevel(level?: Glue42Core.LogLevel): Glue42Core.LogLevel | undefined {\r\n        if (level) {\r\n            this._publishLevel = level;\r\n        }\r\n\r\n        return this._publishLevel || this.parent?.publishLevel();\r\n    }\r\n\r\n    public consoleLevel(level?: Glue42Core.LogLevel): Glue42Core.LogLevel | undefined {\r\n        if (level) {\r\n            this._consoleLevel = level;\r\n        }\r\n\r\n        return this._consoleLevel || this.parent?.consoleLevel();\r\n    }\r\n\r\n    public log(message: string, level?: Glue42Core.LogLevel, error?: Error) {\r\n        this.publishMessage(level || \"info\", message, error);\r\n    }\r\n\r\n    public trace(message: string) {\r\n        this.log(message, \"trace\");\r\n    }\r\n\r\n    public debug(message: string) {\r\n        this.log(message, \"debug\");\r\n    }\r\n\r\n    public info(message: string) {\r\n        this.log(message, \"info\");\r\n    }\r\n\r\n    public warn(message: string) {\r\n        this.log(message, \"warn\");\r\n    }\r\n\r\n    public error(message: string, err?: Error) {\r\n        this.log(message, \"error\");\r\n    }\r\n\r\n    public canPublish(level: Glue42Core.LogLevel, compareWith?: Glue42Core.LogLevel) {\r\n        const levelIdx = order.indexOf(level);\r\n        const restrictionIdx = order.indexOf(compareWith || this.consoleLevel() || \"trace\");\r\n\r\n        return levelIdx >= restrictionIdx;\r\n    }\r\n\r\n    private publishMessage(level: Glue42Core.LogLevel, message: string, error?: Error) {\r\n        // Retrieve logger name and levels\r\n        const loggerName = this.loggerFullName;\r\n\r\n        // Add stack trace if the message is an error\r\n        if (level === \"error\" && !error) {\r\n            const e = new Error();\r\n            if (e.stack) {\r\n                message =\r\n                    message +\r\n                    \"\\n\" +\r\n                    e.stack\r\n                        .split(\"\\n\")\r\n                        .slice(3)\r\n                        .join(\"\\n\");\r\n            }\r\n        }\r\n\r\n        if (this.canPublish(level, this.publishLevel())) {\r\n            const interop = Logger.Interop;\r\n            if (interop) {\r\n                try {\r\n                    if (interop.methods({ name: Logger.InteropMethodName }).length > 0) {\r\n                        interop.invoke(Logger.InteropMethodName, {\r\n                            msg: `${message}`,\r\n                            logger: loggerName,\r\n                            level\r\n                        });\r\n                    }\r\n                } catch {\r\n                    // interop might not be ready yet\r\n                }\r\n            }\r\n        }\r\n\r\n        // Publish in console\r\n        if (this.canPublish(level)) {\r\n            let prefix = \"\";\r\n            if (this.includeTimeAndLevel) {\r\n                const date = new Date();\r\n                const time = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}:${date.getMilliseconds()}`;\r\n                prefix = `[${time}] [${level}] `;\r\n            }\r\n            const toPrint = `${prefix}${loggerName}: ${message}`;\r\n            switch (level) {\r\n                case \"trace\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.debug(toPrint);\r\n                    break;\r\n                case \"debug\":\r\n                    // tslint:disable-next-line:no-console\r\n                    if (this.logFn.debug) {\r\n                        // tslint:disable-next-line:no-console\r\n                        this.logFn.debug(toPrint);\r\n                    } else {\r\n                        // tslint:disable-next-line:no-console\r\n                        this.logFn.log(toPrint);\r\n                    }\r\n                    break;\r\n                case \"info\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.info(toPrint);\r\n                    break;\r\n                case \"warn\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.warn(toPrint);\r\n                    break;\r\n                case \"error\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.error(toPrint, error);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","export const GW_MESSAGE_CREATE_CONTEXT = \"create-context\";\r\nexport const GW_MESSAGE_ACTIVITY_CREATED = \"created\";\r\nexport const GW_MESSAGE_ACTIVITY_DESTROYED = \"destroyed\";\r\nexport const GW_MESSAGE_CONTEXT_CREATED = \"context-created\";\r\nexport const GW_MESSAGE_CONTEXT_ADDED = \"context-added\";\r\n\r\nexport const GW_MESSAGE_SUBSCRIBE_CONTEXT = \"subscribe-context\";\r\nexport const GW_MESSAGE_SUBSCRIBED_CONTEXT = \"subscribed-context\";\r\nexport const GW_MESSAGE_UNSUBSCRIBE_CONTEXT = \"unsubscribe-context\";\r\n\r\nexport const GW_MESSAGE_DESTROY_CONTEXT = \"destroy-context\";\r\nexport const GW_MESSAGE_CONTEXT_DESTROYED = \"context-destroyed\";\r\n\r\nexport const GW_MESSAGE_UPDATE_CONTEXT = \"update-context\";\r\nexport const GW_MESSAGE_CONTEXT_UPDATED = \"context-updated\";\r\nexport const GW_MESSAGE_JOINED_ACTIVITY = \"joined\";\r\n","import { Glue42Core} from \"../../glue\";\r\n\r\nimport * as msg from \"./bridges/gw3/messages\";\r\n\r\nexport const ContextMessageReplaySpec: Glue42Core.Connection.MessageReplaySpec = {\r\n    get name(): string {\r\n        return \"context\";\r\n    },\r\n\r\n    get types(): string[] {\r\n        return [\r\n            msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY\r\n        ];\r\n    }\r\n};\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { ContextSubscriptionKey } from \"../types\";\r\n\r\nexport class GW3ContextData {\r\n    // invariants:\r\n    // - at least one of { isAnnounced, hasCallbacks() } must be truthy\r\n    //     (so no state (0) instances are kept)\r\n    // - name is defined\r\n    // - isAnnounced cannot go from true to false\r\n    // - !isAnnounced => activityId === undefined\r\n    // - !isAnnounced => contextId === undefined\r\n    // - isAnnounced => contextId !== undefined\r\n    // - !isAnnounced => context == {}\r\n    // - !isAnnounced => !joinedActivity\r\n    // - activityId === undefined => !joinedActivity\r\n    // - joinedActivity => activityId !== undefined !\r\n    // - activityId != undefined => name === activityId\r\n    // - !isAnnounced => sentExplicitSubscription === false\r\n    // - !hasCallbacks => sentExplicitSubscription === false\r\n    // - context is defaulted to {}, not null or undefined\r\n\r\n    // the name of this context; it's what our clients use to (un)subscribe\r\n    // to it; for an activity context it's the same as activityId\r\n    public name: string;\r\n\r\n    // the id of the context as assigned by the GW; only known after it has\r\n    // been announced\r\n    public contextId: string | undefined;\r\n\r\n    // since GW3 only sends a snapshot on subscription/activity creation,\r\n    // we need to keep track of the context state ourselves, for the sake\r\n    // of any additional subsequent subscribers (i.e. so we can give them\r\n    // the context snapshot so far)\r\n    public context: {};\r\n\r\n    // has the context been announced by the GW?\r\n    public isAnnounced: boolean;\r\n\r\n    public joinedActivity: boolean | undefined;\r\n\r\n    // callbacks to invoke on context update\r\n    public updateCallbacks: { [index: number]: (data: any, delta: any, removed: string[], key: ContextSubscriptionKey, extraData?: any) => void } = {};\r\n\r\n    // iff activity context, the id of the activity to which it belongs\r\n    public activityId: string | undefined;\r\n\r\n    public sentExplicitSubscription: boolean | undefined;\r\n\r\n    constructor(contextId: string | undefined, name: string, isAnnounced: boolean, activityId?: string) {\r\n        this.contextId = contextId;\r\n        this.name = name;\r\n        this.isAnnounced = isAnnounced;\r\n        this.activityId = activityId;\r\n        this.context = {};\r\n    }\r\n\r\n    public hasCallbacks() {\r\n        return Object.keys(this.updateCallbacks).length > 0;\r\n    }\r\n\r\n    // for reference only\r\n    // should never return 0\r\n    public getState(): number {\r\n        if (this.isAnnounced && this.hasCallbacks()) {\r\n            return 3;\r\n        }\r\n\r\n        if (this.isAnnounced) {\r\n            return 2;\r\n        }\r\n\r\n        if (this.hasCallbacks()) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { ContextDelta } from \"./bridges/types\";\r\nimport { Logger } from \"../logger/logger\";\r\n\r\nexport function applyContextDelta(\r\n    context: any,\r\n    delta: ContextDelta,\r\n    logger: Logger) {\r\n\r\n    try {\r\n        if (logger?.canPublish(\"trace\")) {\r\n            logger?.trace(`applying context delta ${JSON.stringify(delta)} on context ${JSON.stringify(context)}`);\r\n        }\r\n        if (!delta) {\r\n            return context;\r\n        }\r\n\r\n        if (delta.reset) {\r\n            context = { ...delta.reset };\r\n            return context;\r\n        }\r\n\r\n        context = deepClone(context, undefined);\r\n\r\n        if (delta.commands) {\r\n            for (const command of delta.commands) {\r\n                if (command.type === \"remove\") {\r\n                    deletePath(context, command.path);\r\n                } else if (command.type === \"set\") {\r\n                    setValueToPath(context, command.value, command.path);\r\n                }\r\n            }\r\n            // if there is a commands property ignore the rest (v1 added/updated/removed)\r\n            return context;\r\n        }\r\n\r\n        const added = delta.added;\r\n        const updated = delta.updated;\r\n        const removed = delta.removed;\r\n\r\n        if (added) {\r\n            Object.keys(added).forEach((key) => {\r\n                context[key] = added[key];\r\n            });\r\n        }\r\n\r\n        if (updated) {\r\n            Object.keys(updated).forEach((key) => {\r\n                mergeObjectsProperties(key, context, updated);\r\n            });\r\n        }\r\n\r\n        if (removed) {\r\n            removed.forEach((key) => {\r\n                delete context[key];\r\n            });\r\n        }\r\n\r\n        return context;\r\n    } catch (e) {\r\n        logger?.error(`error applying context delta ${JSON.stringify(delta)} on context ${JSON.stringify(context)}`, e);\r\n        return context;\r\n    }\r\n}\r\n\r\n// https://stackoverflow.com/a/40294058/1527706\r\nexport function deepClone(obj: any, hash?: WeakMap<any, any>): any {\r\n    hash = hash || new WeakMap<any, any>();\r\n    if (Object(obj) !== obj) { return obj; } // primitives\r\n    if (obj instanceof Set) { return new Set(obj); } // See note about this!\r\n    if (hash.has(obj)) { return hash.get(obj); } // cyclic reference\r\n    const result = obj instanceof Date ? new Date(obj)\r\n        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)\r\n            : obj.constructor ? new obj.constructor()\r\n                : Object.create(null);\r\n    hash.set(obj, result);\r\n    if (obj instanceof Map) {\r\n        Array.from(obj, ([key, val]) => result.set(key, deepClone(val, hash)));\r\n    }\r\n    return Object.assign(result, ...Object.keys(obj).map(\r\n        (key) => ({ [key]: deepClone(obj[key], hash) })));\r\n}\r\n\r\n/*\r\nmergeObjectsProperties(\r\n    \"a\",\r\n    { a: { b: { c: 1, e: 1 }, x: { y: 1 }, foo: { moo: \"bar\" } } },\r\n    { a: { b: { d: 1, e: 2 }, foo: \"bar\" } });\r\n\r\n    => { a: { b: { c: 1, e: 2 } }, x: { y: 1 }, foo: \"bar\" }\r\n*/\r\n\r\nconst mergeObjectsProperties = (key: string, what: any, withWhat: any) => {\r\n\r\n    const right = withWhat[key];\r\n\r\n    if (right === undefined) {\r\n        return what;\r\n    }\r\n\r\n    const left = what[key];\r\n\r\n    if (!left || !right) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n\r\n    if (typeof left === \"string\" ||\r\n        typeof left === \"number\" ||\r\n        typeof left === \"boolean\" ||\r\n        typeof right === \"string\" ||\r\n        typeof right === \"number\" ||\r\n        typeof right === \"boolean\" ||\r\n        Array.isArray(left) ||\r\n        Array.isArray(right)) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n\r\n    what[key] = Object.assign({}, left, right);\r\n\r\n    return what;\r\n};\r\n\r\n// https://stackoverflow.com/a/6713782/1527706\r\nexport function deepEqual(x: any, y: any) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    // if both x and y are null or undefined and exactly the same\r\n\r\n    if (!(x instanceof Object) || !(y instanceof Object)) {\r\n        return false;\r\n    }\r\n    // if they are not strictly equal, they both need to be Objects\r\n\r\n    if (x.constructor !== y.constructor) {\r\n        return false;\r\n    }\r\n    // they must have the exact same prototype chain, the closest we can do is\r\n    // test there constructor.\r\n\r\n    for (const p in x) {\r\n        if (!x.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        // other properties were tested using x.constructor === y.constructor\r\n\r\n        if (!y.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        // allows to compare x[ p ] and y[ p ] when set to undefined\r\n\r\n        if (x[p] === y[p]) {\r\n            continue;\r\n        }\r\n        // if they have the same strict value or identity then they are equal\r\n\r\n        if (typeof (x[p]) !== \"object\") {\r\n            return false;\r\n        }\r\n        // Numbers, Strings, Functions, Booleans must be strictly equal\r\n\r\n        if (!deepEqual(x[p], y[p])) {\r\n            return false;\r\n        }\r\n        // Objects and Arrays must be tested recursively\r\n    }\r\n\r\n    for (const p in y) {\r\n        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        // allows x[ p ] to be set to undefined\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function setValueToPath(obj: any, value: any, path: string) {\r\n    const pathArr = path.split(\".\");\r\n    let i;\r\n    for (i = 0; i < pathArr.length - 1; i++) {\r\n        if (!obj[pathArr[i]]) {\r\n            // path does not exist, create empty object\r\n            obj[pathArr[i]] = {};\r\n        }\r\n        if (typeof obj[pathArr[i]] !== \"object\") {\r\n            // handle the case where we have {a: 1} and we call set({a: {aa: 2}})\r\n            obj[pathArr[i]] = {};\r\n        }\r\n        obj = obj[pathArr[i]];\r\n    }\r\n    obj[pathArr[i]] = value;\r\n}\r\n\r\nexport function isSubset(superObj: any, subObj: any): boolean {\r\n    return Object.keys(subObj).every((ele) => {\r\n        if (typeof subObj[ele] === \"object\") {\r\n            return isSubset(superObj?.[ele] || {}, subObj[ele] || {});\r\n        }\r\n        return subObj[ele] === superObj?.[ele];\r\n    });\r\n}\r\n\r\nfunction deletePath(obj: any, path: string) {\r\n    const pathArr = path.split(\".\");\r\n    let i;\r\n    for (i = 0; i < pathArr.length - 1; i++) {\r\n        if (!obj[pathArr[i]]) {\r\n            // path does not exist, we're not removing anything\r\n            return;\r\n        }\r\n        obj = obj[pathArr[i]];\r\n    }\r\n    delete obj[pathArr[i]];\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { ContextBridge } from \"../../contextBridge\";\r\nimport { GW3ContextData as ContextData } from \"./contextData\";\r\nimport { applyContextDelta, deepEqual, deepClone, setValueToPath } from \"../../helpers\";\r\nimport * as msg from \"./messages\";\r\nimport { ContextMessage } from \"./contextMessage\";\r\nimport { ContextMessageReplaySpec } from \"../../contextMessageReplaySpec\";\r\nimport { Logger } from \"../../../logger/logger\";\r\nimport Connection from \"../../../connection/connection\";\r\nimport { ContextsConfig } from \"../../contextsModule\";\r\nimport { ContextName, ContextSubscriptionKey, ContextDelta, ContextDeltaCommand } from \"../types\";\r\n\r\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n// GW3Bridge implementation notes\r\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n//\r\n// ===========================\r\n// Terminology used\r\n// ===========================\r\n//\r\n// - gw-subscribe (verb):\r\n//      send SUBSCRIBE CONTEXT to GW se we see CONTEXT UPDATED messages,\r\n//      or\r\n//      get implicitly subscribed as consequence of joining activity\r\n//      sending the SUBSCRIBE CONTEXT message is done internally by this\r\n//      class whenever a ContextData item in _contextNameToData reaches\r\n//      state (3) (see 'States of a context' in gw3ContextData.ts)\r\n// - bridge-subscribe (verb):\r\n//      call gw3Bridge.subscribe method; we need to make sure we've\r\n//      gw-subscribed if/as soon as the target context is announced\r\n//      this is what consumers of this class do\r\n// - bridge-subscription (noun):\r\n//      the result of bridge-subscribe, and the state of having a handler\r\n//      subscribed to a context\r\n// - active subscription: bridge-subscription which will cause the handler\r\n//      to observe context changes until someone calls unsubscribe() here\r\n//      or the subscription becomes 'inactive'\r\n// - inactive subscription: bridge-subscription which will NOT cause the\r\n//      handler to observe context changes; this happens to\r\n//      bridge-subscriptions on activity contexts if we leave the activity.\r\n//      There is NO way to check if a subscription is active or not and it's\r\n//      not reflected in the contextData state.\r\n//\r\n// ===========================\r\n// General information\r\n// ===========================\r\n//\r\n// This class exposes the GW context subscription and updating features\r\n// using the subscribe/unsubscribe/update/createContext methods.\r\n//\r\n// The main logic is related to tracking the states of contexts (shared or\r\n// activity), represented by ContextData entries in _contextNameToData, and\r\n// reacting to gateway messages accordingly.\r\n//\r\n// ===========================\r\n// States of an ContextData object\r\n// ===========================\r\n//\r\n// (0) nothing (not defined, or deleted) - such entries are NOT kept in collections\r\n// (1) unknown but bridge-subscribed to\r\n// (2) announced but not bridge-subscribed to\r\n// (3) both announced and bridge-subscribed to (so also gw-subscribed)\r\n//\r\n//       sub/unsub   GW ann\r\n//      +-------->(1)-----+\r\n//      |                 |\r\n//      |                 |\r\n//      V       destroy   v\r\n// *-->(0)<--------------(3)\r\n//      |^---------+      ^\r\n//      |  destroy |      |\r\n//      |          |      |\r\n//      +-------->(2)<----+\r\n//        GW ann    subscribe/unsub\r\n//\r\n// You can look for the states and transitions in the code below, e.g.\r\n// (0) -> (1)\r\n//\r\n// Note: if it's not our activity context, we need to gw-(un)subscribe to the\r\n// GW update messages on certain transitions:\r\n// - on changes from { (1), (2) } -> (3) we send a subscribe message\r\n// - on changes from (3) -> (2) we send an unsubscribe message\r\n// - on destruction, we drop all the information about the context; let\r\n// anyone subscribe to it and create a new contextData in state (1), we don't\r\n// care - these subscriptions are inactive from the get go, since the context\r\n// can't be created again.\r\n//\r\n// The contextData also contains the current snapshot of the context if it's\r\n// currently gw-subscribed to (so states (2\"') and (3) below).\r\n//\r\n// Note: We're mostly going to the trouble of keeping unannounced contexts\r\n// (state (1)) in order to allow other GW message subscribers to see a new\r\n// context being created and subscribe to it before the message has reached\r\n// our handler. Also, only sending a CONTEXT SUBSCRIBE on state (3) instead\r\n// of on GW announce means no unnecessary updates are being distributed to\r\n// every instance of this library.\r\n//\r\n// Also, in the HC subscribing to an unknown context is OK as well so we're\r\n// keeping this behavior.\r\n//\r\n// Note: above is an abridged version of the state machine; states (2) and (3)\r\n// have three substates depending on whether the context is a global context,\r\n// our own activity context, or a foreign activity's context. Subscription\r\n// messages are only sent on { (1), (2'), (2\") } -> { (3'), (3\") }, with the\r\n// unsubscribe message sent on { (3'), (3\"), (3\"') } -> { (1), (2'), (2\") }\r\n// if a  subscribe was sent previously (so we'll send a final unsubscribe if\r\n// we subscribe to a foreign activity's context, then join the activity, then\r\n// unsubscribe - this is to avoid still potentially receiving unwanted updates\r\n// if we leave the activity).\r\n//\r\n// Full state diagram (not showing 'destroy' transitions):\r\n//\r\n//        join activity\r\n//      +------------------>(3\"')<------+\r\n//      |                    ^          |\r\n//      |                    | join     |\r\n//      |                    | activity |\r\n//      | activity created   |          |\r\n//      +------------------>(3\")<----+  |\r\n//      |                            |  |\r\n//      | global ctx ann             |  |\r\n//      +------------------>(3')<-+  |  |\r\n//      |                         |  |  |\r\n//      |                         |  |  |\r\n//     (1)                        |  |  |\r\n//      ^                         |  |  |\r\n//      | bridge-(un)subscribe   bridge-(un)subscribe\r\n//      |                         |  |  |\r\n//      V                         |  |  |\r\n// *-->(0)                        |  |  |\r\n//      |                         |  |  |\r\n//      | global ctx ann          |  |  |\r\n//      +------------------>(2')<-+  |  |\r\n//      |                            |  |\r\n//      | activity created           |  |\r\n//      +------------------>(2\")<----+  |\r\n//      |                    |          |\r\n//      |                    | join     |\r\n//      |                    | activity |\r\n//      | join activity      V          |\r\n//      +------------------>(2\"')<------+\r\n//\r\n// ===========================\r\n// Supported use cases\r\n// ===========================\r\n//\r\n// - bridge-(un)subscribe to shared context by name\r\n// - bridge-(un)subscribe to activity context for activity we ARE a member of\r\n//      - the context name is the activity id\r\n//      - here the subscriptions become inactive if we leave the activity\r\n//      - HOWEVER these subscriptions will become inactive if we leave the\r\n//      activity, and any further subscriptions to the activity's context\r\n//      will be inactive.\r\n//          The protocol provides no way for us to know other than through\r\n//      the LEAVE ACTIVITY success message which is sent by our peer and we\r\n//      can't observe it here, so we have no way to know to send an explicit\r\n//      subscription in order to reactivate the bridge-subscription.\r\n//          We could deal with this by extending the GW connection to allow\r\n//      us to inspect outgoing messages and react to the LEAVE ACTIVITY, but\r\n//      keeping a few stale objects around isn't worth the code complexity.\r\n//          This transition would be represented by (2\"') -> (2\") and\r\n//      (3\"') -> (3\") in the state diagram, where (3\"') -> (3\") would prompt\r\n//      a subscribe message.\r\n// - bridge-(un)subscribe to context of activity we're NOT in\r\n//      - the context name is the activity id\r\n//      - the subscription will stay active even if we join the activity later\r\n//      - again, these subscriptions will become inactive if we leave the\r\n//      activity\r\n//\r\n// Also note that unsubscribing from destroyed contexts is not required,\r\n// as the data is cleared up automatically (but it doesn't hurt).\r\n// Unsubscriptions are guaranteed to be safe and idempotent.\r\nexport class GW3Bridge implements ContextBridge {\r\n    private _logger: Logger;\r\n    private _connection: Connection;\r\n    // used for sending messages as it provides a promise-based interface\r\n    private _gw3Session: Glue42Core.Connection.GW3DomainSession;\r\n\r\n    // contexts in state { (1), (2), (3) }\r\n    private _contextNameToData: { [contextName: string]: ContextData } = {};\r\n\r\n    // for disposing purposes only\r\n    private _gw3Subscriptions: any[] = [];\r\n\r\n    // increment for every bridge-subscribe; used to unsubscribe()\r\n    private _nextCallbackSubscriptionNumber = 0;\r\n\r\n    // mapping announced contexts' name <-> id\r\n    private _contextNameToId: { [contextName: string]: string } = {};\r\n    private _contextIdToName: { [contextId: string]: string } = {};\r\n    private _protocolVersion?: number = undefined;\r\n    private get protocolVersion(): number {\r\n        if (!this._protocolVersion) {\r\n            const contextsDomainInfo = this._connection.availableDomains.find((d) => d.uri === \"context\");\r\n            this._protocolVersion = contextsDomainInfo?.version ?? 1;\r\n        }\r\n        return this._protocolVersion;\r\n    }\r\n\r\n    public get setPathSupported() {\r\n        return this.protocolVersion >= 2;\r\n    }\r\n\r\n    public constructor(config: ContextsConfig) {\r\n        this._connection = config.connection;\r\n        this._logger = config.logger;\r\n        this._gw3Session = this._connection.domain(\r\n            \"global\",\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_CREATED,\r\n                msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n                msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n                msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            ]);\r\n\r\n        // TODO: logging, validation and error handling\r\n\r\n        this.subscribeToContextCreatedMessages();\r\n\r\n        this.subscribeToContextUpdatedMessages();\r\n\r\n        this.subscribeToContextDestroyedMessages();\r\n\r\n        this._connection.replayer?.drain(\r\n            ContextMessageReplaySpec.name,\r\n            (message) => {\r\n                const type = (message as any).type;\r\n                if (!type) {\r\n                    return;\r\n                }\r\n\r\n                if (type === msg.GW_MESSAGE_CONTEXT_CREATED ||\r\n                    type === msg.GW_MESSAGE_CONTEXT_ADDED ||\r\n                    type === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n                    this.handleContextCreatedMessage(message as ContextMessage);\r\n                } else if (type === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT ||\r\n                    type === msg.GW_MESSAGE_CONTEXT_UPDATED ||\r\n                    type === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n                    this.handleContextUpdatedMessage(message as ContextMessage);\r\n                } else if (type === msg.GW_MESSAGE_CONTEXT_DESTROYED ||\r\n                    type === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n                    this.handleContextDestroyedMessage(message as ContextMessage);\r\n                }\r\n            });\r\n    }\r\n\r\n    public dispose(): void {\r\n        for (const sub of this._gw3Subscriptions) {\r\n            this._connection.off(sub);\r\n        }\r\n        this._gw3Subscriptions.length = 0;\r\n        for (const contextName in this._contextNameToData) {\r\n            if (this._contextNameToId.hasOwnProperty(contextName)) {\r\n                delete this._contextNameToData[contextName];\r\n            }\r\n        }\r\n    }\r\n\r\n    public createContext(name: ContextName, data: any): Promise<string> {\r\n        return this._gw3Session\r\n            .send<ContextMessage>({\r\n                type: msg.GW_MESSAGE_CREATE_CONTEXT,\r\n                domain: \"global\",\r\n                name,\r\n                data,\r\n                lifetime: \"retained\",\r\n            })\r\n            .then((createContextMsg: ContextMessage) => {\r\n                this._contextNameToId[name] = createContextMsg.context_id;\r\n                this._contextIdToName[createContextMsg.context_id] = name;\r\n                const contextData = this._contextNameToData[name] || new ContextData(createContextMsg.context_id, name, true, undefined);\r\n                contextData.isAnnounced = true;\r\n                contextData.name = name;\r\n                contextData.contextId = createContextMsg.context_id;\r\n                contextData.context = data;\r\n                this._contextNameToData[name] = contextData;\r\n                return createContextMsg.context_id;\r\n            });\r\n    }\r\n\r\n    public all(): ContextName[] {\r\n        return Object.keys(this._contextNameToData)\r\n            .filter((name) => this._contextNameToData[name].isAnnounced);\r\n    }\r\n\r\n    public async update(name: ContextName, delta: any): Promise<void> {\r\n\r\n        // - send context update message\r\n        //\r\n        // - on success, apply delta to context currently in contextData\r\n\r\n        // should we implicitly create the context?\r\n\r\n        const contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, delta) as any as Promise<void>;\r\n        }\r\n\r\n        // TODO: explain why --> because this\r\n        let currentContext = contextData.context;\r\n        if (!contextData.hasCallbacks()) {\r\n            currentContext = await this.get(contextData.name);\r\n        }\r\n\r\n        const calculatedDelta =\r\n            this.protocolVersion === 2 ?\r\n                this.calculateContextDeltaV2(currentContext, delta) :\r\n                this.calculateContextDeltaV1(currentContext, delta);\r\n\r\n        if (!Object.keys(calculatedDelta.added).length\r\n            && !Object.keys(calculatedDelta.updated).length\r\n            && !calculatedDelta.removed.length\r\n            && !calculatedDelta.commands?.length) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n                delta: calculatedDelta,\r\n            }, {}, { skipPeerId: false })\r\n            .then((gwResponse: any) => {\r\n                this.handleUpdated(contextData, calculatedDelta, {\r\n                    updaterId: gwResponse.peer_id\r\n                });\r\n            });\r\n    }\r\n\r\n    public set(name: ContextName, data: any): Promise<void> {\r\n\r\n        const contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, data) as any as Promise<void>;\r\n        }\r\n\r\n        // SBGW_D-194\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n                delta: { reset: data },\r\n            }, {}, { skipPeerId: false })\r\n            .then((gwResponse: any) => {\r\n                this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });\r\n            });\r\n    }\r\n\r\n    public setPath(name: ContextName, path: string, value: any): Promise<void> {\r\n        if (!this.setPathSupported) {\r\n            return Promise.reject(\"glue.contexts.setPath operation is not supported, use Glue42 3.10 or later\");\r\n        }\r\n        return this.setPaths(name, [{ path, value }]);\r\n    }\r\n\r\n    public setPaths(name: ContextName, pathValues: Glue42Core.Contexts.PathValue[]): Promise<void> {\r\n        if (!this.setPathSupported) {\r\n            return Promise.reject(\"glue.contexts.setPaths operation is not supported, use Glue42 3.10 or later\");\r\n        }\r\n        const contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            const obj = {};\r\n            for (const pathValue of pathValues) {\r\n                setValueToPath(obj, pathValue.value, pathValue.path);\r\n            }\r\n\r\n            return this.createContext(name, obj) as any as Promise<void>;\r\n        }\r\n\r\n        const commands: ContextDeltaCommand[] = [];\r\n        for (const pathValue of pathValues) {\r\n            if (pathValue.value === null) {\r\n                commands.push({ type: \"remove\", path: pathValue.path });\r\n            } else {\r\n                commands.push({ type: \"set\", path: pathValue.path, value: pathValue.value });\r\n            }\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n                delta: { commands }\r\n            }, {}, { skipPeerId: false })\r\n            .then((gwResponse: any) => {\r\n                this.handleUpdated(contextData, { added: {}, removed: [], updated: {}, commands }, { updaterId: gwResponse.peer_id });\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Return a context's data asynchronously as soon as any becomes available\r\n     */\r\n    public get(name: ContextName): Promise<any> {\r\n\r\n        const contextData = this._contextNameToData[name];\r\n        // Three cases here:\r\n        // 1) The context does not exist and is not announced by the GW -> return {}\r\n        // 2) The context exists but we don't track it -> subscribe and return the object when we get the subscription result from GW\r\n        // 3) The context exists and we're tracking it -> just return the last state we have\r\n\r\n        // 1)\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return Promise.resolve({});\r\n        }\r\n\r\n        // 2)\r\n        if (contextData && !contextData.hasCallbacks()) {\r\n            return new Promise<any>(async (resolve, _) => {\r\n                this.subscribe(name, (data: any, _d: any, _r: string[], un: ContextSubscriptionKey) => {\r\n                    this.unsubscribe(un);\r\n                    resolve(data);\r\n                });\r\n            });\r\n        }\r\n\r\n        // 3)\r\n        const context = contextData?.context ?? {};\r\n        return Promise.resolve(context);\r\n    }\r\n\r\n    /**\r\n     * Creates a subscription to a given context which may or may not exist/be\r\n     * announced as of yet.\r\n     *\r\n     * NB: This method publishes an initial snapshot on subscription. Note that\r\n     * at this point the method itself may not have returned and the returned\r\n     * ContextSubscriptionKey is not saved in the return variable; if you want\r\n     * to unsubscribe from within the subscription callback, use the key argument\r\n     * of the callback.\r\n     */\r\n    public subscribe(\r\n        name: ContextName,\r\n        callback: (\r\n            data: any,\r\n            delta: any,\r\n            removed: string[],\r\n            key: ContextSubscriptionKey,\r\n            extraData?: any) => void)\r\n        : Promise<ContextSubscriptionKey> {\r\n\r\n        // - populate contextData's updateCallbacks with new entry\r\n        //\r\n        // - examine contextData and determine if we need to send a subscribe\r\n        //\r\n        // - if the context is announced, ensure handler gets snapshot\r\n\r\n        const thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;\r\n        this._nextCallbackSubscriptionNumber += 1;\r\n\r\n        let contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData ||\r\n            !contextData.isAnnounced) {\r\n            // (0) -> (1)\r\n            contextData = contextData || new ContextData(undefined, name, false, undefined);\r\n            this._contextNameToData[name] = contextData;\r\n            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n\r\n            // this will end up in handleContextUpdate which will cause a snapshot to get sent\r\n            // return this.createContext(name, {})\r\n            // \t.then(() => thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n\r\n        const hadCallbacks = contextData.hasCallbacks();\r\n\r\n        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n\r\n        if (!hadCallbacks) {\r\n            // first subscriber: (2) -> (3)\r\n\r\n            if (!contextData.joinedActivity) {\r\n\r\n                // if we've created the context ourselves using\r\n                // createContext\r\n                if (contextData.context && contextData.sentExplicitSubscription) {\r\n                    const clone = deepClone(contextData.context);\r\n                    callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n                    return Promise.resolve(thisCallbackSubscriptionNumber);\r\n                }\r\n\r\n                // (2') -> (3') or (2\") -> (3\")\r\n                // shared context or not our activity;\r\n                // we need to gw-subscribe\r\n\r\n                // OTOH, no need to explicitly push a snapshot here,\r\n                // the GW will reply with a SUBSCRIBED CONTEXT with a snapshot\r\n                // which we'll push through subscribeToContextUpdatedMessages\r\n                // (not that we have a snapshot right now - it's not our activity,\r\n                // and we haven't subscribed already so we can't have received updates)\r\n\r\n                return this.sendSubscribe(contextData)\r\n                    .then(() => thisCallbackSubscriptionNumber);\r\n            } else {\r\n\r\n                // (2\"') -> (3\"')\r\n                // our activity, which we're tracking anyway\r\n                // no need to gw-subscribe, just push the snapshot to the new subscriber\r\n\r\n                const clone = deepClone(contextData.context);\r\n                callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n                return Promise.resolve(thisCallbackSubscriptionNumber);\r\n            }\r\n        } else {\r\n            // not first subscriber; no need to gw-subscribe, just push snapshot\r\n            // (3) -> (3)\r\n\r\n            const clone = deepClone(contextData.context);\r\n            callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n    }\r\n\r\n    public unsubscribe(subscriptionKey: ContextSubscriptionKey): void {\r\n        for (const name of Object.keys(this._contextNameToData)) {\r\n            const contextId = this._contextNameToId[name];\r\n            const contextData = this._contextNameToData[name];\r\n\r\n            if (!contextData) {\r\n                return;\r\n            }\r\n\r\n            const hadCallbacks = contextData.hasCallbacks();\r\n\r\n            delete contextData.updateCallbacks[subscriptionKey];\r\n\r\n            if (contextData.isAnnounced &&\r\n                hadCallbacks &&\r\n                !contextData.hasCallbacks() &&\r\n                contextData.sentExplicitSubscription) {\r\n                // (3) -> (2)\r\n                this.sendUnsubscribe(contextData);\r\n            }\r\n\r\n            if (!contextData.isAnnounced &&\r\n                // (1) -> (0)\r\n                !contextData.hasCallbacks()) {\r\n                delete this._contextNameToData[name];\r\n            }\r\n        }\r\n    }\r\n\r\n    public destroy(name: string) {\r\n        const contextData = this._contextNameToData[name];\r\n        if (!contextData) {\r\n            return Promise.reject(`context with ${name} does not exist`);\r\n        }\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n            }).then((_) => undefined);\r\n    }\r\n\r\n    private handleUpdated(contextData: ContextData, delta: ContextDelta, extraData?: any) {\r\n        // for correctness proof, see note about serialized context\r\n        // updates in subscribeToContextUpdatedMessages\r\n\r\n        const oldContext = contextData.context;\r\n        contextData.context = applyContextDelta(contextData.context, delta, this._logger);\r\n\r\n        if (this._contextNameToData[contextData.name] === contextData &&\r\n            !deepEqual(oldContext, contextData.context)) {\r\n            this.invokeUpdateCallbacks(contextData, delta, extraData);\r\n        }\r\n    }\r\n\r\n    private subscribeToContextCreatedMessages() {\r\n\r\n        // when a new context is announced:\r\n        //\r\n        // - record the fact that it's announced, so when the first\r\n        //      bridge-subscribers come in, we do a gw-subscribe\r\n        //\r\n        // - record its name/contextId association\r\n        //\r\n        // - record its activity information, and the fact that this\r\n        //      activity exists and that we're not joined in it (yet?)\r\n        //\r\n        // - if any bridge-subscribers already present, do a gw-subscribe\r\n\r\n        const createdMessageTypes =\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_ADDED,\r\n                msg.GW_MESSAGE_CONTEXT_CREATED,\r\n                msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            ];\r\n\r\n        for (const createdMessageType of createdMessageTypes) {\r\n            const sub = this._connection.on(\r\n                createdMessageType,\r\n                this.handleContextCreatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    }\r\n\r\n    private handleContextCreatedMessage(contextCreatedMsg: ContextMessage): void {\r\n        const createdMessageType = contextCreatedMsg.type;\r\n        if (createdMessageType === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n            // activity context\r\n\r\n            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;\r\n        } else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_ADDED) {\r\n            // shared context\r\n\r\n            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;\r\n        } else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_CREATED) {\r\n            // created by us, data already populated\r\n\r\n            // NB: the promise resolution from createContext is supposed to run *before*\r\n            // we see the CONTEXT CREATED here, so _contextIdToName/_contextNameToId\r\n            // are supposed to already be populated (this is because the gw connection\r\n            // success handler is subscribed long before this one)\r\n        }\r\n\r\n        const name = this._contextIdToName[contextCreatedMsg.context_id];\r\n\r\n        if (!name) {\r\n            // we're supposed to have recorded the name\r\n            throw new Error(\"Received created event for context with unknown name: \" + contextCreatedMsg.context_id);\r\n        }\r\n\r\n        if (!this._contextNameToId[name]) {\r\n            // we're also supposed to have recorded it in the opposite direction\r\n            throw new Error(\"Received created event for context with unknown id: \" + contextCreatedMsg.context_id);\r\n        }\r\n\r\n        let contextData = this._contextNameToData[name];\r\n\r\n        if (contextData) {\r\n            if (contextData.isAnnounced) {\r\n                return;\r\n            } else {\r\n                // (1) -> (3') or (1) -> (3\")\r\n\r\n                // someone's already expressed interest in this context and now\r\n                // it's being announced\r\n\r\n                // you might think that since the activity context's id is\r\n                // auto-generated no one could have already context-subscribed, but\r\n                // there might be another ACTIVITY CREATED observer on the same\r\n                // GW connection who saw this message before us and reacted by\r\n                // subscribing to the context - so we need to handle this case\r\n\r\n                if (!contextData.hasCallbacks()) {\r\n                    throw new Error(\"Assertion failure: contextData.hasCallbacks()\");\r\n                }\r\n\r\n                // update its state and send a gw-subscribe; we're expecting an update message\r\n\r\n                contextData.isAnnounced = true;\r\n                contextData.contextId = contextCreatedMsg.context_id;\r\n                contextData.activityId = contextCreatedMsg.activity_id;\r\n\r\n                // if we're observing the ACTIVITY CREATED message,\r\n                // we're not one of its members and we need to gw-subscribe\r\n                // explicitly; of course we could be getting joined to the activity\r\n                // pretty soon which would subscribe us to context updates implicitly\r\n\r\n                // long story short, if we're about to be joined to the activity\r\n                // and an observer to ACTIVITY CREATED subscribes to the activity's context\r\n                // before we get to this point, we'll send a needless SUBSCRIBE CONTEXT\r\n                // but there's no harm done by beating that to the punch, and there's\r\n                // no clean way to avoid this situation so we leave this as an artifact\r\n                // of the implementation\r\n\r\n                // whether activity or not, we'll push the initial snapshot in the\r\n                // subscribeToContextUpdatedMessages handler\r\n\r\n                if (!contextData.sentExplicitSubscription) {\r\n                    this.sendSubscribe(contextData);\r\n                }\r\n            }\r\n        } else {\r\n            // (0) -> (2') or (0) -> (2\")\r\n            // first time we hear about this context\r\n            // we're not subscribed to it in the GW so just create a placeholder\r\n            // and wait for someone to subscribe to it - we'll THEN send a subscribe to the GW\r\n\r\n            this._contextNameToData[name] = contextData =\r\n                new ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);\r\n        }\r\n    }\r\n\r\n    private subscribeToContextUpdatedMessages() {\r\n\r\n        // receiving a context update or snapshot\r\n        //\r\n        // if it's JOINED ACTIVITY, we may be a new peer as part of activity\r\n        // creation, so it's the first time we've heard about it -\r\n        // record the activity information in the contextData\r\n        //\r\n        // otherwise, this message is a response/consequence of our gw-subscribe\r\n        // message sent on entering state (3)\r\n        //\r\n        // in any case, apply any deltas to the contextData.context, and\r\n        // propagate the context data and delta to any bridge-subscription\r\n        // handlers\r\n        //\r\n        // note that context updates are always performed when reacting to\r\n        // a GW message, so the data over time is tied to the flow of\r\n        // messages coming in through the gateway connection; the GW decides\r\n        // which update comes before which and our view of the changes to\r\n        // the context is consistent with it (i.e. the GW is the serializing\r\n        // agent)\r\n\r\n        const updatedMessageTypes =\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n                msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n                msg.GW_MESSAGE_JOINED_ACTIVITY,\r\n            ];\r\n\r\n        for (const updatedMessageType of updatedMessageTypes) {\r\n            const sub = this._connection.on(\r\n                updatedMessageType,\r\n                this.handleContextUpdatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    }\r\n\r\n    private handleContextUpdatedMessage(contextUpdatedMsg: ContextMessage): void {\r\n        const updatedMessageType = contextUpdatedMsg.type;\r\n        const contextId = contextUpdatedMsg.context_id;\r\n        let contextData = this._contextNameToData[this._contextIdToName[contextId]];\r\n        // this flag is basically used to make sure we raise an update for a new activity\r\n        // even if its initial context is empty\r\n        // see \"long analysis for callback behavior in GW3: several cases\" comment in\r\n        // activityMyApi.ts in js-activity, case 1-1-1\r\n        // it serves a similar purpose for gw_message_subscribed_context\r\n        const justSeen = !contextData || !contextData.isAnnounced;\r\n\r\n        if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            if (!contextData) {\r\n                // (0) -> (2\"')\r\n\r\n                // we're in the middle of activity creation\r\n                contextData = new ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);\r\n                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;\r\n                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;\r\n                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;\r\n            } else {\r\n                // (1) -> (3\"'), (2\") -> (2\"') or (3\") -> (3\"')\r\n\r\n                contextData.contextId = contextId;\r\n                contextData.isAnnounced = true;\r\n                contextData.activityId = contextUpdatedMsg.activity_id;\r\n            }\r\n            contextData.joinedActivity = true;\r\n        } else {\r\n            if (!contextData || !contextData.isAnnounced) {\r\n                if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n                    // we've tried to create a context that already exists\r\n                    contextData = contextData || new ContextData(contextId, contextUpdatedMsg.name, true, undefined);\r\n                    contextData.sentExplicitSubscription = true;\r\n                    this._contextNameToData[contextUpdatedMsg.name] = contextData;\r\n                    this._contextIdToName[contextId] = contextUpdatedMsg.name;\r\n                    this._contextNameToId[contextUpdatedMsg.name] = contextId;\r\n                } else {\r\n                    this._logger.error(`Received 'update' for unknown context: ${contextId}`);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        const oldContext = contextData.context;\r\n\r\n        if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            contextData.context = contextUpdatedMsg.data || {};\r\n        } else if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            contextData.context = contextUpdatedMsg.context_snapshot || {};\r\n        } else if (updatedMessageType === msg.GW_MESSAGE_CONTEXT_UPDATED) {\r\n            contextData.context = applyContextDelta(\r\n                contextData.context,\r\n                contextUpdatedMsg.delta as ContextDelta,\r\n                this._logger);\r\n        } else {\r\n            throw new Error(\"Unrecognized context update message \" + updatedMessageType);\r\n        }\r\n\r\n        if (justSeen ||\r\n            !deepEqual(contextData.context, oldContext) ||\r\n            updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            this.invokeUpdateCallbacks(contextData, contextUpdatedMsg.delta, { updaterId: contextUpdatedMsg.updater_id });\r\n        }\r\n    }\r\n\r\n    private invokeUpdateCallbacks(contextData: ContextData, delta?: ContextDelta, extraData?: any) {\r\n        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };\r\n        if (delta.commands) {\r\n            // clear added, updated, removed, reset\r\n            delta.added = delta.updated = delta.reset = {};\r\n            delta.removed = [];\r\n            for (const command of delta.commands) {\r\n                if (command.type === \"remove\") {\r\n                    // push the removal of top level props only\r\n                    if (command.path.indexOf(\".\") === -1) {\r\n                        delta.removed.push(command.path);\r\n                    }\r\n                    setValueToPath(delta.updated, null, command.path);\r\n                } else if (command.type === \"set\") {\r\n                    setValueToPath(delta.updated, command.value, command.path);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        for (const updateCallbackIndex in contextData.updateCallbacks) {\r\n            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {\r\n                try {\r\n                    const updateCallback = contextData.updateCallbacks[updateCallbackIndex];\r\n                    updateCallback(deepClone(contextData.context), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex, 10), extraData);\r\n                } catch (err) {\r\n                    this._logger.debug(\"callback error: \" + JSON.stringify(err));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private subscribeToContextDestroyedMessages() {\r\n        // wipe all bookkeeping related to this context\r\n\r\n        const destroyedMessageTypes =\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n                msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            ];\r\n\r\n        for (const destroyedMessageType of destroyedMessageTypes) {\r\n            const sub = this._connection.on(\r\n                destroyedMessageType,\r\n                this.handleContextDestroyedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    }\r\n\r\n    private handleContextDestroyedMessage(destroyedMsg: ContextMessage): void {\r\n        const destroyedMessageType = destroyedMsg.type;\r\n        let contextId;\r\n        let name;\r\n\r\n        // (?) -> (0)\r\n\r\n        if (destroyedMessageType === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n            name = destroyedMsg.activity_id;\r\n            contextId = this._contextNameToId[name];\r\n            if (!contextId) {\r\n                this._logger.error(`Received 'destroyed' for unknown activity: ${destroyedMsg.activity_id}`);\r\n                return;\r\n            }\r\n        } else {\r\n            contextId = destroyedMsg.context_id;\r\n            name = this._contextIdToName[contextId];\r\n            if (!name) {\r\n                this._logger.error(`Received 'destroyed' for unknown context: ${destroyedMsg.context_id}`);\r\n                return;\r\n            }\r\n        }\r\n\r\n        delete this._contextIdToName[contextId];\r\n        delete this._contextNameToId[name];\r\n\r\n        const contextData = this._contextNameToData[name];\r\n        delete this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            this._logger.error(`Received 'destroyed' for unknown context: ${contextId}`);\r\n            return;\r\n        }\r\n    }\r\n\r\n    private sendSubscribe(contextData: ContextData): Promise<void> {\r\n        contextData.sentExplicitSubscription = true;\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n            }).then((_) => undefined);\r\n    }\r\n\r\n    private sendUnsubscribe(contextData: ContextData): Promise<void> {\r\n        contextData.sentExplicitSubscription = false;\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n            }).then((_) => undefined);\r\n    }\r\n\r\n    private calculateContextDeltaV1(from: any, to: any): ContextDelta {\r\n        const delta: ContextDelta = { added: {}, updated: {}, removed: [], reset: undefined };\r\n        if (from) {\r\n            for (const x of Object.keys(from)) {\r\n                if (Object.keys(to).indexOf(x) !== -1\r\n                    && to[x] !== null\r\n                    && !deepEqual(from[x], to[x])) {\r\n                    delta.updated[x] = to[x];\r\n                }\r\n            }\r\n        }\r\n        for (const x of Object.keys(to)) {\r\n            if (!from || (Object.keys(from).indexOf(x) === -1)) {\r\n                if (to[x] !== null) {\r\n                    delta.added[x] = to[x];\r\n                }\r\n            } else if (to[x] === null) {\r\n                delta.removed.push(x);\r\n            }\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    private calculateContextDeltaV2(from: any, to: any): ContextDelta {\r\n        const delta: ContextDelta = { added: {}, updated: {}, removed: [], reset: undefined, commands: [] };\r\n\r\n        for (const x of Object.keys(to)) {\r\n            if (to[x] !== null) {\r\n                const fromX = from ? from[x] : null;\r\n                if (!deepEqual(fromX, to[x])) {\r\n                    delta.commands?.push({ type: \"set\", path: x, value: to[x] });\r\n                }\r\n            } else {\r\n                delta.commands?.push({ type: \"remove\", path: x });\r\n            }\r\n        }\r\n\r\n        return delta;\r\n    }\r\n}\r\n","/*\r\n  The AGM Client analyses server presences, collects information about their methods and allows users to invoke these methods.\r\n */\r\nimport promisify from \"../helpers/promisify\";\r\nimport { Protocol, SubscribeError, InteropSettings, SubscriptionInner } from \"../types\";\r\nimport { ClientMethodInfo, ServerInfo, ServerMethodsPair } from \"./types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport ClientRepository from \"./repository\";\r\nimport { UnsubscribeFunction } from \"callback-registry\";\r\nimport random from \"shortid\";\r\nimport { rejectAfter } from \"../helpers/promiseHelpers\";\r\nimport { isSubset } from \"../../contexts/helpers\";\r\nimport InvocationResult = Glue42Core.AGM.InvocationResult;\r\nimport MethodDefinition = Glue42Core.AGM.MethodDefinition;\r\nimport Method = Glue42Core.Interop.Method;\r\n\r\nexport enum InvokeStatus {\r\n    Success = 0,\r\n    Error = 1,\r\n}\r\n\r\nexport interface InvokeResultMessage {\r\n    invocationId: string;\r\n    result?: object;\r\n    instance?: Glue42Core.AGM.Instance;\r\n    status: InvokeStatus;\r\n    message: string;\r\n    error?: Error;\r\n}\r\n\r\nexport default class Client {\r\n    constructor(private protocol: Protocol, private repo: ClientRepository, private instance: Glue42Core.AGM.Instance, private configuration: InteropSettings) {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * Subscribes to an AGM streaming method\r\n     */\r\n    public subscribe(method: string | Glue42Core.AGM.MethodDefinition, options: Glue42Core.AGM.SubscriptionParams, successCallback?: (subscription: Glue42Core.AGM.Subscription) => void, errorCallback?: (err: SubscribeError) => void, existingSub?: SubscriptionInner): Promise<Glue42Core.AGM.Subscription> {\r\n        // options can have arguments:{}, target: 'best'/'all'/{server_instance}, waitTimeoutMs:10000\r\n\r\n        const callProtocolSubscribe = (targetServers: ServerMethodsPair[], stream: Glue42Core.AGM.MethodDefinition, successProxy: (sub: Glue42Core.AGM.Subscription) => void, errorProxy: (err: SubscribeError) => void) => {\r\n\r\n            options.methodResponseTimeout = options.methodResponseTimeout ?? options.waitTimeoutMs;\r\n\r\n            this.protocol.client.subscribe(\r\n                stream,\r\n                options,\r\n                targetServers,\r\n                successProxy,\r\n                errorProxy,\r\n                existingSub\r\n            );\r\n        };\r\n\r\n        const promise = new Promise<Glue42Core.AGM.Subscription>((resolve, reject) => {\r\n\r\n            const successProxy = (sub: Glue42Core.AGM.Subscription) => {\r\n                resolve(sub);\r\n            };\r\n            const errorProxy = (err: SubscribeError) => {\r\n                reject(err);\r\n            };\r\n\r\n            if (!method) {\r\n                reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n                return;\r\n            }\r\n\r\n            let methodDef: Glue42Core.AGM.MethodDefinition;\r\n            if (typeof method === \"string\") {\r\n                methodDef = { name: method };\r\n            } else {\r\n                methodDef = method;\r\n            }\r\n\r\n            if (!methodDef.name) {\r\n                reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n                return;\r\n            }\r\n\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            let target = options.target;\r\n            if (target === undefined) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject(new Error(`\"${target}\" is not a valid target. Valid targets are \"all\", \"best\", or an instance.`));\r\n                return;\r\n            }\r\n\r\n            if (options.methodResponseTimeout === undefined) {\r\n                // legacy support\r\n                options.methodResponseTimeout = (options as any).method_response_timeout;\r\n                if (options.methodResponseTimeout === undefined) {\r\n                    // fallback to default\r\n                    options.methodResponseTimeout = this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n\r\n            if (options.waitTimeoutMs === undefined) {\r\n                // legacy support\r\n                options.waitTimeoutMs = (options as any).wait_for_method_timeout;\r\n                if (options.waitTimeoutMs === undefined) {\r\n                    // fallback to default\r\n                    options.waitTimeoutMs = this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n\r\n            const delayStep = 500;\r\n            let delayTillNow = 0;\r\n\r\n            // don't check if the method is streaming or not, subscribing to non-streaming method has to invoke it\r\n\r\n            // get all servers that have method(s) matching the filter\r\n            let currentServers = this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n            if (currentServers.length > 0) {\r\n                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);\r\n            } else {\r\n                const retry = () => {\r\n                    if (!target || !(options.waitTimeoutMs)) {\r\n                        return;\r\n                    }\r\n                    delayTillNow += delayStep;\r\n                    // get all servers that have method(s) matching the filter\r\n                    currentServers = this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n                    if (currentServers.length > 0) {\r\n                        const streamInfo = currentServers[0].methods[0];\r\n                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);\r\n                    } else if (delayTillNow >= options.waitTimeoutMs) {\r\n                        const def = typeof method === \"string\" ? { name: method } : method;\r\n                        callProtocolSubscribe(currentServers, def, successProxy, errorProxy);\r\n                    } else {\r\n                        setTimeout(retry, delayStep);\r\n                    }\r\n                };\r\n                setTimeout(retry, delayStep);\r\n            }\r\n        });\r\n\r\n        return promisify(promise, successCallback, errorCallback);\r\n    }\r\n\r\n    /**\r\n     * Returns all servers. If methodFilter is specified will return a list of servers\r\n     * having a method matching the filter.\r\n     */\r\n    public servers(methodFilter: Glue42Core.AGM.MethodDefinition): Glue42Core.AGM.Instance[] {\r\n        const filterCopy = methodFilter === undefined\r\n            ? undefined\r\n            : { ...methodFilter };\r\n\r\n        // We want only the announced servers\r\n        return this.getServers(filterCopy).map((serverMethodMap) => {\r\n            return serverMethodMap.server.instance;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns all methods that match the given filter. If no filter specified returns all methods.\r\n     */\r\n    public methods(methodFilter: Glue42Core.AGM.MethodDefinition | string): Glue42Core.AGM.Method[] {\r\n        if (typeof methodFilter === \"string\") {\r\n            methodFilter = { name: methodFilter };\r\n        } else {\r\n            // Must not be mutated\r\n            methodFilter = { ...methodFilter };\r\n        }\r\n\r\n        return this.getMethods(methodFilter);\r\n    }\r\n\r\n    /**\r\n     * Returns all agm method registered by some server\r\n     */\r\n    public methodsForInstance(instance: Glue42Core.AGM.Instance): Glue42Core.AGM.Method[] {\r\n        return this.getMethodsForInstance(instance);\r\n    }\r\n\r\n    /**\r\n     * Called when a method is added for the first time by any application\r\n     */\r\n    public methodAdded(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.repo.onMethodAdded(callback);\r\n    }\r\n\r\n    /**\r\n     * Called when a method is removed from the last application offering it\r\n     * @function methodRemoved\r\n     * @param {MethodCallback} callback\r\n     */\r\n    public methodRemoved(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.repo.onMethodRemoved(callback);\r\n    }\r\n\r\n    /**\r\n     * Called when an application offering methods (server) is discovered\r\n     * @param {InstanceCallback} callback Callback that will be invoked with the {@link Instance} of the new sever\r\n     */\r\n    public serverAdded(callback: (instance: Glue42Core.AGM.Instance) => void): UnsubscribeFunction {\r\n        return this.repo.onServerAdded(callback);\r\n    }\r\n\r\n    /**\r\n     * Called when an app offering methods stops offering them or exits\r\n     * @param {InstanceCallback} callback Callback that will be invoked with the {@link Instance} of the removed server\r\n     */\r\n    public serverRemoved(callback: (instance: Glue42Core.AGM.Instance, reason: string) => void): UnsubscribeFunction {\r\n        return this.repo.onServerRemoved((server: Glue42Core.AGM.Instance, reason: string) => {\r\n            callback(server, reason);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when a method is offered by an application. This will be called for each server offering the method\r\n     * where {@link methodAdded} will be called only for the first time the method is registered.\r\n     *\r\n     * @param {ServerMethodCallback} callback\r\n     */\r\n    public serverMethodAdded(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.Method }) => void): UnsubscribeFunction {\r\n        return this.repo.onServerMethodAdded((server: Glue42Core.AGM.Instance, method: ClientMethodInfo) => {\r\n            callback({ server, method });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when a server stops offering a method\r\n     * @param {ServerMethodCallback} callback\r\n     */\r\n    public serverMethodRemoved(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.Method }) => void): UnsubscribeFunction {\r\n        return this.repo.onServerMethodRemoved((server: Glue42Core.AGM.Instance, method: ClientMethodInfo) => {\r\n            callback({ server, method });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invokes an AGM method\r\n     * @param {MethodDefinition} methodFilter Method to invoke\r\n     * @param {Object} argumentObj Arguments for the invocation\r\n     * @param {Instance|Instance[]|string} [target] Defines which server(s) to target with the invocation - can be one of:\r\n     * * best' - executes the method on the best (or first) server\r\n     * * 'all' - executes the method on all servers offering it\r\n     * * AGM instance (or a subset, used for filtering), e.g. { application: 'appName' }\r\n     * * an array of AGM instances/filters\r\n     * @param {InvocationOptions} [additionalOptions] Additional options for the invocation\r\n     * @param {function} [success] - (use this if you prefer callback style instead of promises)\r\n     * Callback that will be called with {@link InvocationResult} object when the invocation is successful\r\n     * @param {function} [error] -  (use this if you prefer callback style instead of promises)\r\n     * Callback that will be called with {@link InvocationError} object when the invocation is not successful\r\n     * @returns {Promise<InvocationResult>}\r\n     * @example\r\n     * const result = await glue.agm.invoke(\"Sum\", { a: 37, b: 5 }); // everything else is optional\r\n     * console.log('37 + 5 = ' + result.returned.answer);\r\n     */\r\n\r\n    public async invoke(methodFilter: string | Glue42Core.AGM.MethodDefinition, argumentObj?: object, target?: Glue42Core.AGM.InstanceTarget, additionalOptions?: Glue42Core.AGM.InvokeOptions, success?: Glue42Core.AGM.InvokeSuccessHandler<any>, error?: Glue42Core.AGM.InvokeErrorHandler)\r\n        : Promise<Glue42Core.AGM.InvocationResult<any>> {\r\n        const getInvokePromise = async () => {\r\n\r\n            let methodDefinition: Glue42Core.AGM.MethodDefinition;\r\n            if (typeof methodFilter === \"string\") {\r\n                methodDefinition = { name: methodFilter };\r\n            } else {\r\n                methodDefinition = { ...methodFilter };\r\n            }\r\n\r\n            if (!methodDefinition.name) {\r\n                return Promise.reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n            }\r\n\r\n            if (!argumentObj) {\r\n                argumentObj = {};\r\n            }\r\n            if (!target) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\" && target !== \"skipMine\") {\r\n                return Promise.reject(new Error(`\"${target}\" is not a valid target. Valid targets are \"all\" and \"best\".`));\r\n            }\r\n            if (!additionalOptions) {\r\n                additionalOptions = {};\r\n            }\r\n\r\n            if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                // legacy support\r\n                additionalOptions.methodResponseTimeoutMs = (additionalOptions as any).method_response_timeout;\r\n                if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                    // fallback to default\r\n                    additionalOptions.methodResponseTimeoutMs = this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n\r\n            if (additionalOptions.waitTimeoutMs === undefined) {\r\n                // legacy support\r\n                additionalOptions.waitTimeoutMs = (additionalOptions as any).wait_for_method_timeout;\r\n                if (additionalOptions.waitTimeoutMs === undefined) {\r\n                    // fallback to default\r\n                    additionalOptions.waitTimeoutMs = this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n\r\n            if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== \"number\") {\r\n                return Promise.reject(new Error(`\"${additionalOptions.waitTimeoutMs}\" is not a valid number for \"waitTimeoutMs\" `));\r\n            }\r\n\r\n            // Check if the arguments are an object\r\n            if (typeof argumentObj !== \"object\") {\r\n                return Promise.reject(new Error(`The method arguments must be an object. method: ${methodDefinition.name}`));\r\n            }\r\n\r\n            let serversMethodMap: ServerMethodsPair[] = this.getServerMethodsByFilterAndTarget(methodDefinition, target);\r\n\r\n            // Try to await them and then continue\r\n            if (serversMethodMap.length === 0) {\r\n                try {\r\n                    // because of the additionalOptions\r\n                    serversMethodMap = await this.tryToAwaitForMethods(methodDefinition, target, additionalOptions);\r\n                } catch (err) {\r\n                    const method: Glue42Core.Interop.Method = {\r\n                        ...methodDefinition,\r\n                        getServers: () => [],\r\n                        supportsStreaming: false,\r\n                        objectTypes: methodDefinition.objectTypes ?? [],\r\n                        flags: methodDefinition.flags?.metadata ?? {}\r\n                    };\r\n                    const errorObj: InvocationResult = {\r\n                        method,\r\n                        called_with: argumentObj,\r\n                        message: `Can not find a method matching ${JSON.stringify(methodFilter)} with server filter ${JSON.stringify(target)}`,\r\n                        executed_by: undefined,\r\n                        returned: undefined,\r\n                        status: undefined,\r\n                    };\r\n\r\n                    return Promise.reject(errorObj);\r\n                }\r\n            }\r\n\r\n            const timeout = additionalOptions.methodResponseTimeoutMs;\r\n            // ts be happy\r\n            const additionalOptionsCopy: Glue42Core.AGM.InvokeOptions = additionalOptions;\r\n            const invokePromises: Array<Promise<InvokeResultMessage>> = serversMethodMap.map(\r\n                (serversMethodPair) => {\r\n                    const invId = random();\r\n                    const method = serversMethodPair.methods[0];\r\n                    const server = serversMethodPair.server;\r\n                    const invokePromise = this.protocol.client.invoke(invId, method, argumentObj, server, additionalOptionsCopy);\r\n\r\n                    return Promise.race([\r\n                        invokePromise,\r\n                        rejectAfter(timeout, invokePromise, {\r\n                            invocationId: invId,\r\n                            message: `Invocation timeout (${timeout} ms) reached for method name: ${method?.name}, target instance: ${JSON.stringify(server.instance)}, options: ${JSON.stringify(additionalOptionsCopy)}`,\r\n                            status: InvokeStatus.Error,\r\n                        })\r\n                    ]);\r\n                }\r\n            );\r\n\r\n            const invocationMessages: InvokeResultMessage[] = await Promise.all(invokePromises);\r\n\r\n            const results = this.getInvocationResultObj(invocationMessages, methodDefinition, argumentObj);\r\n\r\n            const allRejected = invocationMessages.every((result) => result.status === InvokeStatus.Error);\r\n            if (allRejected) {\r\n                return Promise.reject(results);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        // I would call this\r\n        return promisify(getInvokePromise(), success, error);\r\n    }\r\n\r\n    private getInvocationResultObj(invocationResults: InvokeResultMessage[], method: MethodDefinition, calledWith: object): InvocationResult<any> {\r\n        /* tslint:disable:variable-name*/\r\n        const all_return_values = invocationResults\r\n            .filter((invokeMessage) => invokeMessage.status === InvokeStatus.Success)\r\n            .reduce<InvocationResult[]>(\r\n                (allValues, currentValue) => {\r\n                    allValues = [\r\n                        ...allValues,\r\n                        {\r\n                            executed_by: currentValue.instance,\r\n                            returned: currentValue.result,\r\n                            called_with: calledWith,\r\n                            method,\r\n                            message: currentValue.message,\r\n                            status: currentValue.status,\r\n                        }\r\n                    ];\r\n\r\n                    return allValues;\r\n                }, []\r\n            );\r\n\r\n        /* tslint:disable:variable-name*/\r\n        const all_errors = invocationResults\r\n            .filter((invokeMessage) => invokeMessage.status === InvokeStatus.Error)\r\n            .reduce<object[]>((allErrors, currError) => {\r\n                allErrors = [\r\n                    ...allErrors,\r\n                    {\r\n                        executed_by: currError.instance,\r\n                        called_with: calledWith,\r\n                        name: method.name,\r\n                        message: currError.message,\r\n                    }\r\n                ];\r\n\r\n                return allErrors;\r\n            }, []);\r\n\r\n        const invResult = invocationResults[0];\r\n\r\n        const result: InvocationResult = {\r\n            method,\r\n            called_with: calledWith,\r\n            returned: invResult.result,\r\n            executed_by: invResult.instance,\r\n            all_return_values,\r\n            all_errors,\r\n            message: invResult.message,\r\n            status: invResult.status\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Called when the user tries to invoke a method which does not exist\r\n     */\r\n    private tryToAwaitForMethods(methodDefinition: MethodDefinition, target: Glue42Core.AGM.InstanceTarget, additionalOptions: Glue42Core.AGM.InvokeOptions): Promise<ServerMethodsPair[]> {\r\n        return new Promise((resolve, reject) => {\r\n            if (additionalOptions.waitTimeoutMs === 0) {\r\n                reject();\r\n                return;\r\n            }\r\n\r\n            const delayStep = 500;\r\n            let delayTillNow = 0;\r\n\r\n            const retry = () => {\r\n                delayTillNow += delayStep;\r\n\r\n                // get all servers that have method(s) matching the filter\r\n                const serversMethodMap = this.getServerMethodsByFilterAndTarget(methodDefinition, target);\r\n                if (serversMethodMap.length > 0) {\r\n                    clearInterval(interval);\r\n                    resolve(serversMethodMap);\r\n                } else if (delayTillNow >= (additionalOptions.waitTimeoutMs || 10000)) {\r\n                    clearInterval(interval);\r\n                    reject();\r\n                    return;\r\n                }\r\n            };\r\n            const interval = setInterval(retry, delayStep);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Filters an array of servers and returns the ones which match the target criteria\r\n     */\r\n    private filterByTarget(target: Glue42Core.AGM.InstanceTarget, serverMethodMap: ServerMethodsPair[]): ServerMethodsPair[] {\r\n        // If the user specified target as string:\r\n        if (typeof target === \"string\") {\r\n            if (target === \"all\") {\r\n                return [...serverMethodMap];\r\n            } else if (target === \"best\") {\r\n                // Returns first app found\r\n                const localMachine = serverMethodMap\r\n                    .find((s) => s.server.instance.isLocal);\r\n\r\n                if (localMachine) {\r\n                    return [localMachine];\r\n                }\r\n\r\n                if (serverMethodMap[0] !== undefined) {\r\n                    return [serverMethodMap[0]];\r\n                }\r\n            } else if (target === \"skipMine\") {\r\n                return serverMethodMap.filter(({ server }) => server.instance.peerId !== this.instance.peerId);\r\n            }\r\n        } else {\r\n            let targetArray: Glue42Core.AGM.Instance[];\r\n            if (!Array.isArray(target)) {\r\n                targetArray = [target];\r\n            } else {\r\n                targetArray = target;\r\n            }\r\n\r\n            // Retrieve all getServers that match the filters\r\n            const allServersMatching = targetArray.reduce((matches: ServerMethodsPair[], filter) => {\r\n                // Add matches for each filter\r\n                const myMatches = serverMethodMap.filter((serverMethodPair) => {\r\n                    return this.instanceMatch(filter, serverMethodPair.server.instance);\r\n                });\r\n                return matches.concat(myMatches);\r\n            }, []);\r\n\r\n            return allServersMatching;\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Matches a server definition against a server filter\r\n     */\r\n    private instanceMatch(instanceFilter: Glue42Core.AGM.Instance, instanceDefinition: Glue42Core.AGM.Instance): boolean {\r\n        return this.containsProps(instanceFilter, instanceDefinition);\r\n    }\r\n\r\n    /**\r\n     * Matches a method definition against a method filter\r\n     */\r\n    private methodMatch(methodFilter: Glue42Core.AGM.MethodDefinition, methodDefinition: Glue42Core.AGM.MethodDefinition): boolean {\r\n        return this.containsProps(methodFilter, methodDefinition);\r\n    }\r\n\r\n    /**\r\n     * Checks if all properties of filter match properties in object\r\n     */\r\n    private containsProps(filter: any, repoMethod: any): boolean {\r\n        const filterProps = Object.keys(filter)\r\n            .filter((prop) => {\r\n                return filter[prop] !== undefined\r\n                    && typeof filter[prop] !== \"function\"\r\n                    && prop !== \"object_types\"\r\n                    && prop !== \"display_name\"\r\n                    && prop !== \"id\"\r\n                    && prop !== \"gatewayId\"\r\n                    && prop !== \"identifier\"\r\n                    && prop[0] !== \"_\";\r\n            });\r\n\r\n        return filterProps.every((prop) => {\r\n            let isMatch;\r\n\r\n            const filterValue = filter[prop];\r\n            const repoMethodValue = repoMethod[prop];\r\n\r\n            switch (prop) {\r\n                case \"objectTypes\":\r\n                    // filterValue needs to be a subset of repoMethodValue.\r\n                    isMatch = ((filterValue || []) as string[]).every((filterValueEl) => {\r\n                        return ((repoMethodValue || []) as string[]).includes(filterValueEl);\r\n                    });\r\n                    break;\r\n                case \"flags\":\r\n                    // filterValue needs to be a subset of repoMethodValue.\r\n                    isMatch = isSubset(repoMethodValue || {}, filterValue || {});\r\n                    break;\r\n                default:\r\n                    isMatch = String(filterValue).toLowerCase() === String(repoMethodValue).toLowerCase();\r\n            }\r\n\r\n            return isMatch;\r\n        });\r\n    }\r\n\r\n    private getMethods(methodFilter: Glue42Core.AGM.MethodDefinition): ClientMethodInfo[] {\r\n        if (methodFilter === undefined) {\r\n            return this.repo.getMethods();\r\n        }\r\n\r\n        const methods = this.repo.getMethods().filter((method) => {\r\n            return this.methodMatch(methodFilter, method);\r\n        });\r\n\r\n        return methods;\r\n    }\r\n\r\n    private getMethodsForInstance(instanceFilter: Glue42Core.AGM.Instance): ClientMethodInfo[] {\r\n        const allServers: ServerInfo[] = this.repo.getServers();\r\n\r\n        const matchingServers = allServers.filter((server) => {\r\n            return this.instanceMatch(instanceFilter, server.instance);\r\n        });\r\n\r\n        if (matchingServers.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        let resultMethodsObject: { [key: string]: ClientMethodInfo } = {};\r\n\r\n        if (matchingServers.length === 1) {\r\n            resultMethodsObject = matchingServers[0].methods;\r\n        } else {\r\n            // we have more than one server matching, join all methods\r\n            matchingServers.forEach((server) => {\r\n                Object.keys(server.methods).forEach((methodKey) => {\r\n                    const method = server.methods[methodKey];\r\n                    // group by method identifier\r\n                    resultMethodsObject[method.identifier] = method;\r\n                });\r\n            });\r\n        }\r\n\r\n        // transform the object to array\r\n        return Object.keys(resultMethodsObject)\r\n            .map((key) => {\r\n                return resultMethodsObject[key];\r\n            });\r\n    }\r\n\r\n    private getServers(methodFilter?: Glue42Core.AGM.MethodDefinition): ServerMethodsPair[] {\r\n        const servers = this.repo.getServers();\r\n\r\n        // No method - get all getServers\r\n        if (methodFilter === undefined) {\r\n            return servers.map((server) => {\r\n                return { server, methods: [] };\r\n            });\r\n        }\r\n\r\n        // // Non-existing method - return an empty array\r\n        // const methods = this.getMethods(methodFilter);\r\n        // if (methods === undefined) {\r\n        //     return [];\r\n        // }\r\n\r\n        return servers.reduce<ServerMethodsPair[]>((prev, current) => {\r\n\r\n            const methodsForServer = Object.values(current.methods);\r\n\r\n            const matchingMethods = methodsForServer.filter((method) => {\r\n                return this.methodMatch(methodFilter, method);\r\n            });\r\n\r\n            if (matchingMethods.length > 0) {\r\n                prev.push({ server: current, methods: matchingMethods });\r\n            }\r\n\r\n            return prev;\r\n        }, []);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of server-methods pairs for all servers that match the target and have at lease one method matching the method filter\r\n     */\r\n    private getServerMethodsByFilterAndTarget(methodFilter: Glue42Core.AGM.MethodDefinition, target: Glue42Core.AGM.InstanceTarget): ServerMethodsPair[] {\r\n        // get all servers that have method(s) matching the filter\r\n        const serversMethodMap = this.getServers(methodFilter);\r\n        // filter the server-method map by target\r\n        return this.filterByTarget(target, serversMethodMap);\r\n    }\r\n\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { GW3Bridge } from \"./bridges/gw3/bridge\";\r\nimport { ContextBridge } from \"./contextBridge\";\r\nimport Connection from \"../connection/connection\";\r\nimport { Logger } from \"../logger/logger\";\r\nimport { ContextName, ContextSubscriptionKey } from \"./bridges/types\";\r\n\r\n/** @ignore */\r\nexport interface ContextsConfig {\r\n    connection: Connection;\r\n    logger: Logger;\r\n}\r\n\r\nexport class ContextsModule implements Glue42Core.Contexts.API {\r\n\r\n    public initTime: number | undefined;\r\n    public initStartTime: number | undefined;\r\n    public initEndTime?: number;\r\n    private _bridge: ContextBridge;\r\n\r\n    public constructor(config: ContextsConfig) {\r\n        this._bridge = new GW3Bridge(config);\r\n    }\r\n\r\n    public all(): string[] {\r\n        return this._bridge.all();\r\n    }\r\n\r\n    /**\r\n     * Updates a context with some object. The object properties will replace the context properties, any other\r\n     * context properties will remain in the context. If the context does not exists the update call will create it.\r\n     *\r\n     * @example\r\n     * // if theme does not exists creates a context called theme with initial value\r\n     * glue.contexts.update(\"theme\", {font:10, font-family:\"Arial\"})\r\n     *\r\n     * // increases font to 11, after that call context is {font:10, font-family:\"Arial\"}\r\n     * glue.contexts.update(\"theme\", {font:11})\r\n     *\r\n     * @function\r\n     * @param name Name of the context to be updated\r\n     * @param data The object that will be applied to the context\r\n     */\r\n    public update(name: ContextName, data: any): Promise<void> {\r\n        this.checkName(name);\r\n        this.checkData(data);\r\n\r\n        return this._bridge.update(name, data);\r\n    }\r\n\r\n    /**\r\n     * Replaces a context\r\n     * @function\r\n     * @param name Name of the context to be updated\r\n     * @param data The object that will be applied to the context\r\n     */\r\n    public set(name: ContextName, data: any): Promise<void> {\r\n        this.checkName(name);\r\n        this.checkData(data);\r\n\r\n        return this._bridge.set(name, data);\r\n    }\r\n\r\n    public setPath(name: ContextName, path: string, data: any): Promise<void> {\r\n        this.checkName(name);\r\n        this.checkPath(path);\r\n        const isTopLevelPath = path === \"\";\r\n\r\n        if (isTopLevelPath) {\r\n            // Check the data only in the case of a top level path as the inner props can be of type any.\r\n            this.checkData(data);\r\n\r\n            return this.set(name, data);\r\n        }\r\n\r\n        return this._bridge.setPath(name, path, data);\r\n    }\r\n\r\n    public setPaths(name: ContextName, paths: Glue42Core.Contexts.PathValue[]): Promise<void> {\r\n        this.checkName(name);\r\n\r\n        if (!Array.isArray(paths)) {\r\n            throw new Error(\"Please provide the paths as an array of PathValues!\");\r\n        }\r\n\r\n        for (const { path, value } of paths) {\r\n            this.checkPath(path);\r\n            const isTopLevelPath = path === \"\";\r\n\r\n            if (isTopLevelPath) {\r\n                // Check the value only in the case of a top level path as the inner props can be of type any.\r\n                this.checkData(value);\r\n            }\r\n        }\r\n\r\n        return this._bridge.setPaths(name, paths);\r\n    }\r\n\r\n    /**\r\n     * Subscribe for context events\r\n     *\r\n     * NB: This method publishes an initial snapshot on subscription.\r\n     * To unsubscribe from within the callback, use the unsubscribe argument\r\n     * of the callback, since the method itself may not have returned and the returned\r\n     * callback is not available in the calling code.\r\n     *\r\n     * @function\r\n     *\r\n     * @param name name of the context to subscribe for\r\n     * @param callback function that will receive updates.\r\n     * @returns Function execute the returned function to unsubscribe\r\n     */\r\n    public subscribe(\r\n        name: ContextName,\r\n        callback: (data: any, delta: any, removed: string[], unsubscribe: () => void, extraData?: any) => void): Promise<() => void> {\r\n        this.checkName(name);\r\n        if (typeof callback !== \"function\") {\r\n            throw new Error(\"Please provide the callback as a function!\");\r\n        }\r\n\r\n        return this._bridge\r\n            .subscribe(name, (data: any, delta: any, removed: string[], key: ContextSubscriptionKey, extraData?: any) => callback(data, delta, removed, () => this._bridge.unsubscribe(key), extraData))\r\n            .then((key) =>\r\n                () => {\r\n                    this._bridge.unsubscribe(key);\r\n                });\r\n\r\n    }\r\n\r\n    /**\r\n     * Return a context's data\r\n     */\r\n    public get(name: ContextName): Promise<any> {\r\n        this.checkName(name);\r\n\r\n        return this._bridge.get(name);\r\n    }\r\n\r\n    public ready(): Promise<any> {\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    public destroy(name: string): Promise<any> {\r\n        this.checkName(name);\r\n\r\n        return this._bridge.destroy(name);\r\n    }\r\n\r\n    public get setPathSupported() {\r\n        return this._bridge.setPathSupported;\r\n    }\r\n\r\n    private checkName(name: ContextName) {\r\n        if (typeof name !== \"string\" || name === \"\") {\r\n            throw new Error(\"Please provide the name as a non-empty string!\");\r\n        }\r\n    }\r\n\r\n    private checkPath(path: string) {\r\n        if (typeof path !== \"string\") {\r\n            throw new Error(\"Please provide the path as a dot delimited string!\");\r\n        }\r\n    }\r\n\r\n    // TODO: Update the typings everywhere to disallow strings, numbers, etc.\r\n    private checkData(data: any) {\r\n        // Allows null.\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Please provide the data as an object!\");\r\n        }\r\n    }\r\n}\r\n","export default function <T>(promise: Promise<any>, successCallback: any, errorCallback: any): Promise<T> {\r\n\r\n    if (typeof successCallback !== \"function\" && typeof errorCallback !== \"function\") {\r\n        return promise;\r\n    }\r\n\r\n    if (typeof successCallback !== \"function\") {\r\n        successCallback = () => { /* DO NOTHING */ };\r\n    } else if (typeof errorCallback !== \"function\") {\r\n        errorCallback = () => {  /* DO NOTHING */ };\r\n    }\r\n\r\n    return promise.then(successCallback, errorCallback);\r\n}\r\n","export const waitFor = async (ms: number = 0, callback: () => void) => {\r\n    await resolveAfter(ms);\r\n    callback();\r\n};\r\n\r\nfunction resolveAfter<T>(ms: number = 0, result?: T): Promise<T> {\r\n    return new Promise((resolve) => setTimeout(() => resolve(result), ms));\r\n}\r\n\r\nexport function rejectAfter<T>(ms: number = 0, promise: Promise<T>, error?: T): Promise<T> {\r\n    let timeout: any;\r\n    const clearTimeoutIfThere = () => {\r\n        if (timeout) {\r\n            clearTimeout(timeout);\r\n        }\r\n    };\r\n    promise\r\n        .then(() => {\r\n            clearTimeoutIfThere();\r\n        })\r\n        .catch(() => {\r\n            clearTimeoutIfThere();\r\n        });\r\n\r\n    return new Promise((resolve, reject) => {\r\n        timeout = setTimeout(() => reject(error), ms);\r\n    });\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\n\r\nimport { WrappedCallbackFunction, ResultContext, ServerMethodInfo, ServerSubscriptionInfo } from \"./types\";\r\n\r\nexport default class ServerSubscription implements Glue42Core.AGM.StreamSubscription {\r\n\r\n    constructor(private protocol: Protocol, private repoMethod: ServerMethodInfo, private subscription: ServerSubscriptionInfo) {\r\n    }\r\n\r\n    public get stream(): Glue42Core.AGM.Stream {\r\n        if (!this.repoMethod.stream) {\r\n            throw new Error(\"no stream\");\r\n        }\r\n        return this.repoMethod.stream;\r\n    }\r\n    public get arguments() { return this.subscription.arguments || {}; }\r\n    public get branchKey(): string { return this.subscription.branchKey; }\r\n    public get instance(): Glue42Core.AGM.Instance {\r\n        if (!this.subscription.instance) {\r\n            throw new Error(\"no instance\");\r\n        }\r\n        return this.subscription.instance;\r\n    }\r\n\r\n    public close() {\r\n        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);\r\n    }\r\n\r\n    public push(data: object) {\r\n        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);\r\n    }\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { ServerMethodInfo, RequestContext } from \"./types\";\r\n\r\nexport default class Request implements Glue42Core.AGM.SubscriptionRequest {\r\n    public arguments: object;\r\n    public instance: Glue42Core.AGM.Instance;\r\n\r\n    constructor(private protocol: Protocol, private repoMethod: ServerMethodInfo, private requestContext: RequestContext) {\r\n        this.arguments = requestContext.arguments;\r\n        this.instance = requestContext.instance;\r\n    }\r\n\r\n    public accept() {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, \"\");\r\n    }\r\n\r\n    public acceptOnBranch(branch: string) {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);\r\n    }\r\n\r\n    public reject(reason: string) {\r\n        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);\r\n    }\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { ServerMethodInfo, RequestContext, ServerSubscriptionInfo } from \"./types\";\r\nimport ServerSubscription from \"./subscription\";\r\nimport Server from \"./server\";\r\nimport Request from \"./request\";\r\n\r\n/*\r\n The streaming module defines the user objects relevant to the streaming api, and\r\n attaches to relevant events exposed by the protocol.\r\n */\r\nexport default class ServerStreaming {\r\n    constructor(public protocol: Protocol, private server: Server) {\r\n\r\n        /** Attach to stream 'events' */\r\n        protocol.server.onSubRequest((rc, rm) => this.handleSubRequest(rc, rm));\r\n\r\n        protocol.server.onSubAdded((sub, rm) => this.handleSubAdded(sub, rm));\r\n\r\n        protocol.server.onSubRemoved((sub, rm) => this.handleSubRemoved(sub, rm));\r\n    }\r\n\r\n    private handleSubRequest(requestContext: RequestContext, repoMethod: ServerMethodInfo) {\r\n\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === \"function\")) {\r\n            return;\r\n        }\r\n\r\n        const request = new Request(this.protocol, repoMethod, requestContext);\r\n        repoMethod.streamCallbacks.subscriptionRequestHandler(request);\r\n    }\r\n\r\n    private handleSubAdded(subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === \"function\")) {\r\n            return;\r\n        }\r\n\r\n        const sub = new ServerSubscription(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);\r\n    }\r\n\r\n    private handleSubRemoved(subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === \"function\")) {\r\n            return;\r\n        }\r\n\r\n        const sub = new ServerSubscription(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);\r\n    }\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport ServerSubscription from \"./subscription\";\r\nimport { ServerMethodInfo } from \"./types\";\r\n\r\nexport default class ServerBranch implements Glue42Core.AGM.StreamBranch {\r\n\r\n    constructor(public key: string, private protocol: Protocol, private repoMethod: ServerMethodInfo) {\r\n    }\r\n\r\n    public subscriptions() {\r\n        const subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);\r\n        return subList.map((sub) => {\r\n            return new ServerSubscription(this.protocol, this.repoMethod, sub);\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);\r\n    }\r\n\r\n    public push(data: object) {\r\n        this.protocol.server.pushData(this.repoMethod, data, [this.key]);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { ServerMethodInfo } from \"./types\";\r\nimport ServerSubscription from \"./subscription\";\r\nimport ServerBranch from \"./branch\";\r\nimport Server from \"./server\";\r\n\r\nexport default class ServerStream implements Glue42Core.AGM.Stream {\r\n    public readonly name: string;\r\n\r\n    constructor(private _protocol: Protocol, private _repoMethod: ServerMethodInfo, private _server: Server) {\r\n        this.name = this._repoMethod.definition.name;\r\n    }\r\n\r\n    public branches(): Glue42Core.AGM.StreamBranch[];\r\n    public branches(key: string): Glue42Core.AGM.StreamBranch | undefined;\r\n    public branches(key?: string): Glue42Core.AGM.StreamBranch[] | Glue42Core.AGM.StreamBranch | undefined {\r\n        const bList: string[] = this._protocol.server.getBranchList(this._repoMethod);\r\n        if (key) {\r\n            if (bList.indexOf(key) > -1) {\r\n                return new ServerBranch(key, this._protocol, this._repoMethod);\r\n            }\r\n            return undefined;\r\n\r\n        } else {\r\n            return bList.map((branchKey: string) => {\r\n                return new ServerBranch(branchKey, this._protocol, this._repoMethod);\r\n            });\r\n        }\r\n    }\r\n\r\n    public branch(key: string) {\r\n        return this.branches(key);\r\n    }\r\n\r\n    public subscriptions(): Glue42Core.AGM.StreamSubscription[] {\r\n        const subList = this._protocol.server.getSubscriptionList(this._repoMethod);\r\n        return subList.map((sub) => {\r\n            return new ServerSubscription(this._protocol, this._repoMethod, sub);\r\n        });\r\n    }\r\n\r\n    public get definition(): Glue42Core.AGM.MethodDefinition {\r\n        const def2 = this._repoMethod.definition;\r\n        return {\r\n            accepts: def2.accepts,\r\n            description: def2.description,\r\n            displayName: def2.displayName,\r\n            name: def2.name,\r\n            objectTypes: def2.objectTypes,\r\n            returns: def2.returns,\r\n            supportsStreaming: def2.supportsStreaming,\r\n            flags: def2.flags?.metadata,\r\n        };\r\n    }\r\n\r\n    public close() {\r\n        this._protocol.server.closeAllSubscriptions(this._repoMethod);\r\n        this._server.unregister(this._repoMethod.definition, true);\r\n    }\r\n\r\n    public push(data: object, branches: string[]) {\r\n        if (typeof branches !== \"string\" && !Array.isArray(branches) && branches !== undefined) {\r\n            throw new Error(\"invalid branches should be string or string array\");\r\n        }\r\n        // TODO validate if is plain object\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this._protocol.server.pushData(this._repoMethod, data, branches);\r\n    }\r\n\r\n    public updateRepoMethod(repoMethod: ServerMethodInfo) {\r\n        this._repoMethod = repoMethod;\r\n    }\r\n}\r\n","import promisify from \"../helpers/promisify\";\r\nimport ServerStreaming from \"./streaming\";\r\nimport { Protocol, InteropSettings } from \"../types\";\r\nimport ServerRepository from \"./repository\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { WrappedCallbackFunction, ResultContext, ServerMethodInfo } from \"./types\";\r\nimport ServerStream from \"./stream\";\r\n\r\n/*\r\n The AGM Server allows users register AGM methods.\r\n It exposes these methods to AGM clients (using presence messages) and listens for their invocation\r\n */\r\nexport default class Server {\r\n    private streaming: ServerStreaming;\r\n    private invocations: number = 0;\r\n    private currentlyUnregistering: { [method: string]: Promise<void> } = {};\r\n\r\n    constructor(private protocol: Protocol, private serverRepository: ServerRepository) {\r\n        // An array of the server's methods\r\n        this.streaming = new ServerStreaming(protocol, this);\r\n\r\n        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));\r\n    }\r\n\r\n    // Registers a new streaming agm method\r\n    public createStream(streamDef: string | Glue42Core.AGM.MethodDefinition, callbacks?: Glue42Core.AGM.StreamOptions, successCallback?: (args?: object) => void, errorCallback?: (error?: string | object) => void, existingStream?: ServerStream): Promise<Glue42Core.AGM.Stream> {\r\n        // in callbacks we have subscriptionRequestHandler, subscriptionAddedHandler, subscriptionRemovedHandler\r\n        const promise = new Promise((resolve, reject) => {\r\n            if (!streamDef) {\r\n                reject(`The stream name must be unique! Please, provide either a unique string for a stream name to glue.interop.createStream() or a methodDefinition object with a unique name property for the stream.`);\r\n                return;\r\n            }\r\n\r\n            // transform to a definition\r\n            let streamMethodDefinition: Glue42Core.AGM.MethodDefinition;\r\n\r\n            // This is important because if you change the name for example this will change here as well and it shouldn't change by reference\r\n            if (typeof streamDef === \"string\") {\r\n                streamMethodDefinition = { name: \"\" + streamDef };\r\n            } else {\r\n                streamMethodDefinition = { ...streamDef };\r\n            }\r\n\r\n            if (!streamMethodDefinition.name) {\r\n                return reject(`The name property is required for the streamDefinition object and must be unique. Stream definition: ${JSON.stringify(streamMethodDefinition)}`);\r\n            }\r\n\r\n            const nameAlreadyExists = this.serverRepository.getList()\r\n                .some((serverMethod) => serverMethod.definition.name === streamMethodDefinition.name);\r\n\r\n            if (nameAlreadyExists) {\r\n                return reject(`A stream with the name \"${streamMethodDefinition.name}\" already exists! Please, provide a unique name for the stream.`);\r\n            }\r\n\r\n            streamMethodDefinition.supportsStreaming = true;\r\n\r\n            // User-supplied subscription callbacks\r\n            if (!callbacks) {\r\n                callbacks = {};\r\n            }\r\n\r\n            if (typeof callbacks.subscriptionRequestHandler !== \"function\") {\r\n                callbacks.subscriptionRequestHandler = (request: Glue42Core.AGM.SubscriptionRequest) => {\r\n                    request.accept();\r\n                };\r\n            }\r\n            // Add the method\r\n            const repoMethod = this.serverRepository.add({\r\n                definition: streamMethodDefinition, // store un-formatted definition for checkups in un-register method\r\n                streamCallbacks: callbacks,\r\n                protocolState: {},\r\n            });\r\n\r\n            this.protocol.server.createStream(repoMethod)\r\n                .then(() => {\r\n                    let streamUserObject: ServerStream;\r\n                    if (existingStream) {\r\n                        streamUserObject = existingStream;\r\n                        existingStream.updateRepoMethod(repoMethod);\r\n                    } else {\r\n                        streamUserObject = new ServerStream(this.protocol, repoMethod, this);\r\n                    }\r\n                    repoMethod.stream = streamUserObject;\r\n                    resolve(streamUserObject);\r\n                })\r\n                .catch((err) => {\r\n                    if (repoMethod.repoId) {\r\n                        this.serverRepository.remove(repoMethod.repoId);\r\n                    }\r\n                    reject(err);\r\n                });\r\n        });\r\n\r\n        return promisify(promise, successCallback, errorCallback);\r\n    }\r\n\r\n    /**\r\n     * Registers a new agm method\r\n     * @param {MethodDefinition} methodDefinition\r\n     * @param {MethodHandler} callback Callback that will be called when the AGM server is invoked\r\n     */\r\n\r\n    public register(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: object, caller: Glue42Core.AGM.Instance) => object | Promise<object>): Promise<void> {\r\n        if (!methodDefinition) {\r\n            return Promise.reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n        }\r\n\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(`The second parameter must be a callback function. Method: ${typeof methodDefinition === \"string\" ? methodDefinition : methodDefinition.name}`);\r\n        }\r\n\r\n        const wrappedCallbackFunction: WrappedCallbackFunction = async (context: ResultContext, resultCallback: (err: string | undefined, result: object) => void) => {\r\n            // get the result as direct invocation of the callback and return it using resultCallback\r\n            try {\r\n                const result = callback(context.args, context.instance);\r\n                if (result && typeof (result as any).then === \"function\") {\r\n                    const resultValue = await result;\r\n                    resultCallback(undefined, resultValue);\r\n                } else {\r\n                    resultCallback(undefined, result);\r\n                }\r\n            } catch (e) {\r\n                if (!e) {\r\n                    e = \"\";\r\n                }\r\n                resultCallback(e, e);\r\n            }\r\n        };\r\n\r\n        wrappedCallbackFunction.userCallback = callback;\r\n\r\n        return this.registerCore(methodDefinition, wrappedCallbackFunction);\r\n    }\r\n\r\n    // registers a new async agm method (the result can be returned in async way)\r\n    public registerAsync(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: object, caller: Glue42Core.AGM.Instance, successCallback: (args?: object) => void, errorCallback: (error?: string | object) => void) => Promise<object> | void): Promise<void> {\r\n        if (!methodDefinition) {\r\n            return Promise.reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n        }\r\n\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(`The second parameter must be a callback function. Method: ${typeof methodDefinition === \"string\" ? methodDefinition : methodDefinition.name}`);\r\n        }\r\n\r\n        const wrappedCallback: WrappedCallbackFunction = (context: ResultContext, resultCallback: (err: string | undefined, result: object | undefined) => void) => {\r\n            // invoke the callback passing success and error callbacks\r\n            try {\r\n                let resultCalled = false;\r\n                const success = (result?: object) => {\r\n                    if (!resultCalled) {\r\n                        resultCallback(undefined, result);\r\n                    }\r\n                    resultCalled = true;\r\n                };\r\n                const error = (e: any) => {\r\n                    if (!resultCalled) {\r\n                        if (!e) {\r\n                            e = \"\";\r\n                        }\r\n                        resultCallback(e, e);\r\n                    }\r\n                    resultCalled = true;\r\n                };\r\n\r\n                const methodResult = callback(context.args,\r\n                    context.instance,\r\n                    success,\r\n                    error\r\n                );\r\n\r\n                if (methodResult && typeof methodResult.then === \"function\") {\r\n                    methodResult\r\n                        .then(success)\r\n                        .catch(error);\r\n                }\r\n            } catch (e) {\r\n                resultCallback(e, undefined);\r\n            }\r\n        };\r\n        wrappedCallback.userCallbackAsync = callback;\r\n\r\n        return this.registerCore(methodDefinition, wrappedCallback);\r\n    }\r\n\r\n    // Unregisters a previously registered AGM method\r\n    public async unregister(methodFilter: string | Glue42Core.AGM.MethodDefinition, forStream: boolean = false): Promise<void> {\r\n        if (methodFilter === undefined) {\r\n            return Promise.reject(`Please, provide either a unique string for a name or an object containing a name property.`);\r\n        }\r\n\r\n        // WHEN A FUNCTION IS PASSED\r\n        if (typeof methodFilter === \"function\") {\r\n            await this.unregisterWithPredicate(methodFilter, forStream);\r\n            return;\r\n        }\r\n\r\n        // WHEN string / object is passed\r\n        let methodDefinition: Glue42Core.AGM.MethodDefinition;\r\n        if (typeof methodFilter === \"string\") {\r\n            methodDefinition = { name: methodFilter };\r\n        } else {\r\n            methodDefinition = methodFilter;\r\n        }\r\n\r\n        if (methodDefinition.name === undefined) {\r\n            return Promise.reject(`Method name is required. Cannot find a method if the method name is undefined!`);\r\n        }\r\n\r\n        const methodToBeRemoved: ServerMethodInfo | undefined = this.serverRepository.getList().find((serverMethod) => {\r\n            return serverMethod.definition.name === methodDefinition.name\r\n                && (serverMethod.definition.supportsStreaming || false) === forStream;\r\n            // return this.containsProps(methodFilter, method.definition);\r\n        });\r\n\r\n        if (!methodToBeRemoved) {\r\n            return Promise.reject(`Method with a name \"${methodDefinition.name}\" does not exist or is not registered by your application!`);\r\n        }\r\n\r\n        await this.removeMethodsOrStreams([methodToBeRemoved]);\r\n    }\r\n\r\n    private async unregisterWithPredicate(filterPredicate: (methodDefinition: Glue42Core.AGM.MethodDefinition) => ServerMethodInfo, forStream?: boolean) {\r\n        const methodsOrStreamsToRemove = this.serverRepository.getList()\r\n            .filter((sm) => filterPredicate(sm.definition))\r\n            .filter((serverMethod) =>\r\n                // because both can be undefined or false\r\n                (serverMethod.definition.supportsStreaming || false) === forStream\r\n            );\r\n\r\n        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {\r\n            return Promise.reject(`Could not find a ${forStream ? \"stream\" : \"method\"} matching the specified condition!`);\r\n        }\r\n\r\n        await this.removeMethodsOrStreams(methodsOrStreamsToRemove);\r\n    }\r\n\r\n    private removeMethodsOrStreams(methodsToRemove: ServerMethodInfo[]) {\r\n        const methodUnregPromises: Array<Promise<void>> = [];\r\n\r\n        methodsToRemove.forEach((method) => {\r\n            const promise = this.protocol.server.unregister(method)\r\n                .then(() => {\r\n                    if (method.repoId) {\r\n                        this.serverRepository.remove(method.repoId);\r\n                    }\r\n                });\r\n\r\n            methodUnregPromises.push(promise);\r\n            this.addAsCurrentlyUnregistering(method.definition.name, promise);\r\n        });\r\n\r\n        return Promise.all(methodUnregPromises);\r\n    }\r\n\r\n    private async addAsCurrentlyUnregistering(methodName: string, promise: Promise<void>) {\r\n        const timeout = new Promise((resolve) => setTimeout(resolve, 5000));\r\n\r\n        // will be cleared when promise resolved\r\n        this.currentlyUnregistering[methodName] = Promise.race([promise, timeout]).then(() => {\r\n            delete this.currentlyUnregistering[methodName];\r\n        });\r\n    }\r\n\r\n    // Core method for registering agm method\r\n    private async registerCore(method: string | Glue42Core.AGM.MethodDefinition, theFunction: WrappedCallbackFunction): Promise<void> {\r\n        // transform to a definition\r\n        let methodDefinition: Glue42Core.AGM.MethodDefinition;\r\n\r\n        // This is important because if you change the name for example this will change here as well and it shouldn't change by reference\r\n        if (typeof method === \"string\") {\r\n            methodDefinition = { name: \"\" + method };\r\n        } else {\r\n            methodDefinition = { ...method };\r\n        }\r\n\r\n        if (!methodDefinition.name) {\r\n            return Promise.reject(`Please, provide a (unique) string value for the name property in the methodDefinition object: ${JSON.stringify(method)}`);\r\n        }\r\n\r\n        const unregisterInProgress = this.currentlyUnregistering[methodDefinition.name];\r\n        if (unregisterInProgress) {\r\n            await unregisterInProgress;\r\n        }\r\n\r\n        const nameAlreadyExists = this.serverRepository.getList()\r\n            .some((serverMethod) => serverMethod.definition.name === methodDefinition.name);\r\n\r\n        if (nameAlreadyExists) {\r\n            return Promise.reject(`A method with the name \"${methodDefinition.name}\" already exists! Please, provide a unique name for the method.`);\r\n        }\r\n\r\n        if (methodDefinition.supportsStreaming) {\r\n            return Promise.reject(`When you create methods with glue.interop.register() or glue.interop.registerAsync() the property supportsStreaming cannot be true. If you want ${methodDefinition.name} to be a stream, please use the glue.interop.createStream() method.`);\r\n        }\r\n\r\n        // Add the method ()\r\n        const repoMethod = this.serverRepository.add({\r\n            definition: methodDefinition, // store un-formatted definition for checkups in un-register method\r\n            theFunction,\r\n            protocolState: {},\r\n        });\r\n\r\n        // make it then .catch for those error/success callbacks\r\n        return this.protocol.server.register(repoMethod)\r\n            .catch((err: any) => {\r\n                if (repoMethod?.repoId) {\r\n                    this.serverRepository.remove(repoMethod.repoId);\r\n                }\r\n                throw err;\r\n            });\r\n    }\r\n\r\n    private onMethodInvoked(methodToExecute: ServerMethodInfo, invocationId: string, invocationArgs: ResultContext) {\r\n        if (!methodToExecute || !methodToExecute.theFunction) {\r\n            return;\r\n        }\r\n\r\n        // Execute it and save the result\r\n        methodToExecute.theFunction(invocationArgs, (err: any, result) => {\r\n            if (err !== undefined && err !== null) {\r\n                // handle error case\r\n                if (err.message && typeof err.message === \"string\") {\r\n                    err = err.message;\r\n                } else if (typeof err !== \"string\") {\r\n                    try {\r\n                        err = JSON.stringify(err);\r\n                    } catch (unStrException) {\r\n                        err = `un-stringifyable error in onMethodInvoked! Top level prop names: ${Object.keys(err)}`;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!result) {\r\n                result = {};\r\n            } else if (typeof result !== \"object\" || Array.isArray(result)) {\r\n                // The AGM library only transfers objects. If the result is not an object, put it in one\r\n                result = { _value: result };\r\n            }\r\n\r\n            this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);\r\n        });\r\n    }\r\n}\r\n","import generate from \"shortid\";\r\nimport { Glue42Core } from \"./../../glue\";\r\n\r\nexport class InstanceWrapper {\r\n    private wrapped: Glue42Core.Interop.Instance = {};\r\n\r\n    constructor(API: Glue42Core.AGM.API, instance?: Glue42Core.AGM.Instance, connection?: Glue42Core.Connection.API) {\r\n        this.wrapped.getMethods = function (): Glue42Core.Interop.Method[] {\r\n            return API.methodsForInstance(this);\r\n        };\r\n        this.wrapped.getStreams = function (): Glue42Core.Interop.Method[] {\r\n            return API.methodsForInstance(this).filter((m) => m.supportsStreaming);\r\n        };\r\n\r\n        if (instance) {\r\n            this.refreshWrappedObject(instance);\r\n        }\r\n        if (connection) {\r\n            connection.loggedIn(() => {\r\n                this.refresh(connection);\r\n            });\r\n            this.refresh(connection);\r\n        }\r\n    }\r\n\r\n    public unwrap(): Glue42Core.Interop.Instance {\r\n        return this.wrapped;\r\n    }\r\n\r\n    private refresh(connection: Glue42Core.Connection.API) {\r\n        if (!connection) {\r\n            return;\r\n        }\r\n\r\n        // Apply resolved identity (GW3 case)\r\n        const resolvedIdentity = connection?.resolvedIdentity;\r\n        const instance = Object.assign({}, resolvedIdentity ?? {}, { peerId: connection?.peerId });\r\n        this.refreshWrappedObject(instance);\r\n    }\r\n\r\n    private refreshWrappedObject(resolvedIdentity: Glue42Core.Interop.Instance) {\r\n        this.wrapped.user = resolvedIdentity.user;\r\n        this.wrapped.instance = resolvedIdentity.instance;\r\n        this.wrapped.application = resolvedIdentity.application ?? generate();\r\n        this.wrapped.applicationName = resolvedIdentity.applicationName;\r\n        this.wrapped.pid = resolvedIdentity.pid ?? (resolvedIdentity as any).process ?? Math.floor(Math.random() * 10000000000);\r\n        this.wrapped.machine = resolvedIdentity.machine;\r\n        this.wrapped.environment = resolvedIdentity.environment;\r\n        this.wrapped.region = resolvedIdentity.region;\r\n        this.wrapped.windowId = resolvedIdentity.windowId;\r\n        this.wrapped.isLocal = resolvedIdentity.isLocal ?? true;\r\n        this.wrapped.api = resolvedIdentity.api;\r\n        this.wrapped.service = resolvedIdentity.service;\r\n        this.wrapped.peerId = resolvedIdentity.peerId;\r\n    }\r\n}\r\n","/*\r\n * Repository holding servers and methods visible by this peer including those created by the peer itself.\r\n */\r\nimport { default as CallbackRegistryFactory, UnsubscribeFunction } from \"callback-registry\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { ClientMethodInfo, ServerInfo } from \"./types\";\r\nimport { MethodInfoMessage } from \"../protocols/gw3/messages\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport { InstanceWrapper } from \"../instance\";\r\nimport Client from \"./client\";\r\n\r\nconst hideMethodSystemFlags = (method: ClientMethodInfo): ClientMethodInfo => {\r\n    return {\r\n        ...method,\r\n        flags: method.flags.metadata || {}\r\n    };\r\n};\r\n\r\nexport default class ClientRepository {\r\n\r\n    // each server has format {id:'', info:{}, methods:{}}\r\n    // where methods has format {id:'', info:{}}\r\n    private servers: { [id: string]: ServerInfo } = {};\r\n    private myServer: ServerInfo;\r\n\r\n    // object keyed by method identifier - value is number of servers that offer that method\r\n    private methodsCount: { [id: string]: number } = {};\r\n\r\n    // store for callbacks\r\n    private callbacks = CallbackRegistryFactory();\r\n\r\n    constructor(private logger: Logger, private API: Glue42Core.AGM.API & { unwrappedInstance: InstanceWrapper }) {\r\n        const peerId = this.API.instance.peerId as string;\r\n        this.myServer = {\r\n            id: peerId,\r\n            methods: {},\r\n            instance: this.API.instance,\r\n            wrapper: this.API.unwrappedInstance,\r\n        };\r\n        this.servers[peerId] = this.myServer;\r\n    }\r\n\r\n    // add a new server to internal collection\r\n    public addServer(info: Glue42Core.AGM.Instance, serverId: string): string {\r\n        this.logger.debug(`adding server ${serverId}`);\r\n\r\n        const current = this.servers[serverId];\r\n        if (current) {\r\n            return current.id;\r\n        }\r\n\r\n        const wrapper = new InstanceWrapper(this.API, info);\r\n        const serverEntry: ServerInfo = {\r\n            id: serverId,\r\n            methods: {},\r\n            instance: wrapper.unwrap(),\r\n            wrapper,\r\n        };\r\n\r\n        this.servers[serverId] = serverEntry;\r\n        this.callbacks.execute(\"onServerAdded\", serverEntry.instance);\r\n        return serverId;\r\n    }\r\n\r\n    public removeServerById(id: string, reason?: string) {\r\n        const server = this.servers[id];\r\n        if (!server) {\r\n            // tslint:disable-next-line:no-console\r\n            this.logger.warn(`not aware of server ${id}, my state ${JSON.stringify(Object.keys(this.servers))}`);\r\n            return;\r\n        } else {\r\n            // tslint:disable-next-line:no-console\r\n            this.logger.debug(`removing server ${id}`);\r\n        }\r\n\r\n        Object.keys(server.methods).forEach((methodId) => {\r\n            this.removeServerMethod(id, methodId);\r\n        });\r\n\r\n        delete this.servers[id];\r\n        this.callbacks.execute(\"onServerRemoved\", server.instance, reason);\r\n    }\r\n\r\n    public addServerMethod(serverId: string, method: MethodInfoMessage) {\r\n\r\n        const server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n\r\n        // server already has that method\r\n        if (server.methods[method.id]) {\r\n            return;\r\n        }\r\n\r\n        const identifier = this.createMethodIdentifier(method);\r\n        const that = this;\r\n        const methodDefinition: ClientMethodInfo = {\r\n            identifier,\r\n            gatewayId: method.id,\r\n            name: method.name,\r\n            displayName: method.display_name,\r\n            description: method.description,\r\n            version: method.version,\r\n            objectTypes: method.object_types || [],\r\n            accepts: method.input_signature,\r\n            returns: method.result_signature,\r\n            supportsStreaming: typeof method.flags !== \"undefined\" ? method.flags.streaming : false,\r\n            flags: method.flags ?? {},\r\n            getServers: () => {\r\n                return that.getServersByMethod(identifier);\r\n            }\r\n        };\r\n        // now add some legacy stuff\r\n        (methodDefinition as any).object_types = methodDefinition.objectTypes;\r\n        (methodDefinition as any).display_name = methodDefinition.displayName;\r\n        (methodDefinition as any).version = methodDefinition.version;\r\n\r\n        server.methods[method.id] = methodDefinition;\r\n\r\n        const clientMethodDefinition = hideMethodSystemFlags(methodDefinition);\r\n\r\n        // increase the ref and notify listeners\r\n        if (!this.methodsCount[identifier]) {\r\n            this.methodsCount[identifier] = 0;\r\n            this.callbacks.execute(\"onMethodAdded\", clientMethodDefinition);\r\n        }\r\n        this.methodsCount[identifier] = this.methodsCount[identifier] + 1;\r\n\r\n        this.callbacks.execute(\"onServerMethodAdded\", server.instance, clientMethodDefinition);\r\n        return methodDefinition;\r\n    }\r\n\r\n    public removeServerMethod(serverId: string, methodId: string) {\r\n        const server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n\r\n        const method = server.methods[methodId];\r\n        delete server.methods[methodId];\r\n\r\n        const clientMethodDefinition = hideMethodSystemFlags(method);\r\n\r\n        // update ref counting\r\n        this.methodsCount[method.identifier] = this.methodsCount[method.identifier] - 1;\r\n        if (this.methodsCount[method.identifier] === 0) {\r\n            this.callbacks.execute(\"onMethodRemoved\", clientMethodDefinition);\r\n        }\r\n\r\n        this.callbacks.execute(\"onServerMethodRemoved\", server.instance, clientMethodDefinition);\r\n    }\r\n\r\n    public getMethods(): ClientMethodInfo[] {\r\n        return this.extractMethodsFromServers(Object.values(this.servers)).map(hideMethodSystemFlags);\r\n    }\r\n\r\n    public getServers(): ServerInfo[] {\r\n        return Object.values(this.servers).map(this.hideServerMethodSystemFlags);\r\n    }\r\n\r\n    public onServerAdded(callback: (server: Glue42Core.Interop.Instance) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerAdded\", callback);\r\n\r\n        // because we need the servers shapshot before we exist this stack\r\n        const serversWithMethodsToReplay = this.getServers().map((s) => s.instance);\r\n\r\n        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, serversWithMethodsToReplay, callback);\r\n    }\r\n\r\n    public onMethodAdded(callback: (method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onMethodAdded\", callback);\r\n\r\n        // because we need the servers snapshot before we return to the application code\r\n        const methodsToReplay = this.getMethods();\r\n\r\n        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, methodsToReplay, callback);\r\n    }\r\n\r\n    public onServerMethodAdded(callback: (server: Glue42Core.AGM.Instance, method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerMethodAdded\", callback);\r\n\r\n        // because we want to interrupt the loop with the existing methods\r\n        let unsubCalled = false;\r\n\r\n        // because we need the servers shapshot before we return to the application code\r\n        const servers = this.getServers();\r\n\r\n        // because we want to have the unsub function before the callback is called with all existing methods\r\n        setTimeout(() => {\r\n            servers.forEach((server) => {\r\n                const methods = server.methods;\r\n                Object.keys(methods).forEach((methodId) => {\r\n                    if (!unsubCalled) {\r\n                        callback(server.instance, methods[methodId]);\r\n                    }\r\n                });\r\n            });\r\n        }, 0);\r\n\r\n        return () => {\r\n            unsubCalled = true;\r\n            unsubscribeFunc();\r\n        };\r\n    }\r\n\r\n    public onMethodRemoved(callback: (method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onMethodRemoved\", callback);\r\n\r\n        return unsubscribeFunc;\r\n    }\r\n\r\n    public onServerRemoved(callback: (server: Glue42Core.Interop.Instance, reason: string) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerRemoved\", callback);\r\n\r\n        return unsubscribeFunc;\r\n    }\r\n\r\n    public onServerMethodRemoved(callback: (server: Glue42Core.Interop.Instance, method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerMethodRemoved\", callback);\r\n\r\n        return unsubscribeFunc;\r\n    }\r\n\r\n    public getServerById(id: string) {\r\n        return this.hideServerMethodSystemFlags(this.servers[id]);\r\n    }\r\n\r\n    public reset() {\r\n        Object.keys(this.servers).forEach((key) => {\r\n            this.removeServerById(key, \"reset\");\r\n        });\r\n        this.servers = {\r\n            [this.myServer.id]: this.myServer\r\n        };\r\n        this.methodsCount = {};\r\n    }\r\n\r\n    private createMethodIdentifier(methodInfo: MethodInfoMessage) {\r\n        // Setting properties to defaults:\r\n        const accepts = methodInfo.input_signature !== undefined ? methodInfo.input_signature : \"\";\r\n        const returns = methodInfo.result_signature !== undefined ? methodInfo.result_signature : \"\";\r\n        return (methodInfo.name + accepts + returns).toLowerCase();\r\n    }\r\n\r\n    private getServersByMethod(identifier: string): Glue42Core.AGM.Instance[] {\r\n        const allServers: Glue42Core.AGM.Instance[] = [];\r\n        Object.values(this.servers).forEach((server) => {\r\n            Object.values(server.methods).forEach((method) => {\r\n                if (method.identifier === identifier) {\r\n                    allServers.push(server.instance);\r\n                }\r\n            });\r\n        });\r\n        return allServers;\r\n    }\r\n\r\n    // collectionToReplay: because we need a snapshot before we exist this stack\r\n    private returnUnsubWithDelayedReplay(unsubscribeFunc: UnsubscribeFunction, collectionToReplay: any[], callback: any) {\r\n\r\n        // because we want to interrupt the loop with the existing methods\r\n        let unsubCalled = false;\r\n\r\n        // because we want to have the unsub function before the callback is called with all existing methods\r\n        setTimeout(() => {\r\n            collectionToReplay.forEach((item) => {\r\n                if (!unsubCalled) {\r\n                    callback(item);\r\n                }\r\n            });\r\n        }, 0);\r\n\r\n        return () => {\r\n            unsubCalled = true;\r\n            unsubscribeFunc();\r\n        };\r\n    }\r\n\r\n    private hideServerMethodSystemFlags(server: ServerInfo): ServerInfo {\r\n        const clientMethods: { [name: string]: ClientMethodInfo } = {};\r\n\r\n        Object.entries(server.methods).forEach(([name, method]) => {\r\n            clientMethods[name] = hideMethodSystemFlags(method);\r\n        });\r\n\r\n        return {\r\n            ...server,\r\n            methods: clientMethods\r\n        };\r\n    }\r\n\r\n    private extractMethodsFromServers(servers: ServerInfo[]): ClientMethodInfo[] {\r\n        const methods = Object.values(servers).reduce<ClientMethodInfo[]>((clientMethods, server) => {\r\n            return [...clientMethods, ...Object.values(server.methods)];\r\n        }, []);\r\n\r\n        return methods;\r\n    }\r\n}\r\n","/*\r\n * A store for holding method back-objects registered by this instance's server\r\n */\r\nimport { ServerMethodInfo } from \"./types\";\r\n\r\nexport default class ServerRepository {\r\n\r\n    private nextId = 0;\r\n    private methods: ServerMethodInfo[] = [];\r\n\r\n    public add(method: Partial<ServerMethodInfo>): ServerMethodInfo {\r\n        method.repoId = String(this.nextId);\r\n        this.nextId += 1;\r\n        this.methods.push(method as ServerMethodInfo);\r\n        return method as ServerMethodInfo;\r\n    }\r\n\r\n    public remove(repoId: string) {\r\n        if (typeof repoId !== \"string\") {\r\n            return new TypeError(\"Expecting a string\");\r\n        }\r\n\r\n        this.methods = this.methods.filter((m) => {\r\n            return m.repoId !== repoId;\r\n        });\r\n    }\r\n\r\n    public getById(id: string): ServerMethodInfo | undefined {\r\n        if (typeof id !== \"string\") {\r\n            return undefined;\r\n        }\r\n\r\n        return this.methods.find((m) => {\r\n            return m.repoId === id;\r\n        });\r\n    }\r\n\r\n    public getList() {\r\n        return this.methods.map((m) => m);\r\n    }\r\n\r\n    public length() {\r\n        return this.methods.length;\r\n    }\r\n\r\n    public reset() {\r\n        this.methods = [];\r\n    }\r\n}\r\n","import { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport { RequestContext, ServerMethodInfo, ServerSubscriptionInfo } from \"../../server/types\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport ServerRepository from \"../../server/repository\";\r\nimport {\r\n    AddInterestMessage,\r\n    PublishMessage,\r\n    PostMessage,\r\n    DropSubscriptionMessage,\r\n    RemoveInterestMessage\r\n} from \"./messages\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport { Logger } from \"../../../logger/logger\";\r\n\r\nconst SUBSCRIPTION_REQUEST = \"onSubscriptionRequest\";\r\nconst SUBSCRIPTION_ADDED = \"onSubscriptionAdded\";\r\nconst SUBSCRIPTION_REMOVED = \"onSubscriptionRemoved\";\r\n\r\n/**\r\n * Handles registering methods and sending data to clients\r\n */\r\nexport default class ServerStreaming {\r\n\r\n    private ERR_URI_SUBSCRIPTION_FAILED = \"com.tick42.agm.errors.subscription.failure\";\r\n    private callbacks = CallbackRegistryFactory();\r\n    private nextStreamId = 0;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private repository: ClientRepository, private serverRepository: ServerRepository) {\r\n        session.on(\"add-interest\", (msg: AddInterestMessage) => {\r\n            this.handleAddInterest(msg);\r\n        });\r\n        session.on(\"remove-interest\", (msg: RemoveInterestMessage) => {\r\n            this.handleRemoveInterest(msg);\r\n        });\r\n    }\r\n\r\n    public acceptRequestOnBranch(requestContext: RequestContext, streamingMethod: ServerMethodInfo, branch: string) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            throw new TypeError(\"The streaming method is missing its subscriptions.\");\r\n        }\r\n\r\n        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            throw new TypeError(\"The streaming method is missing its branches.\");\r\n        }\r\n\r\n        const streamId = this.getStreamId(streamingMethod, branch);\r\n\r\n        // Add a new subscription to the method\r\n        const key = requestContext.msg.subscription_id;\r\n\r\n        const subscription: ServerSubscriptionInfo = {\r\n            id: key,\r\n            arguments: requestContext.arguments,\r\n            instance: requestContext.instance,\r\n            branchKey: branch,\r\n            streamId,\r\n            subscribeMsg: requestContext.msg,\r\n        };\r\n\r\n        streamingMethod.protocolState.subscriptionsMap[key] = subscription;\r\n\r\n        // Inform the gw\r\n        this.session.sendFireAndForget({\r\n            type: \"accepted\",\r\n            subscription_id: key,\r\n            stream_id: streamId,\r\n        });\r\n\r\n        // Pass state above-protocol for user objects\r\n        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);\r\n    }\r\n\r\n    public rejectRequest(requestContext: RequestContext, streamingMethod: ServerMethodInfo, reason: string) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n\r\n        this.sendSubscriptionFailed(\r\n            \"Subscription rejected by user. \" + reason,\r\n            requestContext.msg.subscription_id,\r\n        );\r\n    }\r\n\r\n    public pushData(streamingMethod: ServerMethodInfo, data: object, branches: string | string[]) {\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n\r\n        // TODO validate data is a plain object\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches]; // user wants to push to single branch\r\n        } else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = [];\r\n        }\r\n\r\n        // get the StreamId's from the method's branch map\r\n        const streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter((br) => {\r\n                if (!branches || branches.length === 0) {\r\n                    return true;\r\n                }\r\n                return branches.indexOf(br.key) >= 0;\r\n            }).map((br) => {\r\n                return br.streamId;\r\n            });\r\n\r\n        // if (streamIdList.length === 0) {\r\n        //     throw new Error(\"0 branches exist with the supplied name/s !\");\r\n        // }\r\n\r\n        streamIdList.forEach((streamId) => {\r\n            const publishMessage: PublishMessage = {\r\n                type: \"publish\",\r\n                stream_id: streamId,\r\n                // sequence: null,  // the streamingMethod might be used for this\r\n                // snapshot: false, // ...and this\r\n                data,\r\n            };\r\n\r\n            this.session.sendFireAndForget(publishMessage);\r\n        });\r\n    }\r\n\r\n    public pushDataToSingle(method: ServerMethodInfo, subscription: ServerSubscriptionInfo, data: object) {\r\n        // TODO validate data is a plain object\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n\r\n        const postMessage: PostMessage = {\r\n            type: \"post\",\r\n            subscription_id: subscription.id,\r\n            // sequence: null,  // the streamingMethod might be used for this\r\n            // snapshot: false, // ...and this\r\n            data,\r\n        };\r\n\r\n        this.session.sendFireAndForget(postMessage);\r\n    }\r\n\r\n    public closeSingleSubscription(streamingMethod: ServerMethodInfo, subscription: ServerSubscriptionInfo) {\r\n\r\n        if (streamingMethod.protocolState.subscriptionsMap) {\r\n            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n        }\r\n\r\n        const dropSubscriptionMessage: DropSubscriptionMessage = {\r\n            type: \"drop-subscription\",\r\n            subscription_id: subscription.id,\r\n            reason: \"Server dropping a single subscription\",\r\n        };\r\n\r\n        this.session.sendFireAndForget(dropSubscriptionMessage);\r\n\r\n        const subscriber = subscription.instance;\r\n\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    }\r\n\r\n    public closeMultipleSubscriptions(streamingMethod: ServerMethodInfo, branchKey?: string) {\r\n        if (typeof streamingMethod !== \"object\" || typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            return;\r\n        }\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return;\r\n        }\r\n\r\n        const subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n        let subscriptionsToClose = Object.keys(subscriptionsMap)\r\n            .map((key) => {\r\n                return subscriptionsMap[key];\r\n            });\r\n\r\n        if (typeof branchKey === \"string\") {\r\n            subscriptionsToClose = subscriptionsToClose.filter((sub) => {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n\r\n        subscriptionsToClose.forEach((subscription) => {\r\n            delete subscriptionsMap[subscription.id];\r\n\r\n            const drop: DropSubscriptionMessage = {\r\n                type: \"drop-subscription\",\r\n                subscription_id: subscription.id,\r\n                reason: \"Server dropping all subscriptions on stream_id: \" + subscription.streamId,\r\n            };\r\n            this.session.sendFireAndForget(drop);\r\n        });\r\n    }\r\n\r\n    public getSubscriptionList(streamingMethod: ServerMethodInfo, branchKey?: string): ServerSubscriptionInfo[] {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n\r\n        let subscriptions = [];\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return [];\r\n        }\r\n        const subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n\r\n        const allSubscriptions = Object.keys(subscriptionsMap)\r\n            .map((key) => {\r\n                return subscriptionsMap[key];\r\n            });\r\n\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = allSubscriptions;\r\n        } else {\r\n            subscriptions = allSubscriptions.filter((sub) => {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n\r\n        return subscriptions;\r\n    }\r\n\r\n    public getBranchList(streamingMethod: ServerMethodInfo): string[] {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return [];\r\n        }\r\n        const subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n\r\n        const allSubscriptions =\r\n            Object.keys(subscriptionsMap)\r\n                .map((key) => {\r\n                    return subscriptionsMap[key];\r\n                });\r\n\r\n        const result: string[] = [];\r\n        allSubscriptions.forEach((sub) => {\r\n            let branch = \"\";\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                branch = sub.branchKey;\r\n            }\r\n\r\n            if (result.indexOf(branch) === -1) {\r\n                result.push(branch);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    public onSubAdded(callback: (subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);\r\n    }\r\n\r\n    public onSubRequest(callback: (requestContext: RequestContext, repoMethod: ServerMethodInfo) => void) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);\r\n    }\r\n\r\n    public onSubRemoved(callback: (subscriber: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);\r\n    }\r\n\r\n    private handleRemoveInterest(msg: RemoveInterestMessage) {\r\n        const streamingMethod = this.serverRepository.getById(msg.method_id);\r\n\r\n        if (typeof msg.subscription_id !== \"string\" ||\r\n            typeof streamingMethod !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return;\r\n        }\r\n\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        const subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n\r\n        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    }\r\n\r\n    private onSubscriptionLifetimeEvent(eventName: string, handlerFunc: any) {\r\n        this.callbacks.add(eventName, handlerFunc);\r\n    }\r\n\r\n    private getNextStreamId(): string {\r\n        return this.nextStreamId++ + \"\";\r\n    }\r\n\r\n    /**\r\n     * Processes a subscription request\r\n     */\r\n    private handleAddInterest(msg: AddInterestMessage) {\r\n\r\n        const caller = this.repository.getServerById(msg.caller_id);\r\n        const instance = caller.instance;\r\n\r\n        // call subscriptionRequestHandler\r\n        const requestContext: RequestContext = {\r\n            msg,\r\n            arguments: msg.arguments_kv || {},\r\n            instance,\r\n        };\r\n\r\n        const streamingMethod = this.serverRepository.getById(msg.method_id);\r\n\r\n        if (streamingMethod === undefined) {\r\n            const errorMsg = \"No method with id \" + msg.method_id + \" on this server.\";\r\n            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);\r\n            return;\r\n        }\r\n\r\n        if (streamingMethod.protocolState.subscriptionsMap &&\r\n            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {\r\n            this.sendSubscriptionFailed(\"A subscription with id \" + msg.subscription_id + \" already exists.\",\r\n                msg.subscription_id,\r\n            );\r\n            return;\r\n        }\r\n\r\n        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);\r\n    }\r\n\r\n    private sendSubscriptionFailed(reason: string, subscriptionId: string) {\r\n        const errorMessage = {\r\n            type: \"error\",\r\n            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,\r\n            reason,\r\n            request_id: subscriptionId, // this overrides connection wrapper\r\n        };\r\n\r\n        this.session.sendFireAndForget(errorMessage);\r\n    }\r\n\r\n    private getStreamId(streamingMethod: ServerMethodInfo, branchKey: string) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n\r\n        if (!streamingMethod.protocolState.branchKeyToStreamIdMap) {\r\n            throw new Error(`streaming ${streamingMethod.definition.name} method without protocol state`);\r\n        }\r\n\r\n        const needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter((branch) => {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n\r\n        let streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.getNextStreamId();\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId });\r\n        }\r\n\r\n        return streamId;\r\n    }\r\n}\r\n","import { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport ServerStreaming from \"./server-streaming\";\r\nimport {\r\n    InvokeMessage,\r\n    RegisterMethodMessage,\r\n    ErrorMessage,\r\n    YieldMessage,\r\n    UnregisterMessage,\r\n    TaggedMessage\r\n} from \"./messages\";\r\nimport ServerRepository from \"../../server/repository\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport { ServerMethodInfo, ResultContext, ServerSubscriptionInfo, RequestContext } from \"../../server/types\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport { ServerProtocolDefinition } from \"../../types\";\r\nimport { Logger } from \"../../../logger/logger\";\r\n\r\nexport default class ServerProtocol implements ServerProtocolDefinition {\r\n    private callbacks: CallbackRegistry = CallbackRegistryFactory();\r\n    private streaming: ServerStreaming;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private clientRepository: ClientRepository, private serverRepository: ServerRepository, private logger: Logger) {\r\n        this.streaming = new ServerStreaming(session, clientRepository, serverRepository);\r\n        this.session.on(\"invoke\", (msg: InvokeMessage) => this.handleInvokeMessage(msg));\r\n    }\r\n\r\n    public createStream(repoMethod: ServerMethodInfo): Promise<void> {\r\n        // Utility things for this protocol\r\n        repoMethod.protocolState.subscriptionsMap = {}; // ~subscription_id~ : {id:~, branchKey: '~', arguments: {~}, instance:{~}, etc.}\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = []; // [ {branchKey: '', streamId: 7}, {...}, ...]\r\n\r\n        return this.register(repoMethod, true);\r\n    }\r\n\r\n    public register(repoMethod: ServerMethodInfo, isStreaming?: boolean): Promise<void> {\r\n        const methodDef = repoMethod.definition;\r\n        const flags = Object.assign({}, { metadata: methodDef.flags ?? {} }, { streaming: isStreaming || false });\r\n\r\n        const registerMsg: RegisterMethodMessage = {\r\n            type: \"register\",\r\n            methods: [{\r\n                id: repoMethod.repoId,\r\n                name: methodDef.name,\r\n                display_name: methodDef.displayName,\r\n                description: methodDef.description,\r\n                version: methodDef.version,\r\n                flags,\r\n                object_types: methodDef.objectTypes || (methodDef as any).object_types, // object_type for backward compatibility\r\n                input_signature: methodDef.accepts,\r\n                result_signature: methodDef.returns,\r\n                restrictions: undefined,\r\n            }],\r\n        };\r\n\r\n        return this.session.send(registerMsg, { methodId: repoMethod.repoId })\r\n            .then(() => {\r\n                this.logger.debug(\"registered method \" + repoMethod.definition.name + \" with id \" + repoMethod.repoId);\r\n            })\r\n            .catch((msg: ErrorMessage) => {\r\n                this.logger.warn(`failed to register method ${repoMethod.definition.name} with id ${repoMethod.repoId} - ${JSON.stringify(msg)}`);\r\n                throw msg;\r\n            });\r\n    }\r\n\r\n    public onInvoked(callback: (methodToExecute: ServerMethodInfo, invocationId: string, invocationArgs: ResultContext) => void) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    }\r\n\r\n    public methodInvocationResult(method: ServerMethodInfo, invocationId: string, err: string, result: object) {\r\n        let msg: YieldMessage | ErrorMessage;\r\n        if (err || err === \"\") {\r\n            msg = {\r\n                type: \"error\",\r\n                request_id: invocationId,\r\n                reason_uri: \"agm.errors.client_error\",\r\n                reason: err,\r\n                context: result,\r\n                peer_id: undefined,\r\n            };\r\n        } else {\r\n            msg = {\r\n                type: \"yield\",\r\n                invocation_id: invocationId,\r\n                peer_id: this.session.peerId,\r\n                result,\r\n                request_id: undefined,\r\n            };\r\n        }\r\n        this.session.sendFireAndForget(msg);\r\n    }\r\n\r\n    public async unregister(method: ServerMethodInfo): Promise<void> {\r\n        const msg: UnregisterMessage = {\r\n            type: \"unregister\",\r\n            methods: [method.repoId],\r\n        };\r\n\r\n        await this.session.send(msg);\r\n    }\r\n\r\n    public getBranchList(method: ServerMethodInfo): string[] {\r\n        return this.streaming.getBranchList(method);\r\n    }\r\n\r\n    public getSubscriptionList(method: ServerMethodInfo, branchKey?: string): ServerSubscriptionInfo[] {\r\n        return this.streaming.getSubscriptionList(method, branchKey);\r\n    }\r\n\r\n    public closeAllSubscriptions(method: ServerMethodInfo, branchKey?: string): void {\r\n        this.streaming.closeMultipleSubscriptions(method, branchKey);\r\n    }\r\n\r\n    public pushData(method: ServerMethodInfo, data: object, branches: string[]): void {\r\n        this.streaming.pushData(method, data, branches);\r\n    }\r\n\r\n    public pushDataToSingle(method: ServerMethodInfo, subscription: ServerSubscriptionInfo, data: object): void {\r\n        this.streaming.pushDataToSingle(method, subscription, data);\r\n    }\r\n\r\n    public closeSingleSubscription(method: ServerMethodInfo, subscription: ServerSubscriptionInfo): void {\r\n        this.streaming.closeSingleSubscription(method, subscription);\r\n    }\r\n\r\n    public acceptRequestOnBranch(requestContext: RequestContext, method: ServerMethodInfo, branch: string): void {\r\n        this.streaming.acceptRequestOnBranch(requestContext, method, branch);\r\n    }\r\n\r\n    public rejectRequest(requestContext: RequestContext, method: ServerMethodInfo, reason: string): void {\r\n        this.streaming.rejectRequest(requestContext, method, reason);\r\n    }\r\n\r\n    public onSubRequest(callback: (requestContext: RequestContext, repoMethod: ServerMethodInfo) => void): void {\r\n        this.streaming.onSubRequest(callback);\r\n    }\r\n\r\n    public onSubAdded(callback: (subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void): void {\r\n        this.streaming.onSubAdded(callback);\r\n    }\r\n\r\n    public onSubRemoved(callback: (subscriber: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void): void {\r\n        this.streaming.onSubRemoved(callback);\r\n    }\r\n\r\n    private handleInvokeMessage(msg: InvokeMessage) {\r\n        const invocationId = msg.invocation_id;\r\n        const callerId = msg.caller_id;\r\n        const methodId = msg.method_id;\r\n        const args = msg.arguments_kv;\r\n        const methodList = this.serverRepository.getList();\r\n\r\n        const method = methodList.filter((m) => {\r\n            return m.repoId === methodId;\r\n        })[0];\r\n\r\n        // Stop if the message isn't for us\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n\r\n        const client = this.clientRepository.getServerById(callerId).instance;\r\n        const invocationArgs = { args, instance: client };\r\n\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { SubscriptionInner } from \"../../types\";\r\nimport ClientRepository from \"../../client/repository\";\r\n\r\nexport class UserSubscription implements Glue42Core.Interop.Subscription {\r\n    public get requestArguments() {\r\n        return this.subscriptionData.params.arguments || {};\r\n    }\r\n\r\n    public get servers(): Glue42Core.Interop.Instance[] {\r\n        return this.subscriptionData.trackedServers\r\n            .filter((pair) => pair.subscriptionId)\r\n            .map((pair) => this.repository.getServerById(pair.serverId).instance);\r\n    }\r\n\r\n    public get serverInstance(): Glue42Core.Interop.Instance {\r\n        return this.servers[0];\r\n    }\r\n\r\n    public get stream(): Glue42Core.Interop.MethodDefinition {\r\n        return this.subscriptionData.method;\r\n    }\r\n\r\n    constructor(private repository: ClientRepository, private subscriptionData: SubscriptionInner) {\r\n    }\r\n\r\n    public onData(dataCallback: (data: Glue42Core.Interop.StreamData) => void): void {\r\n        if (typeof dataCallback !== \"function\") {\r\n            throw new TypeError(\"The data callback must be a function.\");\r\n        }\r\n\r\n        this.subscriptionData.handlers.onData.push(dataCallback);\r\n        if (this.subscriptionData.handlers.onData.length === 1 && this.subscriptionData.queued.data.length > 0) {\r\n            this.subscriptionData.queued.data.forEach((dataItem) => {\r\n                dataCallback(dataItem);\r\n            });\r\n        }\r\n    }\r\n\r\n    public onClosed(closedCallback: (info: Glue42Core.Interop.OnClosedInfo) => void): void {\r\n        if (typeof closedCallback !== \"function\") {\r\n            throw new TypeError(\"The callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onClosed.push(closedCallback);\r\n    }\r\n\r\n    public onFailed(callback: (err: any) => void): void {\r\n        // DO NOTHING\r\n    }\r\n\r\n    public onConnected(callback: (server: Glue42Core.Interop.Instance, reconnect: boolean) => void): void {\r\n        if (typeof callback !== \"function\") {\r\n            throw new TypeError(\"The callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onConnected.push(callback);\r\n    }\r\n\r\n    public close(): void {\r\n        this.subscriptionData.close();\r\n    }\r\n\r\n    public setNewSubscription(newSub: SubscriptionInner) {\r\n        this.subscriptionData = newSub;\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport { ServerMethodsPair } from \"../../client/types\";\r\nimport * as GW3Messages from \"./messages\";\r\nimport { SubscriptionCancelledMessage, EventMessage, SubscribedMessage, ErrorSubscribingMessage } from \"./messages\";\r\nimport { SubscribeError, SubscriptionInner } from \"../../types\";\r\nimport { Logger } from \"../../../logger/logger\";\r\nimport { UserSubscription } from \"./subscription\";\r\n\r\nconst STATUS_AWAITING_ACCEPT = \"awaitingAccept\"; // not even one server has accepted yet\r\nconst STATUS_SUBSCRIBED = \"subscribed\"; // at least one server has responded as 'Accepting'\r\nconst ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nconst ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nconst ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nconst ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\n\r\n/**\r\n * Handles registering methods and sending data to clients\r\n */\r\nexport default class ClientStreaming {\r\n\r\n    private subscriptionsList: { [key: number]: SubscriptionInner } = {};\r\n    private subscriptionIdToLocalKeyMap: { [key: string]: number } = {};\r\n    private nextSubLocalKey = 0;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private repository: ClientRepository, private logger: Logger) {\r\n        session.on(\"subscribed\", this.handleSubscribed);\r\n        session.on(\"event\", this.handleEventData);\r\n        session.on(\"subscription-cancelled\", this.handleSubscriptionCancelled);\r\n    }\r\n\r\n    public subscribe(streamingMethod: Glue42Core.AGM.MethodDefinition, params: Glue42Core.AGM.SubscriptionParams, targetServers: ServerMethodsPair[], success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: SubscribeError) => void, existingSub: SubscriptionInner) {\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: streamingMethod,\r\n                called_with: params.arguments,\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Note: used to find the subscription in subList. Do not confuse it with the gw-generated subscription_id\r\n        const subLocalKey = this.getNextSubscriptionLocalKey();\r\n\r\n        const pendingSub = this.registerSubscription(\r\n            subLocalKey,\r\n            streamingMethod,\r\n            params,\r\n            success,\r\n            error,\r\n            params.methodResponseTimeout || 10000,\r\n            existingSub\r\n        );\r\n\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: streamingMethod,\r\n                called_with: params.arguments,\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n            });\r\n            return;\r\n        }\r\n\r\n        targetServers.forEach((target) => {\r\n\r\n            const serverId = target.server.id;\r\n            const method = target.methods.find((m) => m.name === streamingMethod.name);\r\n\r\n            if (!method) {\r\n                this.logger.error(`can not find method ${streamingMethod.name} for target ${target.server.id}`);\r\n                return;\r\n            }\r\n\r\n            pendingSub.trackedServers.push({\r\n                serverId,\r\n                subscriptionId: undefined,\r\n            });\r\n\r\n            const msg: GW3Messages.SubscribeMessage = {\r\n                type: \"subscribe\",\r\n                server_id: serverId,\r\n                method_id: method.gatewayId,\r\n                arguments_kv: params.arguments,\r\n            };\r\n\r\n            this.session.send<SubscribedMessage>(msg, { serverId, subLocalKey })\r\n                .then((m: SubscribedMessage) => this.handleSubscribed(m))\r\n                .catch((err: ErrorSubscribingMessage) => this.handleErrorSubscribing(err));\r\n        });\r\n    }\r\n\r\n    public drainSubscriptions() {\r\n        const existing = Object.values(this.subscriptionsList);\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        return existing;\r\n    }\r\n\r\n    private getNextSubscriptionLocalKey() {\r\n        const current = this.nextSubLocalKey;\r\n        this.nextSubLocalKey += 1;\r\n        return current;\r\n    }\r\n\r\n    // This adds subscription and after timeout (30000 default) removes it if it isn't STATUS_SUBSCRIBED\r\n    private registerSubscription(subLocalKey: number, method: Glue42Core.AGM.MethodDefinition, params: Glue42Core.Interop.SubscriptionParams, success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: SubscribeError) => void, timeout: number, existingSub: SubscriptionInner) {\r\n        const subsInfo: SubscriptionInner = {\r\n            localKey: subLocalKey,\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method,\r\n            params,\r\n            success,\r\n            error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: existingSub?.handlers.onData || [],\r\n                onClosed: existingSub?.handlers.onClosed || [],\r\n                onConnected: existingSub?.handlers.onConnected || [],\r\n                // onFailed: []\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n            close: () => this.closeSubscription(subLocalKey),\r\n            subscription: existingSub?.subscription // only when re-connecting\r\n        };\r\n\r\n        if (!existingSub) {\r\n            if (params.onData) {\r\n                subsInfo.handlers.onData.push(params.onData);\r\n            }\r\n            if (params.onClosed) {\r\n                subsInfo.handlers.onClosed.push(params.onClosed);\r\n            }\r\n            if (params.onConnected) {\r\n                subsInfo.handlers.onConnected.push(params.onConnected);\r\n            }\r\n        }\r\n\r\n        this.subscriptionsList[subLocalKey] = subsInfo;\r\n\r\n        subsInfo.timeoutId = setTimeout(() => {\r\n            if (this.subscriptionsList[subLocalKey] === undefined) {\r\n                return; // no such subscription\r\n            }\r\n\r\n            const pendingSub = this.subscriptionsList[subLocalKey];\r\n\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method,\r\n                    called_with: params.arguments,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \" ms.\",\r\n                });\r\n\r\n                // None of the target servers has answered the subscription attempt\r\n                delete this.subscriptionsList[subLocalKey];\r\n\r\n            } else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {\r\n                // Clean the trackedServers, removing those without valid streamId\r\n                pendingSub.trackedServers = pendingSub.trackedServers.filter((server) => {\r\n                    return (typeof server.subscriptionId !== \"undefined\");\r\n                });\r\n\r\n                delete pendingSub.timeoutId;\r\n\r\n                if (pendingSub.trackedServers.length <= 0) {\r\n                    // There are no open streams, some servers accepted then closed very quickly\r\n                    //  (that's why the status changed but there's no good server with a StreamId)\r\n\r\n                    // call the onClosed handlers\r\n                    this.callOnClosedHandlers(pendingSub);\r\n\r\n                    delete this.subscriptionsList[subLocalKey];\r\n                }\r\n            }\r\n        }, timeout);\r\n\r\n        return subsInfo;\r\n    }\r\n\r\n    private handleErrorSubscribing = (errorResponse: ErrorSubscribingMessage) => {\r\n        const tag = errorResponse._tag;\r\n        const subLocalKey = tag.subLocalKey;\r\n        const pendingSub = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof pendingSub !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        pendingSub.trackedServers = pendingSub.trackedServers.filter((server) => {\r\n            return server.serverId !== tag.serverId;\r\n        });\r\n\r\n        if (pendingSub.trackedServers.length <= 0) {\r\n            clearTimeout(pendingSub.timeoutId);\r\n\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                // Reject with reason\r\n                const reason = (typeof errorResponse.reason === \"string\" && errorResponse.reason !== \"\") ?\r\n                    ' Publisher said \"' + errorResponse.reason + '\".' :\r\n                    \" No reason given.\";\r\n\r\n                const callArgs = typeof pendingSub.params.arguments === \"object\" ?\r\n                    JSON.stringify(pendingSub.params.arguments) :\r\n                    \"{}\";\r\n\r\n                pendingSub.error({\r\n                    message: ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs,\r\n                    called_with: pendingSub.params.arguments,\r\n                    method: pendingSub.method,\r\n                });\r\n\r\n            } else if (pendingSub.status === STATUS_SUBSCRIBED) {\r\n                // The timeout may or may not have expired yet,\r\n                // but the status is 'subscribed' and trackedServers is now empty\r\n\r\n                this.callOnClosedHandlers(pendingSub);\r\n            }\r\n\r\n            delete this.subscriptionsList[subLocalKey];\r\n        }\r\n    }\r\n\r\n    private handleSubscribed = (msg: SubscribedMessage) => {\r\n        const subLocalKey = msg._tag.subLocalKey;\r\n        const pendingSub = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof pendingSub !== \"object\") {\r\n            return;\r\n        }\r\n        const serverId = msg._tag.serverId;\r\n\r\n        // Add a subscription_id to this trackedServer\r\n\r\n        const acceptingServer = pendingSub.trackedServers\r\n            .filter((server) => {\r\n                return server.serverId === serverId;\r\n            })[0];\r\n\r\n        if (typeof acceptingServer !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        acceptingServer.subscriptionId = msg.subscription_id;\r\n        this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;\r\n\r\n        const isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);\r\n\r\n        pendingSub.status = STATUS_SUBSCRIBED;\r\n\r\n        if (isFirstResponse) {\r\n            let reconnect: boolean = false;\r\n            let sub = pendingSub.subscription;\r\n            if (sub) {\r\n                // re-connect case, we already have subscription object\r\n                sub.setNewSubscription(pendingSub);\r\n                pendingSub.success(sub);\r\n                reconnect = true;\r\n            } else {\r\n                sub = new UserSubscription(this.repository, pendingSub);\r\n                pendingSub.subscription = sub;\r\n                // Pass in the subscription object\r\n                pendingSub.success(sub);\r\n            }\r\n\r\n            for (const handler of pendingSub.handlers.onConnected) {\r\n                try {\r\n                    handler(sub.serverInstance, reconnect);\r\n                } catch (e) {\r\n                    // DO nothing\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleEventData = (msg: EventMessage) => {\r\n\r\n        const subLocalKey = this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n\r\n        if (typeof subLocalKey === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        const subscription = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        const trackedServersFound = subscription.trackedServers.filter((server) => {\r\n            return server.subscriptionId === msg.subscription_id;\r\n        });\r\n\r\n        if (trackedServersFound.length !== 1) {\r\n            return;\r\n        }\r\n\r\n        // out_of_band. (main stream band)\r\n        const isPrivateData = msg.oob;\r\n\r\n        const sendingServerId = trackedServersFound[0].serverId;\r\n\r\n        // Create the arrivedData object, new object for each handler call\r\n        const receivedStreamData = (): Glue42Core.AGM.StreamData => {\r\n            return {\r\n                data: msg.data,\r\n                server: this.repository.getServerById(sendingServerId).instance,\r\n                requestArguments: subscription.params.arguments,\r\n                message: undefined,\r\n                private: isPrivateData,\r\n            };\r\n        };\r\n\r\n        const onDataHandlers = subscription.handlers.onData;\r\n        const queuedData = subscription.queued.data;\r\n\r\n        if (onDataHandlers.length > 0) {\r\n            onDataHandlers.forEach((callback) => {\r\n                if (typeof callback === \"function\") {\r\n                    callback(receivedStreamData());\r\n                }\r\n            });\r\n        } else {\r\n            queuedData.push(receivedStreamData());\r\n        }\r\n    }\r\n\r\n    // called only on stream.close() multiple times for each subscription\r\n    private handleSubscriptionCancelled = (msg: SubscriptionCancelledMessage) => {\r\n        const subLocalKey = this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n\r\n        if (typeof subLocalKey === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        const subscription = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        // Filter tracked servers\r\n        const expectedNewLength = subscription.trackedServers.length - 1;\r\n\r\n        subscription.trackedServers = subscription.trackedServers.filter((server) => {\r\n            if (server.subscriptionId === msg.subscription_id) {\r\n                subscription.queued.closers.push(server.serverId);\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        });\r\n\r\n        // Check if a server was actually removed\r\n        if (subscription.trackedServers.length !== expectedNewLength) {\r\n            // TODO: Log some error\r\n            return;\r\n        }\r\n\r\n        // Check if this was the last remaining server\r\n        if (subscription.trackedServers.length <= 0) {\r\n            clearTimeout(subscription.timeoutId);\r\n            this.callOnClosedHandlers(subscription);\r\n            delete this.subscriptionsList[subLocalKey];\r\n        }\r\n\r\n        delete this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n    }\r\n\r\n    private callOnClosedHandlers(subscription: SubscriptionInner, reason?: string) {\r\n\r\n        const closersCount = subscription.queued.closers.length;\r\n        const closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n\r\n        let closingServer: Glue42Core.AGM.Instance;\r\n        if (closingServerId !== undefined && typeof closingServerId === \"string\") {\r\n            closingServer = this.repository.getServerById(closingServerId).instance;\r\n        }\r\n\r\n        subscription.handlers.onClosed.forEach((callback) => {\r\n            if (typeof callback !== \"function\") {\r\n                return;\r\n            }\r\n\r\n            callback({\r\n                message: reason || ON_CLOSE_MSG_SERVER_INIT,\r\n                requestArguments: subscription.params.arguments || {},\r\n                server: closingServer,\r\n                stream: subscription.method,\r\n            });\r\n        });\r\n    }\r\n\r\n    // called on client/server close (not on stream.close)\r\n    private closeSubscription(subLocalKey: number) {\r\n        const subscription = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        // Tell each server that we're unsubscribing\r\n        subscription.trackedServers.forEach((server) => {\r\n            if (typeof server.subscriptionId === \"undefined\") {\r\n                return;\r\n            }\r\n\r\n            subscription.queued.closers.push(server.serverId);\r\n\r\n            this.session.sendFireAndForget({\r\n                type: \"unsubscribe\",\r\n                subscription_id: server.subscriptionId,\r\n                reason_uri: \"\",\r\n                reason: ON_CLOSE_MSG_CLIENT_INIT,\r\n            });\r\n\r\n            delete this.subscriptionIdToLocalKeyMap[server.subscriptionId];\r\n        });\r\n\r\n        subscription.trackedServers = [];\r\n\r\n        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);\r\n\r\n        delete this.subscriptionsList[subLocalKey];\r\n    }\r\n}\r\n","import ClientStreaming from \"./client-streaming\";\r\nimport {\r\n    CallMessage,\r\n    ErrorMessage,\r\n    MethodsAddedMessage,\r\n    MethodsRemovedMessage,\r\n    PeerAddedMessage,\r\n    PeerRemovedMessage,\r\n    ResultMessage,\r\n    MethodInfoMessage\r\n} from \"./messages\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport { ClientMethodInfo, ServerInfo, ServerMethodsPair } from \"../../client/types\";\r\nimport { ClientProtocolDefinition, SubscribeError, SubscriptionInner } from \"../../types\";\r\nimport { InvokeResultMessage, InvokeStatus } from \"../../client/client\";\r\nimport { Logger } from \"../../../logger/logger\";\r\n\r\n/**\r\n * Handles session lifetime and events\r\n */\r\nexport default class ClientProtocol implements ClientProtocolDefinition {\r\n\r\n    private streaming: ClientStreaming;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private repository: ClientRepository, private logger: Logger) {\r\n        session.on(\"peer-added\", (msg: PeerAddedMessage) => this.handlePeerAdded(msg));\r\n        session.on(\"peer-removed\", (msg: PeerRemovedMessage) => this.handlePeerRemoved(msg));\r\n        session.on(\"methods-added\", (msg: MethodsAddedMessage) => this.handleMethodsAddedMessage(msg));\r\n        session.on(\"methods-removed\", (msg: MethodsRemovedMessage) => this.handleMethodsRemovedMessage(msg));\r\n\r\n        this.streaming = new ClientStreaming(session, repository, logger);\r\n    }\r\n\r\n    public subscribe(stream: Glue42Core.AGM.MethodDefinition, options: Glue42Core.AGM.SubscriptionParams, targetServers: ServerMethodsPair[], success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: SubscribeError) => void, existingSub: SubscriptionInner): void {\r\n        this.streaming.subscribe(stream, options, targetServers, success, error, existingSub);\r\n    }\r\n\r\n    public invoke(id: string, method: ClientMethodInfo, args: object, target: ServerInfo): Promise<InvokeResultMessage> {\r\n\r\n        const serverId = target.id;\r\n        const methodId = method.gatewayId;\r\n        const msg: CallMessage = {\r\n            type: \"call\",\r\n            server_id: serverId,\r\n            method_id: methodId,\r\n            arguments_kv: args,\r\n        };\r\n\r\n        // we transfer the invocation id as tag\r\n        return this.session.send<ResultMessage>(msg, { invocationId: id, serverId })\r\n            .then((m: ResultMessage) => this.handleResultMessage(m))\r\n            .catch((err) => this.handleInvocationError(err));\r\n    }\r\n\r\n    public drainSubscriptions(): SubscriptionInner[] {\r\n        return this.streaming.drainSubscriptions();\r\n    }\r\n\r\n    private handlePeerAdded(msg: PeerAddedMessage) {\r\n        const newPeerId = msg.new_peer_id;\r\n        const remoteId = msg.identity;\r\n        const isLocal = msg.meta ? msg.meta.local : true;\r\n        const pid = Number(remoteId.process);\r\n\r\n        const serverInfo: Glue42Core.AGM.Instance = {\r\n            machine: remoteId.machine,\r\n            pid: isNaN(pid) ? remoteId.process : pid,\r\n            instance: remoteId.instance,\r\n            application: remoteId.application,\r\n            applicationName: remoteId.applicationName,\r\n            environment: remoteId.environment,\r\n            region: remoteId.region,\r\n            user: remoteId.user,\r\n            windowId: remoteId.windowId,\r\n            peerId: newPeerId,\r\n            api: remoteId.api,\r\n            isLocal\r\n        };\r\n\r\n        this.repository.addServer(serverInfo, newPeerId);\r\n    }\r\n\r\n    private handlePeerRemoved(msg: PeerRemovedMessage) {\r\n        const removedPeerId = msg.removed_id;\r\n        const reason = msg.reason;\r\n\r\n        this.repository.removeServerById(removedPeerId, reason);\r\n    }\r\n\r\n    private handleMethodsAddedMessage(msg: MethodsAddedMessage) {\r\n        const serverId = msg.server_id;\r\n        const methods = msg.methods;\r\n\r\n        methods.forEach((method: MethodInfoMessage) => {\r\n            this.repository.addServerMethod(serverId, method);\r\n        });\r\n    }\r\n\r\n    private handleMethodsRemovedMessage(msg: MethodsRemovedMessage) {\r\n        const serverId = msg.server_id;\r\n        const methodIdList = msg.methods;\r\n\r\n        const server = this.repository.getServerById(serverId);\r\n        const serverMethodKeys = Object.keys(server.methods);\r\n\r\n        serverMethodKeys.forEach((methodKey) => {\r\n            const method = server.methods[methodKey];\r\n            if (methodIdList.indexOf(method.gatewayId) > -1) {\r\n                this.repository.removeServerMethod(serverId, methodKey);\r\n            }\r\n        });\r\n    }\r\n\r\n    private handleResultMessage(msg: ResultMessage): InvokeResultMessage {\r\n        const invocationId = msg._tag.invocationId;\r\n        const result = msg.result;\r\n        const serverId = msg._tag.serverId;\r\n        const server = this.repository.getServerById(serverId);\r\n\r\n        return {\r\n            invocationId,\r\n            result,\r\n            instance: server.instance,\r\n            status: InvokeStatus.Success,\r\n            message: \"\"\r\n        };\r\n    }\r\n\r\n    private handleInvocationError(msg: ErrorMessage | Error): InvokeResultMessage {\r\n        this.logger.debug(`handle invocation error ${JSON.stringify(msg)}`);\r\n\r\n        if (\"_tag\" in msg) {\r\n            const invocationId = msg._tag.invocationId;\r\n            const serverId = msg._tag.serverId;\r\n            const server = this.repository.getServerById(serverId);\r\n            const message = msg.reason;\r\n            const context = msg.context;\r\n\r\n            return {\r\n                invocationId,\r\n                result: context,\r\n                instance: server.instance,\r\n                status: InvokeStatus.Error,\r\n                message\r\n            };\r\n        } else {\r\n            return {\r\n                invocationId: \"\",\r\n                message: (msg as Error).message,\r\n                status: InvokeStatus.Error,\r\n                error: msg as Error\r\n            };\r\n        }\r\n    }\r\n}\r\n","import ServerProtocol from \"./server\";\r\nimport ClientProtocol from \"./client\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport ServerRepository from \"../../server/repository\";\r\nimport Interop from \"../../interop\";\r\nimport { Protocol, InteropSettings } from \"../../types\";\r\nimport Connection from \"../../../connection/connection\";\r\n\r\nexport default function (instance: Glue42Core.AGM.Instance, connection: Connection, clientRepository: ClientRepository, serverRepository: ServerRepository, libConfig: InteropSettings, interop: Interop): Promise<Protocol> {\r\n    const logger = libConfig.logger.subLogger(\"gw3-protocol\");\r\n    let resolveReadyPromise: ((p: Protocol) => void) | undefined;\r\n\r\n    const readyPromise = new Promise<Protocol>((resolve) => {\r\n        resolveReadyPromise = resolve;\r\n    });\r\n\r\n    // start domain join handshake\r\n    const session = connection.domain(\"agm\", [\"subscribed\"]);\r\n\r\n    const server = new ServerProtocol(session, clientRepository, serverRepository, logger.subLogger(\"server\"));\r\n    const client = new ClientProtocol(session, clientRepository, logger.subLogger(\"client\"));\r\n\r\n    function handleReconnect() {\r\n        // we're reconnecting\r\n        logger.info(\"reconnected - will replay registered methods and subscriptions\");\r\n\r\n        const existingSubscriptions = client.drainSubscriptions();\r\n        for (const sub of existingSubscriptions) {\r\n            const methodInfo = sub.method;\r\n            const params = Object.assign({}, sub.params);\r\n            // remove handlers, otherwise they will be added twice\r\n            logger.info(`trying to re-subscribe to method ${methodInfo.name}`);\r\n            interop.client.subscribe(methodInfo, params, undefined, undefined, sub);\r\n        }\r\n\r\n        // server side\r\n        const registeredMethods = serverRepository.getList();\r\n        serverRepository.reset();\r\n\r\n        // replay server methods\r\n        for (const method of registeredMethods) {\r\n            const def = method.definition;\r\n            logger.info(`re-publishing method ${def.name}`);\r\n            if (method.stream) {\r\n                // streaming method\r\n                interop.server.createStream(def, method.streamCallbacks, undefined, undefined, method.stream);\r\n            } else if (method.theFunction && method.theFunction.userCallback) {\r\n                interop.register(def, method.theFunction.userCallback);\r\n            } else if (method.theFunction && method.theFunction.userCallbackAsync) {\r\n                interop.registerAsync(def, method.theFunction.userCallbackAsync);\r\n            }\r\n        }\r\n    }\r\n\r\n    function handleInitialJoin() {\r\n        if (resolveReadyPromise) {\r\n            resolveReadyPromise({\r\n                client,\r\n                server,\r\n            });\r\n\r\n            resolveReadyPromise = undefined;\r\n        }\r\n    }\r\n\r\n    session.onJoined((reconnect) => {\r\n        // add our server to the client repository\r\n        clientRepository.addServer(instance, connection.peerId);\r\n\r\n        if (reconnect) {\r\n            handleReconnect();\r\n        } else {\r\n            handleInitialJoin();\r\n        }\r\n    });\r\n\r\n    session.onLeft(() => {\r\n        // reset the client repository when the connection is down\r\n        clientRepository.reset();\r\n    });\r\n\r\n    session.join();\r\n\r\n    return readyPromise;\r\n}\r\n","import Client from \"./client/client\";\r\nimport Server from \"./server/server\";\r\nimport { Protocol, SubscribeError, InteropSettings } from \"./types\";\r\nimport { Glue42Core } from \"../../glue\";\r\nimport ClientRepository from \"./client/repository\";\r\nimport ServerRepository from \"./server/repository\";\r\nimport { UnsubscribeFunction } from \"callback-registry\";\r\nimport gW3ProtocolFactory from \"./protocols/gw3/factory\";\r\nimport { InstanceWrapper } from \"./instance\";\r\nimport { PromiseWrapper } from \"../utils/pw\";\r\n\r\nexport default class Interop implements Glue42Core.AGM.API {\r\n    public instance: Glue42Core.AGM.Instance;\r\n    public readyPromise: Promise<Interop>;\r\n\r\n    public client!: Client;\r\n    public server!: Server;\r\n    public unwrappedInstance: InstanceWrapper;\r\n    private protocol!: Protocol;\r\n    private clientRepository: ClientRepository;\r\n    private serverRepository: ServerRepository;\r\n\r\n    constructor(configuration: InteropSettings) {\r\n        if (typeof configuration === \"undefined\") {\r\n            throw new Error(\"configuration is required\");\r\n        }\r\n\r\n        if (typeof configuration.connection === \"undefined\") {\r\n            throw new Error(\"configuration.connections is required\");\r\n        }\r\n\r\n        const connection = configuration.connection;\r\n\r\n        if (typeof configuration.methodResponseTimeout !== \"number\") {\r\n            configuration.methodResponseTimeout = 30 * 1000;\r\n        }\r\n        if (typeof configuration.waitTimeoutMs !== \"number\") {\r\n            configuration.waitTimeoutMs = 30 * 1000;\r\n        }\r\n\r\n        // Initialize our modules\r\n        this.unwrappedInstance = new InstanceWrapper(this, undefined, connection);\r\n        this.instance = this.unwrappedInstance.unwrap();\r\n        this.clientRepository = new ClientRepository(configuration.logger.subLogger(\"cRep\"), this);\r\n        this.serverRepository = new ServerRepository();\r\n        let protocolPromise: Promise<Protocol>;\r\n\r\n        if (connection.protocolVersion === 3) {\r\n            protocolPromise = gW3ProtocolFactory(this.instance, connection, this.clientRepository, this.serverRepository, configuration, this);\r\n        } else {\r\n            throw new Error(`protocol ${connection.protocolVersion} not supported`);\r\n        }\r\n\r\n        // wait for protocol to resolve\r\n        this.readyPromise = protocolPromise.then((protocol: Protocol) => {\r\n            this.protocol = protocol;\r\n            this.client = new Client(this.protocol, this.clientRepository, this.instance, configuration);\r\n            this.server = new Server(this.protocol, this.serverRepository);\r\n            return this;\r\n        });\r\n    }\r\n\r\n    public ready() {\r\n        return this.readyPromise;\r\n    }\r\n\r\n    public serverRemoved(callback: (instance: Glue42Core.AGM.Instance, reason: string) => void): UnsubscribeFunction {\r\n        return this.client.serverRemoved(callback);\r\n    }\r\n\r\n    public serverAdded(callback: (instance: Glue42Core.AGM.Instance) => void): UnsubscribeFunction {\r\n        return this.client.serverAdded(callback);\r\n    }\r\n\r\n    public serverMethodRemoved(callback: (info: { server: Glue42Core.AGM.Instance; method: Glue42Core.AGM.Method; }) => void): UnsubscribeFunction {\r\n        return this.client.serverMethodRemoved(callback);\r\n    }\r\n\r\n    public serverMethodAdded(callback: (info: { server: Glue42Core.AGM.Instance; method: Glue42Core.AGM.Method; }) => void): UnsubscribeFunction {\r\n        return this.client.serverMethodAdded(callback);\r\n    }\r\n\r\n    public methodRemoved(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.client.methodRemoved(callback);\r\n    }\r\n\r\n    public methodAdded(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.client.methodAdded(callback);\r\n    }\r\n\r\n    public methodsForInstance(instance: Glue42Core.AGM.Instance): Glue42Core.Interop.Method[] {\r\n        return this.client.methodsForInstance(instance);\r\n    }\r\n\r\n    public methods(methodFilter: Glue42Core.AGM.MethodDefinition): Glue42Core.Interop.Method[] {\r\n        return this.client.methods(methodFilter);\r\n    }\r\n\r\n    public servers(methodFilter: Glue42Core.AGM.MethodDefinition): Glue42Core.AGM.Instance[] {\r\n        return this.client.servers(methodFilter);\r\n    }\r\n\r\n    public subscribe(method: string, options: Glue42Core.AGM.SubscriptionParams, successCallback?: (subscription: Glue42Core.AGM.Subscription) => void, errorCallback?: (err: SubscribeError) => void): Promise<Glue42Core.AGM.Subscription> {\r\n        return this.client.subscribe(method, options, successCallback, errorCallback);\r\n    }\r\n\r\n    public createStream(streamDef: string | Glue42Core.AGM.MethodDefinition, callbacks: Glue42Core.AGM.StreamOptions, successCallback?: (args?: object) => void, errorCallback?: (error?: string | object) => void): Promise<Glue42Core.AGM.Stream> {\r\n        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);\r\n    }\r\n\r\n    public unregister(methodFilter: string | Glue42Core.AGM.MethodDefinition): Promise<void> {\r\n        return this.server.unregister(methodFilter);\r\n    }\r\n\r\n    public registerAsync(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: any, caller: Glue42Core.AGM.Instance, successCallback: (args?: any) => void, errorCallback: (error?: string | object) => void) => void): Promise<void> {\r\n        return this.server.registerAsync(methodDefinition, callback);\r\n    }\r\n\r\n    public register(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: any, caller: Glue42Core.AGM.Instance) => any | Promise<void>): Promise<void> {\r\n        return this.server.register(methodDefinition, callback);\r\n    }\r\n\r\n    public invoke(methodFilter: string | Glue42Core.AGM.MethodDefinition, argumentObj?: object, target?: Glue42Core.AGM.InstanceTarget | Glue42Core.AGM.Instance | Glue42Core.AGM.Instance[], additionalOptions?: Glue42Core.AGM.InvokeOptions, success?: (result: Glue42Core.AGM.InvocationResult<any>) => void, error?: (error: { method: Glue42Core.AGM.MethodDefinition; called_with: object; executed_by: Glue42Core.AGM.Instance; message: string; status: number; returned: object; }) => void): Promise<Glue42Core.AGM.InvocationResult<any>> {\r\n        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n    }\r\n\r\n    public waitForMethod(name: string): Promise<Glue42Core.Interop.Method> {\r\n        const pw = new PromiseWrapper<Glue42Core.Interop.Method>();\r\n        const unsubscribe = this.client.methodAdded((m) => {\r\n            if (m.name === name) {\r\n                unsubscribe();\r\n                pw.resolve(m);\r\n            }\r\n        });\r\n\r\n        return pw.promise;\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport Connection from \"../connection/connection\";\r\nimport { Logger } from \"../logger/logger\";\r\n\r\nexport interface BusSettings {\r\n    connection: Connection;\r\n    logger: Logger;\r\n}\r\ninterface SubscriptionEntry {\r\n    subscription_id: string;\r\n    topic: string;\r\n    callback: (data: object, topic: string, source: Glue42Core.Interop.Instance) => void;\r\n    source?: object;\r\n}\r\n\r\nconst successMessages = [\"subscribed\", \"success\"];\r\n\r\nexport class MessageBus implements Glue42Core.Bus.API {\r\n    public connection: Connection;\r\n    public logger: Logger;\r\n    public peerId: string;\r\n    public session: Glue42Core.Connection.GW3DomainSession;\r\n    public subscriptions: SubscriptionEntry[];\r\n    public readyPromise: Promise<object>;\r\n\r\n    constructor(connection: Connection, logger: Logger) {\r\n        this.connection = connection;\r\n        this.logger = logger;\r\n        this.peerId = connection.peerId;\r\n        this.subscriptions = [];\r\n        this.session = connection.domain(\"bus\", successMessages);\r\n        this.readyPromise = this.session.join();\r\n        this.readyPromise.then(() => {\r\n            this.watchOnEvent();\r\n        });\r\n    }\r\n\r\n    public ready() {\r\n        return this.readyPromise;\r\n    }\r\n\r\n    public publish = (topic: string, data: object, options?: Glue42Core.Bus.MessageOptions): void => {\r\n        const { routingKey, target } = options || {} as any;\r\n        const args = this.removeEmptyValues({\r\n            type: \"publish\",\r\n            topic,\r\n            data,\r\n            peer_id: this.peerId,\r\n            routing_key: routingKey,\r\n            target_identity: target\r\n        });\r\n        this.session.send(args);\r\n    }\r\n\r\n    public subscribe = (\r\n        topic: string,\r\n        callback: (data: object, topic: string, source: object) => void,\r\n        options?: Glue42Core.Bus.MessageOptions\r\n    ): Promise<Glue42Core.Bus.Subscription> => {\r\n        return new Promise((resolve, reject) => {\r\n            const { routingKey, target } = options || {} as any;\r\n            const args = this.removeEmptyValues({\r\n                type: \"subscribe\",\r\n                topic,\r\n                peer_id: this.peerId,\r\n                routing_key: routingKey,\r\n                source: target\r\n            });\r\n\r\n            this.session.send(args)\r\n                .then((response: any) => {\r\n                    const { subscription_id } = response;\r\n                    this.subscriptions.push({ subscription_id, topic, callback, source: target });\r\n\r\n                    resolve({\r\n                        unsubscribe: () => {\r\n                            this.session.send({ type: \"unsubscribe\", subscription_id, peer_id: this.peerId });\r\n                            this.subscriptions = this.subscriptions.filter((s) => s.subscription_id !== subscription_id);\r\n                            return Promise.resolve();\r\n                        }\r\n                    });\r\n                })\r\n                .catch((error: any) => reject(error));\r\n        });\r\n    }\r\n\r\n    public watchOnEvent = () => {\r\n        this.session.on(\"event\", (args: any) => {\r\n            const { data, subscription_id } = args;\r\n            const source = args[\"publisher-identity\"];\r\n            const subscription = this.subscriptions.find((s) => s.subscription_id === subscription_id);\r\n\r\n            if (subscription) {\r\n                if (!subscription.source) {\r\n                    subscription.callback(data, subscription.topic, source);\r\n                } else {\r\n                    if (this.keysMatch(subscription.source, source)) {\r\n                        subscription.callback(data, subscription.topic, source);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private removeEmptyValues(obj: any) {\r\n        const cleaned: any = {};\r\n        Object.keys(obj).forEach((key) => {\r\n            if (obj[key] !== undefined && obj[key] !== null) {\r\n                cleaned[key] = obj[key];\r\n            }\r\n        });\r\n        return cleaned;\r\n    }\r\n\r\n    private keysMatch(obj1: any, obj2: any) {\r\n        const keysObj1 = Object.keys(obj1);\r\n        let allMatch = true;\r\n        keysObj1.forEach((key) => {\r\n            if (obj1[key] !== obj2[key]) {\r\n                allMatch = false;\r\n            }\r\n        });\r\n        return allMatch;\r\n    }\r\n}\r\n","import metrics from \"./metrics/main\";\r\nimport Connection from \"./connection/connection\";\r\nimport { Logger } from \"./logger/logger\";\r\nimport { Glue42Core } from \"../glue\";\r\nimport prepareConfig from \"./config\";\r\nimport timer, { getAllTimers } from \"./utils/timer\";\r\nimport Utils from \"./utils/utils\";\r\nimport { Timer } from \"./types\";\r\nimport { ContextsModule } from \"./contexts/contextsModule\";\r\nimport { ContextMessageReplaySpec } from \"./contexts/contextMessageReplaySpec\";\r\nimport { InteropSettings } from \"./interop/types\";\r\nimport Interop from \"./interop/interop\";\r\nimport { MessageBus } from \"./bus/main\";\r\nimport { version } from \"../package.json\";\r\nimport shortid from \"shortid\";\r\n\r\nconst GlueCore = (userConfig?: Glue42Core.Config, ext?: Glue42Core.Extension): Promise<Glue42Core.GlueCore> => {\r\n    const gdVersion: number | undefined = Utils.getGDMajorVersion();\r\n    let glue42gd: Glue42Core.GDObject | undefined;\r\n    let preloadPromise: Promise<any> = Promise.resolve();\r\n\r\n    if (gdVersion) {\r\n        if (gdVersion < 3) {\r\n            throw new Error(\"GD v2 is not supported. Use v4 of the API to run in that context.\");\r\n        } else if (gdVersion >= 3) {\r\n            glue42gd = window.glue42gd;\r\n            preloadPromise = window.gdPreloadPromise || preloadPromise;\r\n        }\r\n    }\r\n\r\n    const glueInitTimer = timer(\"glue\");\r\n\r\n    userConfig = userConfig || {};\r\n    ext = ext || {};\r\n    const internalConfig = prepareConfig(userConfig, ext, glue42gd);\r\n\r\n    // Init the GLUE namespace\r\n    let _connection: Connection;\r\n    let _interop: Interop;\r\n    let _logger: Logger;\r\n    let _metrics: Glue42Core.Metrics.API;\r\n    let _contexts: Glue42Core.Contexts.API;\r\n    let _bus: Glue42Core.Bus.API;\r\n    let _allowTrace: boolean; // true if trace logging is enabled\r\n\r\n    const libs: { [key: string]: any } = {};\r\n\r\n    function registerLib(name: string | string[], inner: any, t: Timer) {\r\n\r\n        _allowTrace = _logger.canPublish(\"trace\");\r\n        if (_allowTrace) {\r\n            _logger.trace(`registering ${name} module`);\r\n        }\r\n\r\n        const done = () => {\r\n            inner.initTime = t.stop();\r\n            inner.initEndTime = t.endTime;\r\n            inner.marks = t.marks;\r\n            if (_allowTrace) {\r\n                _logger.trace(`${name} is ready - ${t.endTime - t.startTime}`);\r\n            }\r\n        };\r\n\r\n        inner.initStartTime = t.startTime;\r\n        if (inner.ready) {\r\n            inner.ready().then(() => {\r\n                done();\r\n            });\r\n        } else {\r\n            done();\r\n        }\r\n\r\n        if (!Array.isArray(name)) {\r\n            name = [name];\r\n        }\r\n\r\n        name.forEach((n) => {\r\n            libs[n] = inner;\r\n            (GlueCore as any)[n] = inner;\r\n        });\r\n    }\r\n\r\n    function setupConnection(): Promise<object> {\r\n        const initTimer = timer(\"connection\");\r\n        _connection = new Connection(internalConfig.connection, _logger.subLogger(\"connection\"));\r\n\r\n        let authPromise: Promise<any> = Promise.resolve(internalConfig.auth);\r\n\r\n        // no auth - what we do in different protocol versions\r\n        if (internalConfig.connection && !internalConfig.auth) {\r\n            if (glue42gd) {\r\n                authPromise = glue42gd.getGWToken()\r\n                    .then((token) => {\r\n                        // initTimer.mark(\"got-gw-token\");\r\n                        return {\r\n                            gatewayToken: token\r\n                        };\r\n                    });\r\n            } else {\r\n                // assign to auth promise so we ca cleanup the connection\r\n                authPromise = Promise.reject(\"You need to provide auth information\");\r\n            }\r\n        }\r\n\r\n        return authPromise\r\n            .then((authConfig) => {\r\n                initTimer.mark(\"auth-promise-resolved\");\r\n                // convert the authConfig to AuthRequest object\r\n                let authRequest: Glue42Core.Auth;\r\n                if (Object.prototype.toString.call(authConfig) === \"[object Object]\") {\r\n                    authRequest = authConfig;\r\n                } else {\r\n                    throw new Error(\"Invalid auth object - \" + JSON.stringify(authConfig));\r\n                }\r\n                // do the login\r\n                return _connection.login(authRequest);\r\n            })\r\n            .then(() => {\r\n                registerLib(\"connection\", _connection, initTimer);\r\n                return internalConfig;\r\n            })\r\n            .catch((e) => {\r\n                if (_connection) {\r\n                    _connection.logout();\r\n                }\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    function setupLogger(): Promise<void> {\r\n        // Logger\r\n        const initTimer = timer(\"logger\");\r\n        _logger = new Logger(`${internalConfig.connection.identity?.application}`, undefined, internalConfig.customLogger);\r\n        _logger.consoleLevel(internalConfig.logger.console);\r\n        _logger.publishLevel(internalConfig.logger.publish);\r\n\r\n        if (_logger.canPublish(\"debug\")) {\r\n            _logger.debug(\"initializing glue...\");\r\n        }\r\n        registerLib(\"logger\", _logger, initTimer);\r\n\r\n        return Promise.resolve(undefined);\r\n    }\r\n\r\n    function setupMetrics(): Promise<void> {\r\n        const initTimer = timer(\"metrics\");\r\n        const config = internalConfig.metrics;\r\n\r\n        const metricsPublishingEnabledFunc = glue42gd?.getMetricsPublishingEnabled;\r\n        const identity = internalConfig.connection.identity;\r\n        const canUpdateMetric = metricsPublishingEnabledFunc ? metricsPublishingEnabledFunc : () => true;\r\n        const disableAutoAppSystem: boolean = (typeof config !== \"boolean\" && config.disableAutoAppSystem) ?? false;\r\n        _metrics = metrics({\r\n            connection: config ? _connection : undefined,\r\n            logger: _logger.subLogger(\"metrics\"),\r\n            canUpdateMetric,\r\n            system: \"Glue42\",\r\n            service: identity?.service ?? glue42gd?.applicationName ?? internalConfig.application,\r\n            instance: identity?.instance ?? identity?.windowId ?? shortid(),\r\n            disableAutoAppSystem,\r\n            pagePerformanceMetrics: typeof config !== \"boolean\" ? config?.pagePerformanceMetrics : undefined\r\n        });\r\n\r\n        registerLib(\"metrics\", _metrics, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function setupInterop(): Promise<void> {\r\n        const initTimer = timer(\"interop\");\r\n\r\n        const agmConfig: InteropSettings = {\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"interop\"),\r\n        };\r\n\r\n        _interop = new Interop(agmConfig);\r\n        Logger.Interop = _interop;\r\n        registerLib([\"interop\", \"agm\"], _interop, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function setupContexts() {\r\n        const hasActivities = ((internalConfig as any).activities && _connection.protocolVersion === 3);\r\n        const needsContexts = internalConfig.contexts || hasActivities;\r\n        if (needsContexts) {\r\n            const initTimer = timer(\"contexts\");\r\n\r\n            _contexts = new ContextsModule({\r\n                connection: _connection,\r\n                logger: _logger.subLogger(\"contexts\")\r\n            });\r\n            registerLib(\"contexts\", _contexts, initTimer);\r\n            return _contexts;\r\n\r\n            // NB: The shared contexts data is part of the global domain,\r\n            // which is joined implicitly and there is no 'Success' message\r\n            // to indicate that the initial state has arrived.\r\n            // We're relying on the fact that none of the other Glue libs\r\n            // rely on the shared contexts' state, and that the 'contexts'\r\n            // lib is created first so any other domain's success message\r\n            // will arrive after our state, so the contexts will be visible\r\n            // when the Glue promise resolves.\r\n        } else {\r\n            const replayer = _connection.replayer;\r\n            if (replayer) {\r\n                replayer.drain(ContextMessageReplaySpec.name);\r\n            }\r\n        }\r\n    }\r\n\r\n    async function setupBus(): Promise<void> {\r\n        if (!internalConfig.bus) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const initTimer = timer(\"bus\");\r\n        _bus = new MessageBus(_connection, _logger.subLogger(\"bus\"));\r\n        registerLib(\"bus\", _bus, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function setupExternalLibs(externalLibs: Glue42Core.ExternalLib[]): Promise<any> {\r\n        try {\r\n            externalLibs.forEach((lib) => {\r\n                setupExternalLib(lib.name, lib.create);\r\n            });\r\n\r\n            return Promise.resolve();\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    function setupExternalLib(name: string, createCallback: (core: any) => any) {\r\n        const initTimer = timer(name);\r\n        const lib = createCallback(libs);\r\n        if (lib) {\r\n            registerLib(name, lib, initTimer);\r\n        }\r\n    }\r\n\r\n    function waitForLibs(): Promise<object[]> {\r\n        // get all libs that have ready promises and wait for these to be ready\r\n        const libsReadyPromises = Object.keys(libs).map((key) => {\r\n            const lib = libs[key];\r\n            return lib.ready ?\r\n                lib.ready() : Promise.resolve();\r\n        });\r\n\r\n        return Promise.all(libsReadyPromises);\r\n    }\r\n\r\n    function constructGlueObject(): Glue42Core.GlueCore {\r\n\r\n        const feedbackFunc = (feedbackInfo?: Glue42Core.FeedbackInfo) => {\r\n            if (!_interop) {\r\n                return;\r\n            }\r\n            _interop.invoke(\"T42.ACS.Feedback\", feedbackInfo, \"best\");\r\n        };\r\n\r\n        const info: { [key: string]: any } = {\r\n            coreVersion: version,\r\n            version: internalConfig.version\r\n        };\r\n\r\n        glueInitTimer.stop();\r\n\r\n        const glue: Glue42Core.GlueCore & ({ [key: string]: any }) = {\r\n            feedback: feedbackFunc,\r\n            info,\r\n            logger: _logger,\r\n            interop: _interop,\r\n            agm: _interop,\r\n            connection: _connection,\r\n            metrics: _metrics,\r\n            contexts: _contexts,\r\n            bus: _bus,\r\n            version: internalConfig.version,\r\n            userConfig,\r\n            done: () => {\r\n                _logger?.info(`done called by user...`);\r\n                return _connection.logout();\r\n            }\r\n        };\r\n\r\n        // ver performance\r\n        glue.performance = {\r\n            get glueVer() {\r\n                return internalConfig.version;\r\n            },\r\n            get glueConfig() {\r\n                return JSON.stringify(userConfig);\r\n            },\r\n            get browser() {\r\n                return window.performance.timing.toJSON();\r\n            },\r\n            get memory() {\r\n                return (window as any).performance.memory;\r\n            },\r\n            get initTimes() {\r\n                const all = getAllTimers();\r\n                return Object.keys(all).map((key) => {\r\n                    const t = all[key];\r\n                    return {\r\n                        name: key,\r\n                        duration: t.endTime - t.startTime,\r\n                        marks: t.marks,\r\n                        startTime: t.startTime,\r\n                        endTime: t.endTime\r\n                    };\r\n                });\r\n            }\r\n        };\r\n\r\n        // attach each lib to glue\r\n        Object.keys(libs).forEach((key) => {\r\n            const lib = libs[key];\r\n            glue[key] = lib;\r\n        });\r\n\r\n        // construct the config object to be exposed to end user\r\n        // transfer config keys from internalConfig and then ext\r\n        glue.config = {};\r\n\r\n        Object.keys(internalConfig).forEach((k) => {\r\n            glue.config[k] = (internalConfig as any)[k];\r\n        });\r\n\r\n        if (ext && ext.extOptions) {\r\n            Object.keys(ext.extOptions).forEach((k) => {\r\n                glue.config[k] = ext?.extOptions[k];\r\n            });\r\n        }\r\n\r\n        if (ext?.enrichGlue) {\r\n            ext.enrichGlue(glue);\r\n        }\r\n\r\n        if (glue42gd && glue42gd.updatePerfData) {\r\n            glue42gd.updatePerfData(glue.performance);\r\n        }\r\n\r\n        if (glue.agm) {\r\n            const deprecatedDecorator = (fn: any, wrong: string, proper: string) => {\r\n                // tslint:disable-next-line:only-arrow-functions\r\n                return function () {\r\n                    // tslint:disable-next-line:no-console\r\n                    glue.logger.warn(`glue.js - 'glue.agm.${wrong}' method is deprecated, use 'glue.interop.${proper}' instead.`);\r\n                    return fn.apply(glue.agm, arguments);\r\n                };\r\n            };\r\n            // extend glue.agm with legacy support\r\n            const agmAny: any = glue.agm;\r\n            agmAny.method_added = deprecatedDecorator(glue.agm.methodAdded, \"method_added\", \"methodAdded\");\r\n            agmAny.method_removed = deprecatedDecorator(glue.agm.methodRemoved, \"method_removed\", \"methodRemoved\");\r\n            agmAny.server_added = deprecatedDecorator(glue.agm.serverAdded, \"server_added\", \"serverAdded\");\r\n            agmAny.server_method_aded = deprecatedDecorator(glue.agm.serverMethodAdded, \"server_method_aded\", \"serverMethodAdded\");\r\n            agmAny.server_method_removed = deprecatedDecorator(glue.agm.serverMethodRemoved, \"server_method_removed\", \"serverMethodRemoved\");\r\n        }\r\n        return glue;\r\n    }\r\n\r\n    return preloadPromise\r\n        .then(setupLogger)\r\n        .then(setupConnection)\r\n        .then(() => Promise.all([setupMetrics(), setupInterop(), setupContexts(), setupBus()]))\r\n        .then(() => _interop.readyPromise)\r\n        .then(() => {\r\n            return setupExternalLibs(internalConfig.libs || []);\r\n        })\r\n        .then(waitForLibs)\r\n        .then(constructGlueObject)\r\n        .catch((err) => {\r\n            // if there is some some error include the libs object for debugging purposes\r\n            return Promise.reject({\r\n                err,\r\n                libs\r\n            });\r\n        });\r\n};\r\n\r\nif (typeof window !== \"undefined\") {\r\n    (window as any).GlueCore = GlueCore;\r\n}\r\n(GlueCore as any).version = version;\r\n// add default library for ES6 modules\r\n(GlueCore as any).default = GlueCore;\r\n\r\nexport default GlueCore;\r\n","import { Glue42Core } from \"../glue\";\r\nimport { InternalConfig, GDStaringContext } from \"./types\";\r\nimport generate from \"shortid\";\r\nimport Utils from \"./utils/utils\";\r\nimport { ContextMessageReplaySpec } from \"./contexts/contextMessageReplaySpec\";\r\nimport { version as pjsonVersion } from \"../package.json\";\r\nimport { ConnectionSettings } from \"./connection/types\";\r\n\r\nexport default function (configuration: Glue42Core.Config, ext: Glue42Core.Extension, glue42gd: Glue42Core.GDObject | undefined): InternalConfig {\r\n\r\n    let nodeStartingContext: GDStaringContext;\r\n    if (Utils.isNode()) {\r\n        const startingContextString = process.env._GD_STARTING_CONTEXT_;\r\n        if (startingContextString) {\r\n            try {\r\n                nodeStartingContext = JSON.parse(startingContextString);\r\n            } catch {\r\n                // Do nothing - we will continue with the flow as if there is no starting context\r\n            }\r\n        }\r\n    }\r\n\r\n    function getConnection(): ConnectionSettings {\r\n\r\n        const gwConfig = configuration.gateway;\r\n\r\n        const protocolVersion = gwConfig?.protocolVersion ?? 3;\r\n        const reconnectInterval = gwConfig?.reconnectInterval;\r\n        const reconnectAttempts = gwConfig?.reconnectAttempts;\r\n\r\n        const defaultWs = \"ws://localhost:8385\";\r\n        let ws = gwConfig?.ws;\r\n        const sharedWorker = gwConfig?.sharedWorker;\r\n        const inproc = gwConfig?.inproc;\r\n        const webPlatform = gwConfig?.webPlatform ?? undefined;\r\n\r\n        // If running in GD use the injected ws URL\r\n        if (glue42gd) {\r\n            // GD3\r\n            ws = glue42gd.gwURL;\r\n        }\r\n        // if running in Node app, started from GD, use the ws from starting context\r\n        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwURL) {\r\n            ws = nodeStartingContext.gwURL;\r\n        }\r\n\r\n        // if nothing specified use default WS\r\n        if (!ws && !sharedWorker && !inproc) {\r\n            ws = defaultWs;\r\n        }\r\n\r\n        let instanceId: string | undefined;\r\n        let windowId: string | undefined;\r\n        let pid: number | undefined;\r\n        let environment: string | undefined;\r\n        let region: string | undefined;\r\n        const appName = getApplication();\r\n        let uniqueAppName = appName;\r\n        if (typeof glue42gd !== \"undefined\") {\r\n            windowId = glue42gd.windowId;\r\n            pid = glue42gd.pid;\r\n            if (glue42gd.env) {\r\n                environment = glue42gd.env.env;\r\n                region = glue42gd.env.region;\r\n            }\r\n            // G4E-1668\r\n            uniqueAppName = glue42gd.application ?? \"glue-app\";\r\n            instanceId = glue42gd.appInstanceId;\r\n        } else if (Utils.isNode()) {\r\n            pid = process.pid;\r\n            if (nodeStartingContext) {\r\n                environment = nodeStartingContext.env;\r\n                region = nodeStartingContext.region;\r\n                instanceId = nodeStartingContext.instanceId;\r\n            }\r\n        } else {\r\n            // this is the case where this is is running in Glue42 Core V2\r\n            // in this case the windowId of the identity is set by the WebTransport, because it needs to communicate with possible parents\r\n        }\r\n\r\n        // replay specs for core connection\r\n        const replaySpecs = configuration.gateway?.replaySpecs ?? [];\r\n        // inject Context message replay\r\n        replaySpecs.push(ContextMessageReplaySpec);\r\n\r\n        return {\r\n            identity: {\r\n                application: uniqueAppName,\r\n                applicationName: appName,\r\n                windowId,\r\n                instance: instanceId,\r\n                process: pid,\r\n                region,\r\n                environment,\r\n                api: ext.version || pjsonVersion\r\n            },\r\n            reconnectInterval,\r\n            ws,\r\n            sharedWorker,\r\n            webPlatform,\r\n            inproc,\r\n            protocolVersion,\r\n            reconnectAttempts,\r\n            replaySpecs,\r\n        };\r\n    }\r\n\r\n    function getApplication() {\r\n        if (configuration.application) {\r\n            return configuration.application;\r\n        }\r\n\r\n        if (glue42gd) {\r\n            return glue42gd.applicationName;\r\n        }\r\n\r\n        const uid = generate();\r\n        if (Utils.isNode()) {\r\n            if (nodeStartingContext) {\r\n                return nodeStartingContext.applicationConfig.name;\r\n            }\r\n\r\n            return \"NodeJS\" + uid;\r\n        }\r\n\r\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n            return document.title + ` (${uid})`;\r\n        }\r\n\r\n        return uid;\r\n    }\r\n\r\n    function getAuth(): Glue42Core.Auth | undefined {\r\n        if (typeof configuration.auth === \"string\") {\r\n            return {\r\n                token: configuration.auth\r\n            };\r\n        }\r\n\r\n        if (configuration.auth) {\r\n            return configuration.auth;\r\n        }\r\n\r\n        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwToken) {\r\n            return {\r\n                gatewayToken: nodeStartingContext.gwToken\r\n            };\r\n        }\r\n\r\n        if (configuration.gateway?.webPlatform || configuration.gateway?.inproc || configuration.gateway?.sharedWorker) {\r\n            return {\r\n                username: \"glue42\", password: \"glue42\"\r\n            };\r\n        }\r\n    }\r\n\r\n    function getLogger(): { console: Glue42Core.LogLevel; publish: Glue42Core.LogLevel } {\r\n        let config = configuration.logger;\r\n        const defaultLevel = \"warn\";\r\n        if (!config) {\r\n            config = defaultLevel;\r\n        }\r\n\r\n        // console level can be overridden by a gd setting\r\n        let gdConsoleLevel: Glue42Core.LogLevel | undefined;\r\n        if (glue42gd) {\r\n            gdConsoleLevel = glue42gd.consoleLogLevel;\r\n        }\r\n\r\n        if (typeof config === \"string\") {\r\n            return { console: gdConsoleLevel ?? config, publish: defaultLevel };\r\n        }\r\n\r\n        return {\r\n            console: gdConsoleLevel ?? config.console ?? defaultLevel,\r\n            publish: config.publish ?? defaultLevel\r\n        };\r\n    }\r\n\r\n    const connection = getConnection();\r\n    let application: string = getApplication();\r\n    if (typeof window !== \"undefined\") {\r\n        const windowAsAny = window as any;\r\n        const containerApplication = windowAsAny.htmlContainer ?\r\n            `${windowAsAny.htmlContainer.containerName}.${windowAsAny.htmlContainer.application}` :\r\n            windowAsAny?.glue42gd?.application;\r\n        if (containerApplication) {\r\n            application = containerApplication;\r\n        }\r\n    }\r\n\r\n    return {\r\n        bus: configuration.bus ?? false,\r\n        application,\r\n        auth: getAuth(),\r\n        logger: getLogger(),\r\n        connection,\r\n        metrics: configuration.metrics ?? true,\r\n        contexts: configuration.contexts ?? true,\r\n        version: ext.version || pjsonVersion,\r\n        libs: ext.libs ?? [],\r\n        customLogger: configuration.customLogger\r\n    };\r\n}\r\n"],"names":["getMetricTypeByValue","metric","type","MetricTypes","getTypeByValue","value","constructor","Date","serializeMetric","serializedMetrics","values","Object","keys","reduce","memo","key","innerType","composite","defineNestedComposite","description","context","name","normalizeMetricName","path","join","length","getMetricValueByType","now","publishNestedComposite","getTime","Boolean","toString","composeMsgForRootStateMetric","system","merged","flatten","arr","flat","toFlatten","concat","Array","isArray","root","getAggregateState","highestState","sort","a","b","state","msg","forEach","m","idx","slice","aggregateDescription","definition","parent","transport","Error","this","Helpers","push","createMetric","BaseMetric","repo","newValue","updateMetric","_super","metricTypes","__extends","NumberMetric","num","update","incrementBy","ObjectMetric","mergeValues","k","_this","TimestampMetric","options","protocol","init","separator","_transport","_name","_description","_repo","_parent","_path","_buildPath","shadowedSystem","_state","id","_subSystems","_metrics","_getOrCreateMetric","metricObject","expectedType","metricDef","matching","filter","shadowedMetric","existing","catch","me","subSystems","metrics","subSystem","nameSystem","descriptionSystem","match","s","_system","getState","setState","stateDescription","updateSystem","stringMetric","StringMetric","timestampMetric","objectMetric","numberMetric","aggState","shadowedSubSystem","result","createSystem","addSystemMetrics","clickStream","undefined","Repository","rootSystem","useClickStream","navigator","userAgent","document","clickStream_1","documentClickHandler","e","target","timestamp","className","tagName","toLowerCase","href","title","page","window","location","addEventListener","attachEvent","urlMetric","appNameMetric","startUrl","glue42gd","appName","NullProtocol","Promise","resolve","api","initialPublishTimeout","publishInterval","scheduleCollection","PerfTracker","setTimeout","collect","setInterval","collectMemory","collectEntries","memory","performance","JSON","stringify","totalJSHeapSize","usedJSHeapSize","allEntries","getEntries","lastCount","jsonfiedEntries","map","i","toJSON","connection","config","joinPromise","session","replayRepo","replaySystem","ss","_a","Description","Value","createMetricsMsg","send","metricClone","cloneMetric","updateMetricCore","canUpdate","publishMetricsMsg","sendFireAndForget","canUpdateMetric","resolveReadyPromise","domain","onJoined","reconnect","defineRootMetricsMsg","service","instance","shadowedUpdateMetric","stateObj","rootMetric","peer_id","peerId","gw3","disableAutoAppSystem","featureMetric","reportingSystem","def","featureMetricFunc","action","payload","addFAVSupport","perfConfig","pagePerformanceMetrics","enabled","initPerf","createRegistry","errorHandling","_userErrorHandler","callbacks","_handleError","exceptionArtifact","errParam","stack","console","error","add","callback","replayArgumentsArr","callbacksForKey","replayArgument","includes","apply","err","allForKey","acc","element","index","execute","argumentsArr","_i","arguments","results","clear","clearKey","default","settings","logger","CallbackRegistryFactory","gw","facade","connect","_client","message","messageHandler","then","client","InProcTransport","reject","_msg","registry","workerFile","worker","SharedWorker","port","onmessage","data","SharedWorkerTransport","postMessage","Utils","glueDesktop","version","ver","Number","substr","isNaN","_isNode","prototype","call","global","process","promise","t","resolved","rejected","PromiseWrapper","time","timers","timerName","marks","endTime","period","startTime","mark","currentTime","diff","timerObj","stop","WebSocketConstructor","isNode","require","WebSocket","timer","ws","WS","_registry","waitForSocketConnection","info","_running","close","pw","failed","readyState","wsRequests","openSocket","retryInterval","retriesLeft","startupTimer","reconnectInterval","notifyForSocketState","debug","initiateSocket","_b","retries","onerror","reason","seen_1","WeakSet","has","notifyStatusChanged","onclose","onopen","identity","application","wsRequest","status","seed","alphabet","previousSeed","shuffled","nextValue","_seed_","ORIGINAL","reset","setCharacters","_alphabet_","unique","split","item","ind","lastIndexOf","getShuffled","characterIndex","sourceArray","targetArray","r","randomFromSeed","Math","floor","splice","shuffle","characters","lookup","crypto","msCrypto","getRandomValues","random","dest","Uint8Array","number","done","loopCounter","str","randomByte","pow","indexOf","len","counter","previousSeconds","clusterWorkerId","generate","seconds","encode","module","seedValue","exports","workerId","newCharacters","decode","isValid","require$$0","successMessages","errorMessages","_latestOptions","isJoined","tryReconnecting","_connectionOn","disconnected","loggedIn","on","handleSuccessMessage","handleErrorMessage","sm","requestsMap","destination","wasReconnect","handleJoined","requestId","request_id","entry","success","getNextRequestId","tag","skipPeerId","successMsg","_tag","errorMsg","warn","leave","onLeft","connected","datePrefix","datePrefixLen","handleDisconnected","ping","GW3ProtocolImpl","_isLoggedIn","parse","dateMinLen","datePrefixFirstChar","substring","milliseconds","parseInt","ex","msgType","oldToJson","datePrefix_1","loginConfig","username","password","shouldTryLogin","authentication","gatewayToken","getNewGWToken","token","_c","e_1","method","flowName","provider","flowCallback","sessionId","login","secret","helloMsg","globalDomain","domainSession","subLogger","sendOptions","initialLogin","maxRetries","reconnectAttempts","welcomeMsg","Buffer","from","resolvedIdentity","resolved_identity","availableDomains","available_domains","access_token","setLoggedIn","err_1","pingTimer","clearTimeout","promises","sessions","all","domainName","domainLogger","initialLoginAttempts","bind","res","getGWToken","specs","specs_1","spec","specsNames","MessageReplayerImpl","name_1","refCount","this_1","subsRefCount","sub","processMessage","subs","types","isDone","name_2","messages","off","PromisePlus","executor","timeoutMilliseconds","timeoutMessage","timeout","connectionAccepted","handle","handleConnectionAccepted","connectionRejected","handleConnectionRejected","connectionRequest","handleConnectionRequest","parentReady","handleParentReady","parentPing","handleParentPing","platformPing","handlePlatformPing","platformUnload","handlePlatformUnload","platformReady","handlePlatformReady","clientUnload","handleClientUnload","manualUnload","handleManualUnload","setUpMessageListener","setUpUnload","opener","top","parentType","WebPlatformTransport","publicWindowId","windowId","event","waitParent","initiateRemoteConnection","connectionResolve","connectionReject","myClientId","bridgeInstanceId","request","glue42core","clientId","clientType","defaultTargetString","connectionRequestTimeout","parentPingResolve","parentPingTimeout","checkMessageTypeValid","messageType","ownWindowId","handleAcceptanceOfMyRequest","handleAcceptanceOfGrandChildRequest","parentWindowId","applicationName","child","children","find","c","grandChildId","source","origin","rejectConnectionRequest","iAmConnected","typeToValidate","rejection","CallbackFactory","inproc","sharedWorker","webPlatform","isTrace","canPublish","onConnectedChanged","handleConnectionChanged","onMessage","handleTransportMessage","replaySpecs","replayer","Connection","protocolVersion","sendObject","isObjectBasedTransport","createObjectMessage","trace","strMessage","createStringMessage","messageHandlers","ids","isLoggedIn","authRequest","open","logout","authToken","handlers","handlerId","handler","loggerError","log","_connected","msgObj","processStringMessage","processObjectMessage","distributeMessage","order","logFn","loggerFullName","includeTimeAndLevel","customLogFn","Logger","existingSub","subLoggers","level","_publishLevel","publishLevel","_consoleLevel","consoleLevel","publishMessage","compareWith","loggerName","interop","Interop","methods","InteropMethodName","invoke","prefix","date","getHours","getMinutes","getSeconds","getMilliseconds","toPrint","GW_MESSAGE_CREATE_CONTEXT","GW_MESSAGE_ACTIVITY_CREATED","GW_MESSAGE_ACTIVITY_DESTROYED","GW_MESSAGE_CONTEXT_CREATED","GW_MESSAGE_CONTEXT_ADDED","GW_MESSAGE_SUBSCRIBE_CONTEXT","GW_MESSAGE_SUBSCRIBED_CONTEXT","GW_MESSAGE_UNSUBSCRIBE_CONTEXT","GW_MESSAGE_DESTROY_CONTEXT","GW_MESSAGE_CONTEXT_DESTROYED","GW_MESSAGE_UPDATE_CONTEXT","GW_MESSAGE_CONTEXT_UPDATED","GW_MESSAGE_JOINED_ACTIVITY","ContextMessageReplaySpec","msg.GW_MESSAGE_CREATE_CONTEXT","msg.GW_MESSAGE_ACTIVITY_CREATED","msg.GW_MESSAGE_ACTIVITY_DESTROYED","msg.GW_MESSAGE_CONTEXT_CREATED","msg.GW_MESSAGE_CONTEXT_ADDED","msg.GW_MESSAGE_SUBSCRIBE_CONTEXT","msg.GW_MESSAGE_SUBSCRIBED_CONTEXT","msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT","msg.GW_MESSAGE_DESTROY_CONTEXT","msg.GW_MESSAGE_CONTEXT_DESTROYED","msg.GW_MESSAGE_UPDATE_CONTEXT","msg.GW_MESSAGE_CONTEXT_UPDATED","msg.GW_MESSAGE_JOINED_ACTIVITY","contextId","isAnnounced","activityId","GW3ContextData","updateCallbacks","hasCallbacks","applyContextDelta","delta","deepClone","commands","command","deletePath","setValueToPath","added_1","added","updated_1","updated","removed","mergeObjectsProperties","obj","hash","WeakMap","Set","get","RegExp","flags","create","set","Map","val","assign","what","withWhat","right","left","deepEqual","x","y","p","hasOwnProperty","pathArr","InvokeStatus","_connection","_logger","_gw3Session","subscribeToContextCreatedMessages","subscribeToContextUpdatedMessages","subscribeToContextDestroyedMessages","drain","handleContextCreatedMessage","handleContextUpdatedMessage","handleContextDestroyedMessage","GW3Bridge","_protocolVersion","contextsDomainInfo","d","uri","_gw3Subscriptions","contextName","_contextNameToData","_contextNameToId","lifetime","createContextMsg","context_id","_contextIdToName","contextData","ContextData","currentContext","createContext","calculatedDelta","calculateContextDeltaV2","calculateContextDeltaV1","gwResponse","handleUpdated","updaterId","setPathSupported","setPaths","pathValues","pathValues_1","pathValue","pathValues_2","_","subscribe","_d","_r","un","unsubscribe","thisCallbackSubscriptionNumber","_nextCallbackSubscriptionNumber","clone","hadCallbacks","joinedActivity","sentExplicitSubscription","sendSubscribe","subscriptionKey","sendUnsubscribe","extraData","oldContext","invokeUpdateCallbacks","createdMessageTypes_1","createdMessageType","contextCreatedMsg","activity_id","updatedMessageTypes_1","updatedMessageType","contextUpdatedMsg","justSeen","context_snapshot","updater_id","updateCallbackIndex","updateCallback","destroyedMessageTypes_1","destroyedMessageType","destroyedMsg","to","_bridge","ContextsModule","checkName","checkData","checkPath","setPath","paths","paths_1","destroy","successCallback","errorCallback","rejectAfter","ms","clearTimeoutIfThere","configuration","Client","callProtocolSubscribe","targetServers","stream","successProxy","errorProxy","methodResponseTimeout","waitTimeoutMs","promisify","methodDef","method_response_timeout","wait_for_method_timeout","delayTillNow","currentServers","getServerMethodsByFilterAndTarget","retry_1","streamInfo","methodFilter","filterCopy","getServers","serverMethodMap","server","getMethods","getMethodsForInstance","onMethodAdded","onMethodRemoved","onServerAdded","onServerRemoved","onServerMethodAdded","onServerMethodRemoved","argumentObj","additionalOptions","methodDefinition","methodResponseTimeoutMs","serversMethodMap","tryToAwaitForMethods","supportsStreaming","objectTypes","metadata","errorObj","called_with","executed_by","returned","additionalOptionsCopy","invokePromises","serversMethodPair","invId","invokePromise","race","invocationId","invocationMessages","getInvocationResultObj","every","getInvokePromise","invocationResults","calledWith","all_return_values","invokeMessage","Success","allValues","currentValue","all_errors","allErrors","currError","invResult","interval","clearInterval","matches","myMatches","serverMethodPair","instanceMatch","localMachine","isLocal","instanceFilter","instanceDefinition","containsProps","repoMethod","prop","isMatch","filterValue","repoMethodValue","filterValueEl","isSubset","superObj","subObj","ele","String","methodMatch","matchingServers","resultMethodsObject","methodKey","identifier","servers","prev","current","matchingMethods","filterByTarget","subscription","ServerSubscription","branchKey","closeSingleSubscription","pushDataToSingle","requestContext","Request","acceptRequestOnBranch","branch","rejectRequest","onSubRequest","rc","rm","handleSubRequest","onSubAdded","handleSubAdded","onSubRemoved","handleSubRemoved","ServerStreaming","streamCallbacks","subscriptionRequestHandler","subscriptionAddedHandler","subscriptionRemovedHandler","ServerBranch","getSubscriptionList","closeAllSubscriptions","pushData","_protocol","_repoMethod","_server","ServerStream","bList","getBranchList","branches","def2","accepts","displayName","returns","unregister","serverRepository","streaming","onInvoked","onMethodInvoked","Server","streamDef","existingStream","streamMethodDefinition","getList","some","serverMethod","accept","protocolState","createStream","streamUserObject","updateRepoMethod","repoId","remove","wrappedCallbackFunction","resultCallback","args","resultValue","userCallback","registerCore","wrappedCallback","resultCalled_1","methodResult","userCallbackAsync","forStream","unregisterWithPredicate","methodToBeRemoved","removeMethodsOrStreams","filterPredicate","methodsOrStreamsToRemove","methodsToRemove","methodUnregPromises","addAsCurrentlyUnregistering","methodName","currentlyUnregistering","theFunction","unregisterInProgress","register","methodToExecute","invocationArgs","unStrException","_value","methodInvocationResult","API","wrapped","methodsForInstance","getStreams","refreshWrappedObject","refresh","InstanceWrapper","user","pid","machine","environment","region","hideMethodSystemFlags","myServer","wrapper","unwrappedInstance","ClientRepository","serverId","serverEntry","unwrap","methodId","removeServerMethod","createMethodIdentifier","that","gatewayId","display_name","object_types","input_signature","result_signature","getServersByMethod","clientMethodDefinition","methodsCount","extractMethodsFromServers","hideServerMethodSystemFlags","unsubscribeFunc","serversWithMethodsToReplay","returnUnsubWithDelayedReplay","methodsToReplay","unsubCalled","removeServerById","methodInfo","allServers","collectionToReplay","clientMethods","entries","ServerRepository","nextId","TypeError","SUBSCRIPTION_REQUEST","SUBSCRIPTION_ADDED","SUBSCRIPTION_REMOVED","repository","handleAddInterest","handleRemoveInterest","streamingMethod","subscriptionsMap","branchKeyToStreamIdMap","streamId","getStreamId","subscription_id","subscribeMsg","stream_id","sendSubscriptionFailed","br","dropSubscriptionMessage","subscriptionsToClose","drop","allSubscriptions","onSubscriptionLifetimeEvent","getById","method_id","eventName","handlerFunc","nextStreamId","getServerById","caller_id","arguments_kv","subscriptionId","errorMessage","reason_uri","ERR_URI_SUBSCRIPTION_FAILED","needleBranch","getNextStreamId","clientRepository","handleInvokeMessage","ServerProtocol","isStreaming","registerMsg","restrictions","invocation_id","closeMultipleSubscriptions","callerId","subscriptionData","UserSubscription","params","trackedServers","pair","dataCallback","onData","queued","dataItem","closedCallback","onClosed","onConnected","newSub","STATUS_AWAITING_ACCEPT","STATUS_SUBSCRIBED","ERR_MSG_SUB_FAILED","ON_CLOSE_MSG_CLIENT_INIT","errorResponse","subLocalKey","pendingSub","subscriptionsList","timeoutId","callArgs","callOnClosedHandlers","acceptingServer","subscriptionIdToLocalKeyMap","isFirstResponse","setNewSubscription","serverInstance","trackedServersFound","isPrivateData","oob","sendingServerId","receivedStreamData","requestArguments","private","onDataHandlers","queuedData","expectedNewLength","closers","handleSubscribed","handleEventData","handleSubscriptionCancelled","ClientStreaming","getNextSubscriptionLocalKey","registerSubscription","server_id","handleErrorSubscribing","nextSubLocalKey","subsInfo","localKey","closeSubscription","closingServer","closersCount","closingServerId","handlePeerAdded","handlePeerRemoved","handleMethodsAddedMessage","handleMethodsRemovedMessage","ClientProtocol","handleResultMessage","handleInvocationError","drainSubscriptions","newPeerId","new_peer_id","remoteId","meta","local","serverInfo","addServer","removedPeerId","removed_id","addServerMethod","methodIdList","libConfig","readyPromise","existingSubscriptions_1","registeredMethods","registeredMethods_1","registerAsync","handleReconnect","protocolPromise","gW3ProtocolFactory","serverRemoved","serverAdded","serverMethodRemoved","serverMethodAdded","methodRemoved","methodAdded","topic","routingKey","removeEmptyValues","routing_key","target_identity","response","subscriptions","keysMatch","watchOnEvent","MessageBus","cleaned","obj1","obj2","keysObj1","allMatch","GlueCore","userConfig","ext","gdVersion","getGDMajorVersion","preloadPromise","gdPreloadPromise","_interop","_contexts","_bus","_allowTrace","glueInitTimer","internalConfig","nodeStartingContext","startingContextString","env","_GD_STARTING_CONTEXT_","getApplication","uid","applicationConfig","instanceId","gwConfig","gateway","gwURL","uniqueAppName","appInstanceId","pjsonVersion","getConnection","windowAsAny","containerApplication","htmlContainer","containerName","bus","auth","gwToken","getAuth","gdConsoleLevel","defaultLevel","consoleLogLevel","publish","getLogger","contexts","libs","customLogger","prepareConfig","registerLib","inner","initTime","initEndTime","initStartTime","ready","n","setupInterop","initTimer","agmConfig","setupContexts","hasActivities","activities","setupBus","setupExternalLibs","externalLibs","lib","createCallback","setupExternalLib","authPromise","authConfig","metricsPublishingEnabledFunc","getMetricsPublishingEnabled","shortid","libsReadyPromises","coreVersion","glue","feedback","feedbackInfo","agm","glueVer","glueConfig","browser","timing","initTimes","duration","extOptions","enrichGlue","updatePerfData","deprecatedDecorator","fn","wrong","proper","agmAny","method_added","method_removed","server_added","server_method_aded","server_method_removed"],"mappings":"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"}